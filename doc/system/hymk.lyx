#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{times}
\usepackage[
    a4paper,     
    dvips,        
    pdftitle={Aufbau und Implementierung des HydrixOS Kernels - hymk},
    pdfauthor={Friedrich Graeter},
    colorlinks,   
    linkcolor=black,
    urlcolor=blue,
    citecolor=blue]{hyperref} 
\end_preamble
\language ngerman
\inputencoding auto
\fontscheme helvet
\graphics default
\paperfontsize 12
\spacing single
\papersize a4paper
\use_geometry true
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 1.5cm
\headsep 0.5cm
\footskip 1cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language german
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes true
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
lhead{}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
rhead{}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
lfoot{}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
cfoot{- 
\backslash
thepage
\backslash
 -}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
rfoot{}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
chead{}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
renewcommand{
\backslash
headrulewidth}{0.0pt}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
renewcommand{
\backslash
footrulewidth}{0.1pt}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Title
Aufbau und Implementierung 
\newline
des 
\newline
HydrixOS Kernels 
\newline

\emph on
hymk
\end_layout

\begin_layout Author
Friedrich Gräter
\end_layout

\begin_layout Subsubsection
Lizenz
\end_layout

\begin_layout Standard
This work is licensed under the terms of the 
\emph on
Creative Commons Attribution-ShareAlike License
\emph default
.
 You are free to
\end_layout

\begin_layout Itemize
to copy, distribute, display and perform this work
\end_layout

\begin_layout Itemize
to make derivative works
\end_layout

\begin_layout Itemize
to make commercial use of this work
\end_layout

\begin_layout Standard
Under the following conditions:
\end_layout

\begin_layout Description
Attribution.
 You must give the original author credit.
\end_layout

\begin_layout Description
Share\InsetSpace ~
alike.
 If you alter, transfer, or build upon this work, you may distribute the
 resulting work only under a license identical to this one.
\end_layout

\begin_layout Itemize
For any reuse or distribution, you must make clear to others the license
 terms of this work.
\end_layout

\begin_layout Itemize
Any of these conditions can be waived if you get permission of the copyright
 holder.
\end_layout

\begin_layout Standard
Your fair use and other rights are not affected by the above.
 This was a human-readable summary of the legal code (the full license).
 
\newline

\end_layout

\begin_layout Standard
\align center

\series bold
To view a copy of the full license, visit 
\end_layout

\begin_layout Standard
\align center
\begin_inset LatexCommand \htmlurl{http://creativecommons.org/licenses/by-sa/2.0/}

\end_inset

 
\end_layout

\begin_layout Standard
\align center

\series bold
or send a letter to
\series default
 
\newline

\end_layout

\begin_layout Standard
\align center
Creative Commons, 
\end_layout

\begin_layout Standard
\align center
559 Nathan Abbott Way, 
\end_layout

\begin_layout Standard
\align center
Stanford, California 94305, 
\end_layout

\begin_layout Standard
\align center
USA.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsubsection*
Vorwort
\end_layout

\begin_layout Standard
Das Ziel des HydrixOS-Betriebssystemprojekt soll ein in jeder Hinsicht offenes,
 flexibles, modulares, stabiles, zuverlässiges, portables und architekturtranspa
rentes Betriebssystem sein, das leistungsfähig und in seiner Arbeitsweise
 professionell und verständlich organisiert ist.
 
\end_layout

\begin_layout Standard
Um dieses doch sehr hochgesteckten Ziel zu erreichen, müssen bereits auf
 unterster Ebene die Grundsteine richtig gelegt werden.
 Daher ist ein leistungsfähiger und möglichst einfacher Mikrokernel unbedingt
 erforderlich.
 
\end_layout

\begin_layout Standard
Der neue HydrixOS-Kernel, der den Namen 
\emph on
hymk
\emph default
 (hymk - HydrixOS µ-Kernel) trägt, soll ein vollständiger Mikrokernel sein,
 der auf einer extrem vereinfachten, synchronen und paging-basierten IPC
 aufbaut.
 Der neue Kernel soll grundsätzlich an die Standardaufgaben eines Client-Server-
Systems orientiert werden, bei dem im wesentlichen die Interaktion zwischen
 Clients und Servern über virtuelle Dateien geschieht.
 Portabilität ist bei diesem Kernel mehr Sache der vom Kernel angebotenen
 Konzepte, als eine Sache der Schnittstellen an sich.
 Gleichzeitig soll er aber auch alles bieten, um Architekturtransparenz
 zu realisieren - nur bietet er jetzt nur noch Mechanismen zur Unterstützung
 von dieser an.
 Die eigentliche Umsetzung der Virtualisierungssoftware, CPU-Emulatoren
 und Programmübersetzern soll nun vollständig im Benutzer-Modus stattfinden.
 Zu diesen Unterstützungsfeatures gehört unter anderem die Möglichkeit Threads
 vollständig fernzusteuern und deren Systemaufrufe und Exceptions an andere
 Threads im Benutzer-Modus weiterzuleiten.
\newline

\end_layout

\begin_layout Standard
Diese Dokument soll einen Überblick über die grundlegenden Konzepte des
 Betriebssystem bieten.
 Es setzt dabei gewisse Grundkenntnisse über die üblichen internen Strukturen
 von Betriebssystemen voraus.
 Ferner wird schließlich die auf der x86-Implementierung verwendete Schnittstell
e erläutert.
 Im letzten Teil wird dann die konkrete Implementierung des Kernels dokumentiert.
 Das Dokument sollte in der vorgesehenen Reihenfolge gelesen werden, da
 jeder Teil die jeweils vorausgehenden Teile des Dokuments voraussetzt.
\newline

\end_layout

\begin_layout Standard
\begin_inset LatexCommand \tableofcontents{}

\end_inset


\end_layout

\begin_layout Part
Architektur des hymk
\end_layout

\begin_layout Chapter
Grundlegende Konzepte
\end_layout

\begin_layout Section
Virtueller Adressraum
\end_layout

\begin_layout Subsection
Klärung des Begriffs
\end_layout

\begin_layout Standard
Eines der grundlegensten Konzepte des 
\emph on
hymk
\emph default
 ist das Konzept des 
\emph on
virtuellen Adressraums
\begin_inset LatexCommand \index{virtueller Adressraum}

\end_inset


\emph default
 (
\emph on
virtual address space
\emph default
).
 Ein virtueller Adressraum ist ein kontinuierlicher Adressraum, der aus
 Speicherseiten (
\emph on
pages
\emph default
) fester, plattformabhängiger Größe besteht (auf x86-Plattformen sind es
 4 KiB).
 Er ist deshalb virtuell, weil Speicherung und Zusammensetzung dieses Adressraum
s mit keinem 
\emph on
physikalischen Adressraum
\begin_inset LatexCommand \index{physikalischer Adressraum}

\end_inset


\emph default
 (z.B.
 dem RAM) übereinstimmen muss.
 Der Inhalt jeder Speicherseite kann an einem völlig beliebigen Ort gespeichert
 sein, der in keiner Beziehung mit den restlichen Speicherseiten des virtuellen
 Adressraums steht.
 So können zwei Seiten, die in einem virtuellen Adressraum direkt nebeneinander
 liegen, an völlig unterschiedlichen, weit auseinander liegenden Plätzen
 im physikalischen Adressraum gespeichert sein.
 
\end_layout

\begin_layout Standard
Ein solcher Speicherort, der den Inhalt einer Speicherseite enthält, wird
 als 
\emph on
Seitenrahmen
\begin_inset LatexCommand \index{Seitenrahmen}

\end_inset


\emph default
 (
\emph on
page frame
\emph default
) bezeichnet.
 Normalerweise liegen diese Seitenrahmen irgendwo über das RAM des Rechners
 verteilt.
 
\end_layout

\begin_layout Standard
Sie können aber rein prinzipiell auch auf eine Festplatte ausgelagert werden,
 um einen 
\emph on
virtuellen Arbeitsspeicher
\begin_inset LatexCommand \index{virtueller Arbeitsspeicher}

\end_inset


\emph default
 zu realisieren.
 Dazu werden die Seiten speziell markiert, so dass ein Zugriff auf diese
 automatisch an einen Systemdienst - den sog.
 
\emph on
Paging Daemon
\begin_inset LatexCommand \index{Paging Daemon}

\end_inset


\emph default
 (
\emph on
hyPageD
\emph default
)
\begin_inset LatexCommand \index{hyPageD}

\end_inset

 weitergeleitet wird, damit dieser die Speicherseite wieder in das RAM zurückhol
en kann.
\end_layout

\begin_layout Standard
Prinzipiell ist jeder virtueller Adressraum von einem anderen unabhängig
 und somit vor unerlaubten Zugriff von Programmen geschützt, die nicht in
 diesem Adressraum arbeiten.
 Um jedoch einen schnellen Datenaustausch möglich zu machen, können Seitenrahmen
 von mehreren virtuellen Adressräumen gemeinsam genutzt werden.
 Dieses Verfahren wird öfters als 
\begin_inset Quotes gld
\end_inset


\emph on
memory sharing
\emph default

\begin_inset Quotes grd
\end_inset


\begin_inset LatexCommand \index{memory sharing}

\end_inset

 oder 
\begin_inset Quotes gld
\end_inset


\emph on
shared memory
\emph default

\begin_inset Quotes grd
\end_inset


\begin_inset LatexCommand \index{shared memory}

\end_inset

 bezeichnet.
\end_layout

\begin_layout Standard
Zum Schluß muss eine Speicherseite nicht zwingend einem Seitenrahmen zugewiesen
 werden.
 Normalerweise hat ein virtueller Adressraum eine Größe von 4 GiB (
\begin_inset Formula $2^{32}$
\end_inset

 Byte) oder gar von 
\begin_inset Formula $2^{64}$
\end_inset

 Bytes, so dass auf den derzeit verfügbaren Architekturen gar nicht genug
 Seitenrahmen zur Verfügung ständen, um den Adressraum auszufüllen.
 Daher werden die meisten Seiten eines virtuellen Adressraums gar nicht
 mit einem Seitenrahmen verknüpft sein.
 Ein Zugriff auf solche unverknüpften Speicherseiten führt meist zu einer
 Exception.
 
\end_layout

\begin_layout Standard
Da aber natürlich ein normales Programm nichts von Speicherseiten und Seitenrahm
en wissen will und einfach nur auf seinen Speicher zugreifen können will,
 muss das Konzept des virtueller Adressraums bereits auf der Ebene der CPU
 durch eine sog.
 
\emph on
Memory Managment Unit
\begin_inset LatexCommand \index{MMU}

\end_inset


\emph default
 (
\emph on
MMU
\emph default
) unterstützt werden.
 Die Aufgabe einer MMU ist die transparente Übersetzung virtueller Adressen
 in physikalische Adressen bei jedem Speicherzugriff eines Programms (um
 dies zu beschleunigen gibt es sog.
 
\emph on
Translation Lookaside Buffers
\emph default
, die Übersetzungen zwischenspeichern).
 Der virtuelle Adressraum ist also ein Konzept, die bereits auf Hardwareebene
 umgesetzt wird und vom Kernel nur noch gesteuert werden muss.
\end_layout

\begin_layout Subsection
Verwaltung virtueller Adressräume
\end_layout

\begin_layout Standard
Ein virtueller Adressraum wird über sog.
 
\emph on
Seitentabellen 
\emph default
(
\emph on
page tables
\emph default
) verwaltet.
 In diesen Seitentabellen sind für jede Speicherseite 
\emph on
Seitendeskriptoren 
\emph default
(
\emph on
page descriptors
\emph default
) enthalten, die die Adresse des Seitenrahmens angeben, der mit der jeweiligen
 Speicherseite assoziiert ist.
 Außerdem enthalten sie eine Reihe weiterer Informationen, die spezielle
 Zugriffsrechte auf die Seite definieren.
 
\end_layout

\begin_layout Standard
Da in einem normalen virtuellen Adressraum der größte Teil des Speichers
 ungenutzt bleibt, wäre es Speicherverschwendung, trotzdem für alle nicht
 benötigten Speicherseiten eigene Seitendeskriptoren zu speichern.
 Statt dessen organisiert man die Tabelle mit Hilfe eines zwei- oder mehrstufige
n Verfahrens.
 An der Spitze eines zweistufigen Modells steht ein 
\emph on
Seitenverzeichnis 
\emph default
(
\emph on
page directory
\emph default
), das z.B.
 für alle 4 MiB (1024 Speicherseiten bei 4 KiB Seitengröße) die Adresse
 einer Seitentabelle beschreibt, die dann die tatsächlichen Deskriptoren
 für die jeweiligen Speicherseiten ihres Bereichs enthält.
 Wenn ein größerer Speicherbereich nicht genutzt wird, müsen für ihn weder
 Speicherseiten, noch Seitentabellen reserviert werden, da der Eintrag für
 die jeweilige Seitentabelle im Seitenverzeichnis einfach leer gelassen
 wird.
\end_layout

\begin_layout Standard
Um die interne Organisation und Verwaltung eines virtuellen Adressraums
 kümmert sich alleine der Kernel, da die damit verbundenen Strukturen zu
 sehr plattformabhängig sind.
 Für den Programmierer existieren weder Seitentabellen, noch Seitenverzeichnisse.
 Wenn er mit der virtuellen Speicherverwaltung überhaupt in Kontakt tritt,
 dann nur dann, wenn es um die Zugriffsflags geht, die für Speicherseiten
 gesetzt werden können.
 Diese Flags sind plattformunabhängig definiert - auch wenn sie nicht zwingend
 auf jeder Plattform umgesetzt werden können.
 Derzeit sind es folgende Flags
\begin_inset Foot
status collapsed

\begin_layout Standard
Es sei darauf hingewiesen, dass derzeit weitere Flags, die für die Implementieru
ng eines Seitenauslagerungsmechanismuses benötigt werden könnten (z.B.
 Zugriffsprüfung) bewusst noch nicht mit aufgenommen wurden, da die Seitenauslag
erung unter HydrixOS erst zu späterer Zeit implementiert werden kann und
 voreilige Festlegungen vermieden werden sollten.
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
Lesezugriff erlaubt
\end_layout

\begin_layout Itemize
Schreibzugriff erlaubt (bei einigen Plattformen, wie x86, setzt Schreibzugriff
 Lesezugriff voraus)
\end_layout

\begin_layout Itemize
Ausführung erlaubt (auf x86 nicht seperat definierbar)
\end_layout

\begin_layout Itemize
Schreibzugriff nur für den Kernel erlaubt
\end_layout

\begin_layout Itemize
Speicherseite ist für das 
\emph on
Copy-On-Write
\emph default

\begin_inset LatexCommand \index{Copy-On-Write}

\end_inset

-Verfahren selektiert
\end_layout

\begin_layout Itemize
Speicherseite ist vom Caching durch die CPU ausgeschlossen
\end_layout

\begin_layout Subsection
Aufbau eines virtuellen Adressraums
\end_layout

\begin_layout Standard
Je nach Plattform ist der Aufbau des virtuellen Adressraums vorgeben.
 Er teilt sich normalerweise in einen Kernel-Adressraum und einen Benutzer-Adres
sraum.
 Der Benutzer-Adressraum kann in jedem virtuellen Adressraum völlig unterschiedl
ich zusammengesetzt sein.
 Der Kernel-Adressraum bleibt in allen virtuellen Adressräumen von seiner
 Zusammensetzung her identisch und enthält Kernel-Code und Daten, sowie
 die sogenannten 
\emph on
Info-Pages
\emph default
.
 Die Info-Pages sind ein Bereich des Kernel-Adressraums, der Informationen
 über das Systems und alle Systemdeskriptoren enthält.
 Dadurch können Programme Systeminformationen ohne einen Systemaufruf aus
 dem Benutzer-Modus heraus abrufen.
\end_layout

\begin_layout Standard
Ferner ist meist die erste und die letzte Speicherseite jedes Adressraums
 komplett gesperrt, um Null-Pointerzugriffe leichter aufdecken zu können.
\end_layout

\begin_layout Section
Subjekte
\end_layout

\begin_layout Subsection
Begriffsklärung
\end_layout

\begin_layout Standard
Ein Subjekt ist unter HydrixOS alles, das als solches Aktionen an Systemobjekten
 ausführen kann oder in dessen Namen Aktionen ausgeführt werden können.
 Der 
\emph on
hymk
\emph default
 kennt grundsätzlich vier Sorten von Subjekten:
\end_layout

\begin_layout Itemize
Platzhalter (Typ 0)
\end_layout

\begin_layout Itemize
Threads (Typ 1)
\end_layout

\begin_layout Itemize
Prozesse (Typ 2)
\end_layout

\begin_layout Itemize
Prozessgruppen (Typ 4)
\end_layout

\begin_layout Standard
Jedes Subjekt wird durch seine einmalige 
\emph on
Subjekt-ID
\emph default
 (
\emph on
SID
\emph default
) idendifiziert.
 Diese Subjekt-ID ist eine 32-Bit-Zahl, die einen 8-bit Header enthält,
 der den Typ des Subjekts beschreibt (siehe obige Typnummer).
 Die restlichen 24-Bit der Zahl enthalten die Nummer des jeweiligen Subjekts,
 wobei die Nummern der unterschiedlichen Typen sich überschneiden dürfen.
 Die Anzahl der möglichen SIDs ist bei Threads und Prozessen plattformmäßig
 beschränkt (bei x86 auf 4096).
\end_layout

\begin_layout Subsection
Platzhalter
\end_layout

\begin_layout Standard
Das System definiert als Subjekte drei Platzhalter, die immer dann verwendet
 werden, wenn eine ganz besondere Art von Subjekt-Gruppe symbolisch dargestellt
 werden soll:
\end_layout

\begin_layout Itemize
Das 
\emph on
invalid subject
\emph default
 (
\family typewriter
0x00FFFFFF
\family default
) wird immer dann verwendet, wenn eine ungültige Subjekt-ID angegeben werden
 soll.
\end_layout

\begin_layout Itemize
Das 
\emph on
null subject 
\emph default
(
\family typewriter
0x00000000
\family default
) wird immer dann verwendet, wenn als Subjekt-ID ein gültiges, aber rechteloses
 Subjekt definiert werden soll.
\end_layout

\begin_layout Itemize
Das 
\emph on
kernel subject 
\emph default
(
\family typewriter
0x00000001
\family default
) wird immer dann verwendet, wenn der Kernel als Subjekt auftritt.
 Da der Kernel weder als Thread, noch als Prozess auftreten kann, besitzt
 er einen eigenen Platzhalter.
\end_layout

\begin_layout Subsection
Threads
\end_layout

\begin_layout Standard
Threads sind Subjekte, die ausführenden Programmcode beschreiben sollen.
 Ein Thread ist einem bestimmten virtuellen Adressraum zugeordnet, indem
 sein Programmcode, seine Daten und seinen Stack enthalten ist.
 Diese Zuordnung findet über einen Prozess statt, bei dem der Thread Mitglied
 ist.
 
\end_layout

\begin_layout Standard
Grundsätzlich besitzt ein Thread zwei Stacks: einen User-Mode-Stack der
 von dem Thread normalerweise während der Ausführung im Benutzermodus verwendet
 wird und einen Kernel-Mode-Stack, der immer dann verwendet wird, wenn dem
 Thread die CPU-Zeit entzogen worden ist und sein Arbeitszustand vom Kernel
 gespeichert werden muss oder wenn der Thread in den Kernel-Modus wechselt,
 um dort einen Systemaufruf auszuführen.
\end_layout

\begin_layout Standard
Jeder Thread besitzt eine statische Priorität, die vom Scheduler verwendet
 wird, um festzulegen wie viel Zeit (effektive Priorität) der Thread pro
 Scheduling-Durchlauf zur Ausführung zugewiesen wird, ehe er wieder verdrängt
 und durch einen anderen ersetzt wird.
 Dies ist genauer im Kapitel zum Scheduling-Algorithmus erklärt.
\end_layout

\begin_layout Standard
Grundsätzlich kann ein Thread sich in einem von vier Betriebsmodi befinden:
\end_layout

\begin_layout Itemize
Rechenbereit - Der Thread wartet auf Wiedererhalten der CPU-Zeit
\end_layout

\begin_layout Itemize
Rechnend - Der Thread wird auf einer CPU derzeit ausgeführt
\end_layout

\begin_layout Itemize
Wartend - Der Thread wartet auf eintreffende Nachrichten oder auf die Empfangsbe
reitschaft eines anderen Threads
\end_layout

\begin_layout Standard
Um allgemein Schutzmaßnahmen zu realisieren kann ein Thread die Kommunikation
 mit ihm auf bestimmte Prozesse oder Threads einschränken.
\end_layout

\begin_layout Standard
Grundsätzlich kann ein Thread nur durch einen Thread des eigenen Prozesses
 beendet werden.
 Zusätzlich können Threads die einem sog.
 
\emph on
root-
\emph default
Prozess angehören einen fremden Thread beenden.
 Ein Thread kann sich nicht selbst beenden, da normalerweise für die Beendigung
 eines Threads Datenstrukturen vernichtet werden müssen, die der Thread
 zum Betrieb auch während seiner Beendigung benötigt
\begin_inset Foot
status collapsed

\begin_layout Standard
Die HydrixOS-API wird jedoch diese Einschränkung mit Hilfe sog.
 Thread-Pakete verbergen, so dass aus Sicht eines Programmierers ein Thread
 sich auch selbst beenden kann.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Prozesse
\end_layout

\begin_layout Standard
Prozesse sind eine Kombination eines virtuellen Adressraums und eines oder
 mehrerer Threads, die bei ihm Mitglied sind.
 Mit Hilfe eines Prozesses, können diese Threads als eine Einheit auftreten.
 Ein Prozess kann in den 
\emph on
root-
\emph default
Modus gewechselt werden, wodurch dessen Threads bestimmte geschützte Systemaufru
fe ausführen kann.
 Dieser Wechsel wiederum kann nur durch Prozesse durchgeführt werden, die
 sich selbst im 
\emph on
root
\emph default
-Modus befinden.
\end_layout

\begin_layout Standard
Ein Prozess hat einen sog.
 
\emph on
controller thread
\begin_inset LatexCommand \index{controler thread}

\end_inset


\emph default
, der immer dann verwendet wird, wenn bei einer Thread-spezifischen Aktion
 nicht die SID eines Threads, sondern nue die eines Prozesses bekannt ist.
 In Client/Server-Systemen kann dieser Thread die Funktion des Anmelde-Threads
 des Servers übernehmen, da Clients dann nur noch die Prozess-SID des Servers
 wissen müssen und die SID des 
\emph on
controller threads 
\emph default
mit Hilfe der Prozesstabelle in Erfahrung bringen können.
\end_layout

\begin_layout Standard
Erstellt ein Therad einen neuen Prozess, so darf der Thread den (dann noch
 leeren) virtuellen Adressraum des neuen Prozesses mit neuen Seitenrahmen
 anfüllen.
\end_layout

\begin_layout Standard
Ein Prozess existiert grundsätzlich nur solange, solange er einen Thread
 besitzt.
 Werden alle seiner Threads beendet, so wird auch er beendet.
 Ein Prozess kann aber in den sog.
 
\begin_inset Quotes gld
\end_inset

Zombie-Modus
\begin_inset Quotes grd
\end_inset

 (oder auch 
\begin_inset Quotes gld
\end_inset

Defunct-Modus
\begin_inset Quotes grd
\end_inset

 genannt) gesetzt werden.
 In diesem Zustand können keine Threads von ihm mehr ausgeführt werden und
 sein Speicher kann freigegeben werden.
 Dieser Zwischenzustand ist erforderlich, da in vielen Fällen ein bestimmter
 Prozess gezielt unterbrochen werden können soll.
\end_layout

\begin_layout Subsection
Prozessgruppen
\end_layout

\begin_layout Standard
Als Übergruppe von Prozessen können Prozessgruppen auftreten.
 Der Kernel verfeinert das Konzept der Prozessgruppen nicht weiter - sie
 können für die Implementierung von Benutzer/Gruppen-Systemen im Benutzermodus
 verwendet werden.
 Nur die zwei vordefinierten Prozessgruppen können bei der Kommunikationsberecht
igung von Threads eingesetzt werden:
\end_layout

\begin_layout Itemize
Die 
\emph on
everybody
\emph default
 (
\family typewriter
0x04FFFFFF
\family default
) Gruppe, bei der jeder Prozess automatisch Mitglied ist (es sei denn, er
 hat sich ausgeschlossen) und somit immer dann verwendet wird, wenn Threads
 von allen Threads des Systems Nachrichten annehmen wollen.
\end_layout

\begin_layout Itemize
Die 
\emph on
root
\emph default
 (
\family typewriter
0x04000000
\family default
) Gruppe.
 Diese Gruppe repräsentiert alle Prozesse, die sich im 
\emph on
root
\emph default
-Modus befinden - ein Thread kann somit den Zugriff auf sich auf diese Gruppe
 beschränken.
 Prozesse im 
\emph on
root
\emph default
-Modus haben folgende Rechte:
\end_layout

\begin_deeper
\begin_layout Itemize
Geschützte Hardwarespeicherbereiche in den virtuellen Adressraum einbauen
\end_layout

\begin_layout Itemize
Auf I/O-Ports zugreifen (transferierbar auf nicht-root)
\end_layout

\begin_layout Itemize
IRQs behandeln (transferierbar auf nicht-root)
\end_layout

\begin_layout Itemize
Prozesse und Threads killen, die nicht zum eigenen Prozess gehören
\end_layout

\begin_layout Itemize
Threads, die nicht zum eigenen Prozess gehören einfrieren / aufwecken
\end_layout

\begin_layout Itemize
Zum Paging-Dämon werden (einmalig möglich)
\end_layout

\begin_layout Itemize
Exceptions, Systemaufrufe und Page-Faults anderer Threads zu sich umleiten
\end_layout

\begin_layout Itemize
Exceptions, Systemaufrufe und Page-Faults in anderem Namen ausführen
\end_layout

\begin_layout Itemize
Register anderer Prozesse auslesen oder ändern
\end_layout

\begin_layout Itemize
Speicherbereichsoperationen anderer Threads aus der Ferne erlauben und ausführen
\end_layout

\begin_layout Itemize
Speicherbereiche anderer virtueller Adressräume freigeben
\end_layout

\begin_layout Standard
Somit besitzen Prozesse der root-Gruppe sehr weitgehende Rechte.
 Wichtig ist, dass sie einige Rechte auch an Prozesse anderer Gruppen weitergebe
n können, so dass z.B.
 Gerätetreibern icht zwingend Mitglieder der Root-Gruppe sein müssen, was
 die Sicherheit des Systems wesentlich verbessern kann.
\end_layout

\end_deeper
\begin_layout Subsection
Eindeutige IDs
\end_layout

\begin_layout Standard
Die SID eines Threads oder eines Prozesses kann in kurzer Zeit mehrfach
 verwendet werden.
 Oft ist es jedoch aus Sicherheitsgründen erforderlich, dass ein Prozess
 eindeutig über lange Zeit hinweg identifiziert werden kann.
 Aus diesem Grund verfügt jeder Prozess und jeder Thread in seinem Deskriptor
 über eine eindeutige ID.
 Die Wiederholung dieser Nummer für einen Prozess oder Thread mit derselben
 SID ist relativ unwahrscheinlich.
 Soll also ein Prozess oder Thread eindeutig identifiziet werden, so kann
 dies zusammen mit dessen SID geschehen: Ein Thread übergibt beispielsweise
 zu seiner Identifikation einem Server seine SID und seine eindeutige ID.
 Ist mittlerweile ein neuer Thread mit gleicher SID entstanden, so wird
 dieser in seinem Deskriptor eine andere eindeutige ID vermerkt haben.
 Der Server kann somit also feststellen, dass es sich bei diesem Client-Thread
 trotz identischer SID um einen anderen Thread handelt.
 Die eindeutige ID lässt sich nicht von Außerhalb manipulieren.
\end_layout

\begin_layout Chapter
Die IPC
\end_layout

\begin_layout Section
Das grundlende Konzept
\end_layout

\begin_layout Standard
Die meisten modernen Mikrokernelsysteme verwenden für die Interprozess-Kommunika
tion 
\emph on
Message passing
\emph default
, d.h.
 das Versenden von Nachrichten zwischen Prozessen.
 Einige Mikrokernel - wie Mach - bieten dabei sehr komplizierte, asynchrone
 - d.h.
 auf Nachrichtenwarteschlangen basierende - Nachrichtensysteme an, andere
 wiederum - wie L4 - verwenden nur noch sehr kompakte synchrone Nachrichtensyste
me, bei denen sehr kurze Nachrichten (evtl.
 in Kombination mit Speicherverwaltungsbefehlen) versendet werden können.
\end_layout

\begin_layout Standard
Das Problem der asynchronen, auf Nachritenwarteschlangen basierenden Nachrichten
systeme ist in erster Linie die niedrige Performance und die Tatsache, dass
 dabei der Kernel weiterhin große Komplexität besitzt, was letztlich dem
 Mikrokernelansatz wiederspricht.
 Andere Systeme, die einen Nachrichtentransfer sehr kurzer Nachrichten anbieten,
 sind aber meist genauso problematisch.
 Sie sind zwar sehr effizient und haben bereits eine sehr reduzierte Komplexität
 - dennoch müssen meist größere Datenmengen ohnehin über gemeinsam genutzte
 Speicherbereiche transferiert werden, da ansonsten größere Datenmengen
 nur mit sehr hohen Transferzeiten übertragen werden könnten.
\end_layout

\begin_layout Standard
Daher stellt sich die Frage, ob man überhaupt im Kernel ein Nachrichtensystem
 als solches anbieten sollte, oder ob es nicht genügt, dass der Kernel sehr
 einfache Dienste zur gemeinsamen Speichernutzung und zur Synchronisierung
 von Threads anbietet.
 Der eigentliche Datentransfer über die Speicherseiten kann im Benutzermodus
 erledigt werden.
 Dies reduziert die Komplexität des Kernels und erhöht die Systemperformance,
 da die Daten ohne Kontext-Wechsel übertragen werden können.
\newline

\end_layout

\begin_layout Standard
Das IPC-Konzept des 
\emph on
hymk
\emph default
 sieht also vor, dass Threads unterschiedlicher Prozesse nur noch über gemeinsam
 genutzte Speicherbereiche kommunizieren, die über den Kernel eingerichtet
 werden können und sich mit Hilfe des Kernels synchronisieren.
 Dadurch soll eine höhere Performance des Systems und eine niedrigere Komplexitä
t des Kernels erreicht werden.
\end_layout

\begin_layout Section
Gemeinsame Speichernutzung
\end_layout

\begin_layout Standard
Für die gemeinsame Speichernutzung sind vier Operationen vorgesehen.
 Diese Operationen heißen 
\emph on
allow
\emph default
, 
\emph on
map
\emph default
, 
\emph on
unmap
\emph default
, 
\emph on
move
\emph default
.
\end_layout

\begin_layout Subsection
allow
\end_layout

\begin_layout Subsubsection
allow(SID_src, SID_dest, dest_start, dest_size, operation)
\end_layout

\begin_layout Standard
Die Operation 
\emph on
allow
\emph default
 dient dazu festzulegen, von welcher SID Operationen zur gemeinsamen Speichernut
zung auf diesen Thread (bzw.
 dessen virtuellen Adressraum) angewendet werden dürfen (Parameter 
\emph on
SID_src
\emph default
).
 Trotz der Tatsache, dass ein virtuelle Adressraum eigentlich die Sache
 eines bestimmten Prozesses ist, wird die Zugriffserlaubnis über die Threads
 gesteuert.
 Dies wird deshalb gemacht, um einen aufwendigeren, prozess-basierten Zugriffsko
ntrollmechanismus zu vermeiden, der in der Regel überflüssig ist, da die
 Kommunikation in Client/Server-Systemen ohnehin unmittelbar zwischen dem
 Client und einem nur für diesen Client erstellen Server-Thread abläuft
 und es somit völlig ausreicht, dass der Server-Thread (bzw.
 der Client-Thread der ohnehin nur auf einen Server gleichzeitig zugreifen
 kann) den Zugriff ohne prozessweite Zugriffslisten steuert.
\end_layout

\begin_layout Standard
Die SID, die als Parameter übergeben werden kann, kann die SID eines bestimmten
 Threads, eines bestimmten Prozesses oder einer der beiden vom Kernel definierte
n Prozessgruppen (
\emph on
root 
\emph default
und 
\emph on
everybody
\emph default
) sein.
 Sie kann aber auch einem Platzhalter entsprechen.
 Wird der 
\emph on
null
\emph default
-Platzhalter verwendet, ist der Zugriff komplett gesperrt.
 Der 
\emph on
kernel
\emph default
-Platzhalter ist überflüssig, da der Kernel weder Speicherseiten mit einem
 Prozess gemeinsam nutzt und wenn er es jemals würde, dies auch ohne Erlaubnis
 machen könnte.
\end_layout

\begin_layout Standard
Root-Threads haben das Recht die allow-Operation auf andere Threads anzuweden,
 die gar nicht zu ihrem Prozess gehören (Parameter 
\emph on
SID_dest
\emph default
).
 
\end_layout

\begin_layout Standard
Die Allow-Operation gibt zusätzlich an, auf welche Zieladressen die Speicherverw
altungsoperation angewendet werden soll (Parameter 
\emph on
dest_start
\emph default
 und 
\emph on
dest_size
\emph default
).
 Ferner kann festgelegt werden, welche Operationen alle überhaupt zulässig
 sind (Parameter 
\emph on
operation
\emph default
).
\end_layout

\begin_layout Standard
Der Aufruf 
\emph on
allow
\emph default
 wird automatisch beim Erstellen eines neuen Prozesses aufgerufen, so dass
 der erzeugende Thread Speicherinhalte in den neuen Prozess hineinverschieben
 kann.
 Abgesehen von dieser Ausnahme werden sonst nach dem Start eines neuen Threads
 die von 
\emph on
allow
\emph default
 zu definierenden Einstellungen so gesetzt, dass kein anderer Thread Speicherver
waltugnsoperationen ausführen kann.
\end_layout

\begin_layout Subsection
map
\end_layout

\begin_layout Subsubsection
map(SID, src_start, src_size, flags)
\end_layout

\begin_layout Standard
Die Operation 
\emph on
map
\emph default
 stellt einen gemeinsamen Speicherbereich des eigenen virtuellen Adressraums
 dem virtuellen Adressraum eines anderen Threads (Parameter 
\emph on
SID
\emph default
) zur Verfügung.
 Der Speicherbereich wird durch eine Startadresse und eine Größe definiert
 (Parameter 
\emph on
src_start
\emph default
 und 
\emph on
src_size
\emph default
).
 Zusätzlich können Flags definiert werden, die die Zugriffsrechte auf den
 Bereich festlegen (Nur-Lesen, Lesen/Schreiben, Lesen/Schreiben/Ausführen),
 sofern diese durch die Hardware-Plattform unterstützt werden.
 Außerdem kann festgelegt werden, dass die Seiten für das Copy-On-Write-Verfahre
n markiert werden sollen, so dass effektiv kein gemeinsamer Speicherbereich,
 sondern tatsächlich zwei getrennte Speicherbereiche entstehen.
\end_layout

\begin_layout Standard
Der Zugriff auf den anderen virtuellen Adressraum wird durch eine vorangegangene
 
\emph on
allow
\emph default
-Operation der Gegenseite bestimmt.
 Der map-Aufruf kann auch auf den eigenen Prozess angewendet werden, erfordert
 aber auch eine 
\emph on
allow
\emph default
-Operation, um die Zieladresse festzulegen.
\end_layout

\begin_layout Subsection
unmap
\end_layout

\begin_layout Subsubsection
unmap(SID, dest_start, dest_size, flags)
\end_layout

\begin_layout Standard
Entfernt einen Speicherbereich aus einen Zieladressraum, der zu einem Zielthread
 gehört (Parameter 
\emph on
SID
\emph default
).
 Diese Operation betrifft nicht zwingend gemeinsam genutzte Speicherbereiche,
 sondern kann auch andere Speicherbereiche betreffen - somit können z.B.
 auch normale Speicherbereiche freigegeben werden.
 Mit Hilfe bestimmter Flags können auch nur Zugriffsrechte reduziert werden.
 Root-Prozesse können diesen Aufruf auch ohne ein vorausgegangenes 
\emph on
allow
\emph default
 der Gegenseite ausführen.
 
\end_layout

\begin_layout Standard
Der 
\emph on
unmap
\emph default
-Aufruf kann ohne Aufruf von 
\emph on
allow 
\emph default
auch auf den eigenen Prozess angewendet werden, um lokalen Speicher freizugeben
 oder Mappings aus dem eigenen Adressraum zu entfernen.
\end_layout

\begin_layout Subsection
move
\end_layout

\begin_layout Subsubsection
move(SID, src_start, src_start, flags)
\end_layout

\begin_layout Standard
Dieser Aufruf ist eine Mischung aus einem 
\emph on
map
\emph default
 auf einen anderen Adressraum und einem 
\emph on
unmap
\emph default
 auf den eigenen Adressraum mit dem Ziel einen Speicherbereich zu einem
 anderen Adressraum zu verschieben.
 Der andere virtuelle Adressraum, repräsentiert durch den Thread, dessen
 SID definiert ist (Parameter 
\emph on
SID
\emph default
) muss daher zuvor mit einem 
\emph on
allow
\emph default
 freigegeben worden sein (der eigene Adressraum natürlich nicht).
 Die zu verschiebenden Speicherbereiche werden durch eine Startadresse und
 eine Bereichsgröße definiert (Parameter 
\emph on
src_start
\emph default
 und 
\emph on
src_size
\emph default
).
 Ferner können auch hier Zugriffsflags definiert werden.
\end_layout

\begin_layout Standard
Ist der Zielbereich kleiner als der Quellbereich, werden überschüssige Speichers
eiten freigegeben.
\end_layout

\begin_layout Section
Synchronisation von Threads
\end_layout

\begin_layout Standard
Für die gegenseitige Synchronisation von Threads
\begin_inset LatexCommand \index{Threads, Synchronisation von}

\end_inset

 gibt es einen Systemaufruf, der von beiden zu synchronisierenden Seiten
 verwendet wird:
\end_layout

\begin_layout Subsection
sync
\end_layout

\begin_layout Subsubsection
sync(SID, timeout, resync);
\end_layout

\begin_layout Standard
Synchronisiert zwei Threads innerhalb eines bestimmten (oder unendlichen)
 Timeouts miteinander - d.h.
 der Aufrufer wartet, bis ein gewählter anderer Thread (definiert durch
 den Parameter 
\emph on
SID
\emph default
) ebenfalls 
\emph on
sync
\emph default
 mit seiner SID aufruft.
 
\end_layout

\begin_layout Standard
Das Warten geschieht weitgehend passiv, so dass durch den Wartevorgang keine
 oder relativ wenig CPU-Zeit verbraucht wird.
 Der Kernel kann zur Umsetzung interne Warteschleifen einsetzen.
 Gewartet wird solange, bis die Gegenseite die Synchronisierung gestattet
 - d.h.
 auch wenn die Gegenseite sich derzeit auf eingehende Synchronisationen
 wartet, aber die Synchronisation mit dem Aufrufer verbietet, wartet der
 Aufrufer, bis sich dieser Zustand der Gegenseite ändert oder das Timeout
 abläuft.
\end_layout

\begin_layout Standard
Die Gegenseite, auf die ein Thread wartet, kann
\end_layout

\begin_layout Itemize
ein bestimmter Thread (definiert durch dessen Thread-SID) sein
\end_layout

\begin_layout Itemize
ein beliebiger Thread eines bestimmten Prozesses (definiert durch die Prozess-SI
D) sein
\end_layout

\begin_layout Itemize
ein beliebiger Thread aller Prozesse sein, die sich im 
\emph on
root
\emph default
-Modus befinden (definiert durch die 
\emph on
root
\emph default
-SID)
\end_layout

\begin_layout Itemize
ein beliebiger Thread (definiert durch die 
\emph on
everybody
\emph default
-SID) sein
\end_layout

\begin_layout Standard
Wichtig ist hierbei, dass bei einer Synchronisierung grundsätzlich mindestens
 einer der beiden Seiten eine konkrete Thread-SID angeben muss, da sonst
 das Ziel nicht genau spezifiziert ist.
\newline
Um unnötige Wechsel zwischen Kernel-
 und Benutzermodus zu vermeiden, kann ein Thread eine automatische Wiederholung
 des selben Synchronisationsvorgangs bei erfolgreicher Synchronisation anordnen.
 In einem Client-Server-System ist es z.B.
 oft der Fall, dass der Client sich zuerst mit dem Worker-Thread des Servers
 synchronisiert, um diesen zu signalisieren, dass ein neuer Auftrag ansteht
 und anschließend auf eingehende Synchronisation des Worker-Threads wartet,
 damit dieser ihm die Fertigstellung des Auftrags signalisiert.
 Durch die automatische Resynchronisierung kann hier ein überflüssiger Wechsel
 zwischen Kernel- und Benutzeradressraum vermieden werden.
\end_layout

\begin_layout Subsection
Weitere Synchronisationsmöglichkeiten
\end_layout

\begin_layout Subsubsection
freeze_subject und awake_subject
\end_layout

\begin_layout Standard
Es gibt auch weitere Synchronisationsmöglichkeiten
\begin_inset LatexCommand \index{Synchronisationsmöglichkeiten, weitere}

\end_inset

 über die Operationen 
\emph on
freeze_subject
\emph default
 und 
\emph on
awake_subject
\emph default
, mit deren Hilfe Threads von außen angehalten oder fortgesetzt weden können.
 Diese Operation kann von allen Root-Prozessen oder aber auch von Threads
 des gleichen Prozesses untereinander angewandt werden.
\end_layout

\begin_layout Standard
Diese Aufrufe sind auf Threads, die sich im Kernel-Modus befinden möglicherwiese
 nur bedingt anwendbar (implementationsabhängig).
\end_layout

\begin_layout Chapter
Kontrolloperationen
\end_layout

\begin_layout Section
Allgemeine Fernsteuerung von Threads
\begin_inset LatexCommand \index{Threads, Fernsteuerung von}

\end_inset


\end_layout

\begin_layout Standard
Der 
\emph on
hymk
\emph default
 bietet eien Reihe von Funktionen an, mit deren Hilfe andere Threads ferngesteue
rt werden können.
 Diese Funktionen sind grundsätzlich auf root beschränkt.
 Diese allgemeine Fernsteuerung wurde aus verschiedenen Gründen eingebaut
 - einerseits um schlichtweg einen Debugging-Mechanismus zu ermöglichen,
 anderseits aber auch um im Benutzermodus Virtualisierungs- und Übersetzungsmech
anismen zu ermöglichen, die für die von HydrixOS angebotene Architekturtranspare
nz unbedingt erforderlich sind.
\end_layout

\begin_layout Subsection
Kontrolle der Register eines Threads
\end_layout

\begin_layout Standard
Grundsätzlich gehört zu dieser Fernsteuerungsmöglichkeit das Auslesen und
 Ändern der Register eines Threads.
 Sie schließen den Programm- und Stackzeiger mit ein.
 Diese Operationen sind von ihrer Schnittstelle selbstverständlich immer
 sehr plattformspezifisch.
 Grundsätzlich können sie nur dann ausgeführt werden, wenn der zu manipulierende
 Thread mit einem 
\emph on
freeze
\emph default
_
\emph on
subject
\emph default
-Aufruf zuvor angehalten wurde (hierbei muss der Thread explizit angehalten
 sein, nicht nur dessen Prozess).
\end_layout

\begin_layout Subsection
Kontrolle der Softwareinterrupts
\end_layout

\begin_layout Standard
Das wichtigste Kontrollfeature ist die Kontrolle von Softwareinterrupts.
 Der kontrollierende Thread kann sich bei der Ausführung von Softwareinterrupts
 zwischenschalten, so dass diese nicht vom Kernel, sondern von dem kontrollieren
den Thread behandelt werden können.
 Dabei wird die Nummer des Softwareinterupts mitgeteilt und der ausführende
 Thread mit 
\emph on
freeze_subject
\emph default
 temporär gestoppt.
 Softwareinterrupts schließen unter HydrixOS Systemaufrufe, Exceptions und
 Page Faults ein.
 Prinzipiell kann nur ein Thread gleichzeitig sich beim gleichen Thread
 zwischenschalten.
\end_layout

\begin_layout Standard
Auf der anderen Seite können aber auch Softwareinterrupts vorgetäuscht werden.
 Somit kann ein Thread von außen einerseits einen Page-Fault oder eine Exception
 in dem betroffenen Thread auslösen, aber besonders im Namen eines anderen
 Threads einen Systemaufruf ausführen.
 
\end_layout

\begin_layout Standard
In beiden Fällen werden die Softwareinterrupts mit den Registerwerten des
 kontrollierten Threads ausgeführt, bzw.
 von dort die Parameter bei einer Zwischenschaltung bezogen, um maximale
 Transparenz zu erreichen.
\end_layout

\begin_layout Section
Spezielle Fernsteuerung des Paging Dämons
\end_layout

\begin_layout Subsection
Behandlung von Page Faults
\end_layout

\begin_layout Standard
Eine spezielle Fernsteuerung erfolgt immer durch den Paging Dämon.
 Dieser Dienst wird vom Kernel immer aufgerufen, wenn ein 
\emph on
Page Fault
\begin_inset LatexCommand \index{Page Fault}

\end_inset


\emph default
 nicht durch eine Zwischenschaltung (siehe 3.1.2) behandelt wurde.
 Um diese 
\emph on
Page Faults
\emph default
 entgegenzunehmen, geht der Paging Dämon mittels eines sync auf den Kernel-Platz
halter in einen Wartemodus.
 Tritt ein 
\emph on
Page Fault
\emph default
 auf, wird der Paging Dämon reaktiviert und erhält als Rückgabewert die
 Thread-SID des Threads, der den Fault ausgelöst hat.
 Mit dieser Thread-SID kann er einen aus dem Thread-Deskriptor des betroffenen
 Threads auslesen.
 Dieser enthält hierfür die folgenden Informationen:
\end_layout

\begin_layout Itemize
Betroffene Speicheradresse
\end_layout

\begin_layout Itemize
Inhalt des Page-Deskriptors (Plattformabhängig; fehlt die notwendige Seitentabel
le, wird der Deskriptor der Seitentabelle übermittelt)
\end_layout

\begin_layout Itemize
Abgebrochene Operation (Lesen, Schreiben, Freigeben der Speicherseite)
\end_layout

\begin_layout Itemize
Weitere Daten zur aufgetretenen Exception, wie z.B.
 der plattformspezifische Fehlercode (siehe Exception-Handling)
\end_layout

\begin_layout Standard
Der Paging-Dämon kann dann eine 
\emph on
allow
\emph default
-Operation im Namen des betroffenen Threads ausführen (allerdings muss er
 den alten 
\emph on
allow
\emph default
-Zustand danach auch wiederherstellen) und ggf.
 Pages von einem exterenen Medium zurückmappen oder aber eine Exception
 (außer einem Page-Fault) im Namen des Threads ausführen, falls keine Page
 zur Verfügung steht.
 
\end_layout

\begin_layout Standard
Solange der Paging-Dämon nicht mit sync() auf neue Page-Faults wartet, bleiben
 diejenigen Threads im Kernel-Mode stehen, die den Page Fault erzeugt haben
 (der Teil des Thread-Deskriptors mit den Informationen zum Page-Fault ändert
 sich auch bis dahin nicht).
 Findet die Synchronisierung statt, wird der auslösende Thread während des
 Page-Faults mit 
\emph on
freeze_subject
\emph default
 eingefroren.
 Der Paging-Dämon muss ihn also anschließend wieder mit 
\emph on
awake_subject
\emph default
 aufwecken.
\end_layout

\begin_layout Subsection
Behandlung von Exceptions
\end_layout

\begin_layout Standard
Löst ein Thread eine Exception (
\emph on
Ausnahmefehler
\emph default
) aus, so wird ebenfalls der Paging-Dämon informiert.
 In diesem Fall können folgende Informationen aus dem Deskriptor des betroffenen
 Threads entnommen werden:
\end_layout

\begin_layout Itemize
Plattformunabhängige Fehlernummer
\end_layout

\begin_layout Itemize
Ausgelöste Exception (Plattformabhängig)
\end_layout

\begin_layout Itemize
Fehlercode (Plattformabhängig)
\end_layout

\begin_layout Standard
Der Thread, der diese Exception ausgelöst hat, wurde mit 
\emph on
freeze_subject
\emph default
 zuvor bereits eingefroren.
 Je nach Implementierung kann der Paging-Dämon dann diese Informationen
 weiterleiten, die Ausführung des Threads mit 
\emph on
awake_subject
\emph default
 wieder fortsetzen (sofern die Ursache der Exception beseitigt wurde) oder
 den betroffenen Thread einfach beenden.
\end_layout

\begin_layout Standard
Trat die Exception auf, bevor ein Paging-Dämon installiert werden konnte
 oder trat die Exception im Paging-Dämon selbst auf, so wird das System
 angehalten.
\end_layout

\begin_layout Subsection
Installation des Paging-Dämons
\end_layout

\begin_layout Standard
Der Paging-Dämon meldet sich beim Start des Systems über den Systemaufruf
 
\emph on
set_paged
\emph default
 beim Kernel an.
 Ist er einmal angemeldet, kann kein anderer Thread sich mehr als Paging-Dämon
 anmelden, bis dieser Thread beendet wurde.
\end_layout

\begin_layout Subsection
Anmerkungen zur Implementierung
\end_layout

\begin_layout Standard
Ein Paging-Dämon, der das Ziel hat, Speicherseiten auf ein externes Medium
 auszulagern, kann mit den derzeitigen Mitteln noch kaum oder zumindest
 sehr schwierig implementiert werden.
 Es wird sicherlich weitere Erweiterung der Systemarchitektur erfordern,
 um diese Fähigkeit des Systems effizient auszubauen.
 Auf Grund der hohen RAM-Speicherkapazitäten und des Bedarfs an einem unkomplizi
erten Betriebssystemkern wurde der Aspekt der Seitenauslagerung vorerst
 noch ausgelassen.
\end_layout

\begin_layout Chapter
System- und Hardwareverwaltung
\end_layout

\begin_layout Section
IRQs
\end_layout

\begin_layout Subsection
Funktionsweise von IRQs
\end_layout

\begin_layout Standard
Auf nahezu jeder Plattform können auf Grund angeschlossener, externer Geräte
 bestimmte Ereignisse asynchron zur normalen Programmausführung auftreten
 und müssen dementsprechend behandelt werden.
 Wird beispielsweise eine Taste gedrückt, so muss u.U.
 die aktuelle Programmausführung unterbrochen werden, damit die Eingaben
 an einen Thread weitergeleitet werden können, der Tastatureingaben erwartet.
 Diese Art der Behandlung externer Ereignisse wird durch das Konzept der
 IRQs
\begin_inset LatexCommand \index{IRQ}

\end_inset

 gelöst.
\end_layout

\begin_layout Standard
Ein externes Gerät meldet der CPU über einen bestimmten, hardwaremäßigen
 Weg, dass ein externes Ereignis eingetreten ist und stellt somit eine Anfrage
 auf eine Unterbrechung der aktuellen Ausführung (
\emph on
interrupt request
\begin_inset LatexCommand \index{interrupt request}

\end_inset


\emph default
 = IRQ).
 Die CPU prüft, ob dieser IRQ vom laufenden Betriebssystem angenommen wird
 oder nicht.
 Wird er angenommen, so unterbricht die CPU die aktuelle Ausführung und
 sichert ihren Betriebszustand auf eine plattformspezifische Weise (meist
 auf den Kernel-Stack des aktuellen Threads).
 Anschließend führt sie eine Behandlungsroutine aus, die das Betriebssystem
 für diesen IRQ angegeben hat.
 Dieses leitet den IRQ an den jeweiligen Treiber weiter, der dann das Ereignis
 behandelt (z.B.
 Daten aus Gerätepuffern lädt etc.).
 Anschließend erklärt der Treiber den IRQ für behandelt und das System stellt
 den Zustand vor dem IRQ wieder her (oder führt ggf.
 einen Kontext-Wechsel durch).
\end_layout

\begin_layout Subsection
Behandlung von IRQs im 
\emph on
hymk
\end_layout

\begin_layout Standard
Unter dem 
\emph on
hymk
\emph default
 sind zwei Phasen der IRQ-Behandlung zu unterscheiden: Die 
\emph on
Low-Level
\emph default
-Behandlung
\begin_inset LatexCommand \index{IRQs, Low-Level-Behandlung von}

\end_inset

 der IRQs und die 
\emph on
High-Level
\emph default
-Behandlung
\begin_inset LatexCommand \index{IRQs, High-Level-Behandlung von,}

\end_inset

 der IRQs.
 Die Low-Level-Behandlung ist ein sehr plattform- und implementationsabhängiger
 Teil der IRQ-Behandlung.
 Die High-Level-Behandlung hingegen wurde soweit verallgemeinert, dass sie
 nahezu plattformunabhängig sein sollte.
\end_layout

\begin_layout Standard
Im Unterschied zu anderen Mikrokernel-Systemen wurde die IRQ-Behandlung
 unter HydrixOS nicht über den generischen IPC-Mechanismus implementiert,
 sondern durch einen speziellen Mechanismus.
 Der Grund ist folgender: die Behandlung eines IRQs kann mit einer plattformspez
ifischen Anpassung wesentlich performanter ausgeführt werden.
 Zudem verwenden viele Systeme, die nach außen hin den gleichen IPC-Mechanismus
 für die IRQ-Behandlung einsetzten, intern doch einen spezifischen Mechanismus,
 was nur dazu führt, dass die Anzahl der Systemaufrufe, aber nicht deren
 interne Komplexität reduziert wird.
\newline

\end_layout

\begin_layout Standard
Bei der High-Level-Behandlung eines IRQs ruft ein Thread, der dazu die Erlaubnis
 hat, die Routine 
\emph on
recv_irq
\emph default
 auf.
 Diese Routine prüft zuerst, ob bereits ein anderer Thread auf den gleichen
 IRQ wartet.
 Ist dem so, wird der Vorgang abgebrochen.
 Andernfalls trägt die Routine den Thread zur IRQ-Behandlung ein und legt
 ihn in einen passiven Wartemodus.
 Tritt der IRQ auf, wird der aktuelle Thread verdrängt und der IRQ-Thread
 aus dem Wartemodus erweckt (dieser Thread hat eine sehr hohe Priorität,
 wodurch er alle anderen Threads verdrängt werden).
 Anschließend kann er die IRQ-Behandlung ausführen.
 Ist er fertig, kann er den selben IRQ erneut mit 
\emph on
recv_irq 
\emph default
behandeln.
 Sollte er keine weiteren IRQs mehr behandeln wollen, so hat er dennoch
 
\emph on
recv_irq
\emph default
 mit einem plattformspezifischen Wert auszuführen, der einen ungültigen
 IRQ symbolisiert, um den zuletzt behandelten IRQ wieder freizugeben.
 In beiden Fällen löst der Aufruf von 
\emph on
recv_irq
\emph default
 während einer IRQ-Behandlung interne Operationen aus, die hardwaremäßig
 erforderlich sind, um den IRQ als behandelt zu erklären.
 
\end_layout

\begin_layout Standard
Grundsätzlich ist während einer IRQ-Behandlung die Behandlung weiterer IRQs
 gleichzeitig möglich, da während der IRQ-Behandlung nicht alle, sondern
 nur der zu behandelnde IRQ maskiert wird.
 Daher können IRQ-Behandlungsroutinen prinzipiell auch blockierende Operationen
 - wie sync - ausführen.
 Die Priorisierung der IRQs ist bei den meisten Plattformen durch die Hardware
 geregelt.
\end_layout

\begin_layout Section
I/O-Speicher
\end_layout

\begin_layout Subsection
Speicherbasiertes I/O
\end_layout

\begin_layout Standard
Bei vielen Plattformen werden externe Geräte über Speicherbereiche angesteuert,
 die in den physikalischen Adressraum der CPU eingeblendet wurden.
 Diese Speicherbereiche können meist nur mit eingeschränkten Cache-Regelungen
 verwendet werden, so dass sie nicht direkt als normale Seitenrahmen verwendet
 werden dürfen.
 Stattdessen ist ein spezieller Reservierungsmechanismus erforderlich, der
 zudem eine mehrfache Resevierung gleicher Speicherbereiche erlaubt.
\end_layout

\begin_layout Standard
Der Reservierungsmechanismus des 
\emph on
hymk
\emph default
 erlaubt für Root-Prozesse die Aufnahme von I/O-Adressbereichen in deren
 eigenen virtuellen Adressraum über den Systemaufruf 
\emph on
io_alloc
\emph default
.
 Falls erforderlich können Root-Prozesse mit 
\emph on
map
\emph default
 diese Adressräume dann an Nicht-root-Prozesse weitergeben, so dass Treiberimple
mentierungen zur Verbesserung der Systemsicherheit in weniger privilegierten
 Prozessen durchgeführt werden können.
\end_layout

\begin_layout Subsection
Portbasiertes I/O
\end_layout

\begin_layout Standard
Einige Plattformen (in erster Linie Intels x86-Plattform) bieten neben dem
 Speicherbasierten I/O auch noch einen weiteren Adressraum von I/O-Ports
 an.
 Dieser Zugriff wird meist über eigene Instruktionen realisiert und kann
 für einzelne Prozesse meist sehr detailiert eingeschränkt werden.
 Der 
\emph on
hymk
\emph default
 erlaubt grundsätzlich allen Root-Prozessen den Zugriff auf alle I/O-Ports.
 Root-Prozesse können aber einzelnen Nicht-root-Prozessen den Zugriff auf
 die I/O-Ports zusätzlich gestatten.
\end_layout

\begin_layout Section
I/O-Sicherheit
\end_layout

\begin_layout Standard
Wie bereits in den vorherigen Kapiteln erwähnt, ist I/O meist nur auf root-Proze
sse beschränkt.
 Jedoch können Root-Prozesse bestimmte I/O-Rechte an Nicht-root-Prozesse
 weiterleiten.
 Dies ist recht sinnvoll, da dadurch Treiber nicht mit vollen Root-Privilegien
 arbeiten müssen, sondern auch unter beschränkten und kontrollierbaren Privilegi
en arbeiten können.
 Die Privilegienkontrolle erfolgt über den Systemaufruf 
\emph on
io_allow
\emph default
.
 Mit diesem lassen sich folgende Privilegien regeln:
\end_layout

\begin_layout Itemize
Zugriff auf die Portbasiert-I/O (falls vorhanden)
\end_layout

\begin_layout Itemize
Behandlung von IRQs
\end_layout

\begin_layout Standard
Die Weitergabe von IO-Adressbereichen kann über das mappen solcher Adressbereich
e durch root-Prozesse erfolgen.
 Somit ist dort eine feinkörnigere Steuerung möglich.
\end_layout

\begin_layout Section
Info-Pages
\end_layout

\begin_layout Standard
Bei vielen Systemen werden aktuelle Statusinformationen meist durch Systemaufruf
e zugänglich gemacht.
 Da dies jedoch meist einen weiteren Kontext-Wechsel bedeutet und zudem
 die dabei erledigten Aufgaben meistens lediglich auf eine bestimmte Systemtabel
le zugreifen, verzichtet der 
\emph on
hymk
\emph default
 auf solche Aufrufe.
 Statt dessen blendet er am Ende des Kernel-Adressraums die sogenannten
 Info-Pages ein (die genaue Adresse und die größe dieses Areals sind Plattform
 bedingt).
 Dieser Bereich ist für Programme im User-Mode lesbar und für den Kernel
 auch beschreibbar.
\end_layout

\begin_layout Standard
Der exakte Aufbau der Inhalte der Info-Pages und die Position von diesen
 ist plattformspezifisch - daher müssen API-Bibliotheken Zugriffsfunktionen
 anbieten, die den Zugriff auf die eigentlichen Informationen plattformunabhängi
g ermöglichen.
 Grundsätztlich setzt sich dieser Bereich immer aus den folgenden Teilbereichen
 zusammen:
\end_layout

\begin_layout Enumerate
Der Hauptinfopage
\end_layout

\begin_layout Enumerate
Der Prozesstabelle
\end_layout

\begin_layout Enumerate
Der Threadtabelle
\end_layout

\begin_layout Subsection
Die Hauptinfopage
\end_layout

\begin_layout Standard
Die Hauptinfopage enthält Informationen über den aktuellen Systemzustand.
 Diese sind auf allen Plattformen mindestens die folgenden:
\end_layout

\begin_layout Itemize
Die SID des aktuellen Prozesses
\end_layout

\begin_layout Itemize
Die SID des aktuellen Threads
\end_layout

\begin_layout Itemize
Einen Zeiger auf den Prozesstabelleneintrag des aktuellen Prozesses
\end_layout

\begin_layout Itemize
Einen Zeiger auf den Threadtabelleneintrag des aktuellen Threads
\end_layout

\begin_layout Itemize
Die Versionsnummer des Kernels
\end_layout

\begin_layout Itemize
SID des Paging-Dämons
\end_layout

\begin_layout Itemize
Der aktuelle RTC-Zähler
\end_layout

\begin_layout Itemize
Der Idendifikationscode für die CPU (z.B.
 0x80386)
\end_layout

\begin_layout Itemize
Die Größe einer Speicherseite auf dieser Plattform
\end_layout

\begin_layout Itemize
Plattformspezifische Daten, die über die CPU (u.ä.) nähere Auskunft geben
\end_layout

\begin_layout Itemize
Anzahl von Seiten, die maximal in einem Systemaufruf (z.B.
 alloc_pages, io_alloc, map) 
\end_layout

\begin_layout Standard
Der genaue Aufbau der Infopage für die jeweilige Kernel-Implementierung
 ist später im Handbuch beschrieben.
\end_layout

\begin_layout Subsection
Die Prozesstabelle
\end_layout

\begin_layout Standard
Die Prozesstabelle enthält alle Informationen, die der Kernel über den jeweilige
n Prozess speichert.
 Es handelt sich dabei um die tatsächlichen Prozessdeskriptoren, die der
 Kernel auch intern verwendet (der Kernel benutzt ebenfalls die Info-Pages
 um diese Deskriptoren zu manipulieren, da dies einen schnellen Zugriff
 über Arrays gestattet, ohne physischen Speicher zu verschwenden).
 Diese Tabelle entählt für jede im System möglich Prozess-SID (auf x86-Systemen
 sind dies 4096) einen Deskriptor.
 Ist zu einer Prozess-SID kein Deskriptor verfügbar, wird ein leerer Deskriptor
 zur Verfügung gestellt (es handelt sich dabei immer um den gleichen Seitenrahme
n).
 Um Speicherplatz zu sparen, ist diese Tabelle ein Mapping von Deskriptoren,
 die in irgendwelchen Seitenrahmen gespeichert wurden, welche im physikalischen
 Speicher keine zusammenhängende Tabelle bilden.
 
\end_layout

\begin_layout Standard
Normalerweise besteht ein Eintrag aus mehreren Teilen: in einem ist der
 tatsächliche Deskriptor des Prozesses enthalten und im anderen eine Speicherver
waltungstabelle des Kernels enthalten, deren Struktur implementations-abhängig
 ist.
 Meistens sind diese Tabelleneinträge über mehrere vollständige Speicherseiten
 verteilt.
 Der genaue Aufbau der Prozesstabelle ist von der jeweiligen Kernel-Implementier
ung abhängig.
 Dennoch sollen von unterschiedlichen Kernel-Implementierungen im wesentlichen
 der gleiche Bestand an Grundinformationen angeboten werden.
 
\end_layout

\begin_layout Standard
Die Details über den Aufbau der Info-Pages können der Dokumentation der
 jeweiligen Implementierung entnommen werden.
 Es empfiehlt sich jedoch die interne Struktur der Prozessdeskriptoren über
 eine API-Bibliothek zu kapseln.
\end_layout

\begin_layout Subsection
Die Threadtabelle
\end_layout

\begin_layout Standard
Die Threadtabelle ist der Prozesstabelle sehr ähnlich.
 Auch sie enthält alle Informationen, die der Kernel über den jeweiligen
 Thread speichert.
 Auch handelt es sich hier um die tatsächlichen Threaddeskriptoren, die
 der Kernel auch intern verwendet.
 Diese Tabelle enthält für jede im System möglich Thread-SID (auf x86-Systemen
 sind dies 4096) einen Deskriptor.
 Ist zu einer Thread-SID kein Deskriptor verfügbar, wird auch hier immer
 der gleiche leere Deskriptor zur Verfügung gestellt.
 Um Speicherplatz zu sparen, ist auch diese Tabelle ein Mapping von Deskriptoren
, die in irgendwelchen Seitenrahmen gespeichert wurden, welche auch in diesem
 Fall im physikalischen Speicher keine zusammenhängende Tabelle bilden.
 Normalerweise besteht ein Eintrag aus drei Teilen: in einem ist der Deskriptor
 des Threads enthalten und im zweiten der 
\emph on
thread local storage
\begin_inset LatexCommand \index{thread local storage}

\end_inset


\emph default
 des Threads.
 Meistens sind diese Einträge über mehrere vollständige Speicherseiten verteilt.
\end_layout

\begin_layout Standard
Auch der genaue Aufbau der Threadtabelle ist von der jeweiligen Kernel-Implement
ierung stark abhängig und können der Dokumentation der jeweiligen Implementierun
g entnommen werden.
 Auch hier empfiehlt sich eine Kapselung durch API-Funktionen.
\end_layout

\begin_layout Section
Der Thread local storage
\end_layout

\begin_layout Standard
Neben den Info-Pages gibt es noch den 
\emph on
thread local storage
\emph default
.
 Dabei handelt es sich um eine Speicherseite, die an der letzten oder vorletzten
 Adresse des Benutzeradressraums eines virtuellen Adressraums liegt.
 Der zu dieser speziellen Seite zugeordnete Seitenrahmen wechselt dabei
 mit jedem Thread, so dass jeder Thread in diesem Adressbereich seinen eigenen,
 privaten Speicherplatz hat, auf den nur er zugreifen kann und der an einer
 festgelegten Adresse liegt.
 Der Seitenrahmen zu diesem Speicherbereich wird automatisch bei der Erzeugung
 des Threads angelegt und beim Beenden des Threads freigegeben.
\end_layout

\begin_layout Standard
In diesen 
\emph on
thread local storage
\emph default
 kann er z.B.
 Zeiger auf API-Variablen legen, die Thread-spezifisch sind und auf die
 immer sehr schnell zugegriffen werden können muss (z.B.
 der aktuelle API-Fehlerzustand).
 
\end_layout

\begin_layout Chapter
Programmausführung
\end_layout

\begin_layout Section
Der Scheduler
\end_layout

\begin_layout Subsection
Organisation des Schedulers
\end_layout

\begin_layout Standard
Wie jedes moderene Betriebssystem unterstützt HydrixOS natürlich preemptives
 Multitasking (bzw.
 Multithreading).
 Dabei unterstützt der 
\emph on
hymk
\emph default
 derzeit eine Prioritätenskala von 40 Prioritäten - von der niedrigsten
 Priorität 0, bis zur höchsten Priorität 40.
 Aus dieser statischen Priorität wird, wenn ein Thread aktiviert wird (z.B.
 nachdem er erstellt wurde oder er einen I/O-Wartezustand verlassen hat),
 eine effektive Priorität ausgerechnet.
 Diese effektive Priorität gibt die Länge der Zeit an, in der ein Thread
 die CPU verwenden darf.
 Diese effektive Priorität wird dazu mit jedem Uhrenschlag dekrementiert
 (außer der Thread ist im Kernel-Modus).
 
\end_layout

\begin_layout Standard
Ist jedenfalls die effektive Priorität eines neu aktivierten Threads höher
 als die des derzeit laufenden Threads, so wird der derzeitige Thread verdrängt
 und dem höherprioritäre Thread die CPU übergeben.
 Ist die effektive Priorität eines Threads aufgebraucht, so wird er ebenfalls
 verdrängt und durch einen anderen (beliebigen) Thread ersetzt.
\end_layout

\begin_layout Standard
Dieser Vorgang wird ständig mit allen Threads gemacht, die in der sog.
 Run-Queue des Schedulers abgelegt werden.
 In dieser Warteschlange werden grundsätzlich alle rechenbereiten Threads
 abgelegt, so dass nicht nach erneut rechenbereiten Threads gesucht werden
 muss.
 Wird ein neuer Thread mit höherer Priorität als der des aktuellen Threads
 rechenbereit, so wird er in diese Schlange direkt nach dem aktuellen Thread
 eingereiht.
 (Die Warteschlange ist als verkettete Liste organisiert).
\end_layout

\begin_layout Subsection
Bevorzung interaktiver Prozesse
\end_layout

\begin_layout Standard
Grundsätzlich ist der Scheduler auf die Förderung interaktiver Programme
 ausgerichtet, die immer wieder auf Eingaben oder Ausgabemöglichkeiten warten,
 dann aber möglichst schnell reagieren müssen.
 Dies wird über mehrere Verfahren erreicht: Zum einen können zwei Threads,
 die in gegenseitige Interaktion treten gezielt ihre restliche effektive
 Priorität an die jeweilige Gegenseite abtreten (d.h.
 die abgetretene effektive Priorität wird zu der der Gegenseite addiert),
 die für sie eine Aufgabe erlegdigen soll (so kann z.B.
 ein Client beim Aufruf eines Server-Threads seine effektive Priorität an
 den Server-Thread abgeben, damit dieser die vom Client gestellte Aufgabe
 schneller erledigen kann).
 
\end_layout

\begin_layout Standard
Auf der anderen Seite werden grundsätzlich Programme gefördert, die auf
 Eingaben warten, indem beim Betreten des Wartemodus ihre restliche effektive
 Priorität gesichert wird und später beim Wiedererwachen zur ohnehin zur
 Verfügung stehenden effektiven Priorität dazuaddiert wird.
 Dies bringt den Vorteil, dass dieses Programm in einem Zug mehr Aufgaben
 erledigen kann, aber vorallem erhöht es die Wahrscheinlichkeit, dass ein
 laufender Thread auf Grund von dessen meist niedrigeren effektiven Priorität
 durch den aus dem Wartemodus erweckten Thread verdrängt werden kann.
\end_layout

\begin_layout Subsection
Timeouts
\end_layout

\begin_layout Standard
Damit 
\emph on
sync
\emph default
 und 
\emph on
recv_softints
\emph default
-Operationen, die gesetzte Timeouts besitzen, nicht jedesmal einen vollständigen
 Kontextwechsel zur Überprüfung des Timeouts erfordern, wird diese Überprüfung
 beiläufig bei jedem Clock-Tick durchgeführt.
 Erst wenn das gesetzte Timeout abgelaufen ist, wird der wartende Thread
 wirklich wieder reaktiviert - andernfalls wird lediglich der Zähler für
 das Timeout dekrementiert und ein anderer Thread ausgewählt.
\end_layout

\begin_layout Section
Systemaufrufe
\end_layout

\begin_layout Standard
Die Systemaufrufe des 
\emph on
hymk
\emph default
 sind grundsätzlich nicht vollständig portabel entworfen worden.
 Gerade Parameter, die Speicheradressen beinhalten, verwenden auf den verschiede
nen Plattformen unterschiedliche Datentypen.
 Ebenfalls ist der Mechanismus, der zum Aufruf verwendet werden soll, grundsätzl
ich plattformabhängig.
 Das aber, was die einzelnen Systemaufrufe bewirken sollen, sollte auf allen
 Plattformen identisch sein (abgesehen von evtl.
 erforderlichen zusätzlichen plattformspezifischen Aufrufen und Detail-Parameter
n).
\end_layout

\begin_layout Standard
Da also die genaue Aufrufmethode und die Parameter in ihren Einzelheiten
 nicht plattformunabhängig erklärt werden kann, werden in diesem Kapitel
 nur die allgemein verfügbaren Systemaufrufe kurz erläutert.
 Ihre detailierte Spezifikation sind in dem für die jeweilige Plattform
 bestimmten Teil dieses Dokumentes aufgelistet:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="23" columns="3">
<features islongtable="true" headTopDL="true" headBottomDL="true">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="4cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="7cm">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Beschränkungen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Kurzbeschreibung
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
alloc_pages
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aktueller Thread
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reserviert Speicherseiten und mappt sie in den aktuellen virtuellen Adressraum.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
create_thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aktueller Thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Erzeugt einen neuen Thread.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
create_process
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aktueller Thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Erzeugt einen neuen Prozess.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
set_controller
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aktueller Prozess
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Legt den 
\emph on
controller thread
\emph default
 für den aktuellen Prozess fest.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
destroy_subject
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Paging-Dämon
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zerstört einen Prozess oder Thread
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
chg_root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Root;
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Wechselt einen Prozess in den Root-Modus oder entfernt ihn daraus.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
freeze_subject
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Threads des gleichen Prozesses; Root;
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Friert einen Thread ein.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
awake_subject
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Threads des gleichen Prozesses; Root;
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Weckt einen mit 
\emph on
freeze_subject
\emph default
 eingefrorenen Thread wieder auf.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
yield_thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aktueller Thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Gibt die restliche effektive Priorität an einen anderen Thread (oder keinen
 anderen) ab.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
set_priority
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Threads des gleichen Prozesses (nur herabsetzen); Root;
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ändert die aktuelle Priorität.
 Nur Root darf die Priorität dabei anheben.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
allow
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aktueller Thread; Root;
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Erlaubt eine Seitenverwaltungsoperation für eine bestimmte SID
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
map
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur 
\emph on
allow
\emph default
 oder Root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Etabliert eine gemeinsame Speichernutzung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
unmap
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur 
\emph on
allow
\emph default
 oder Root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Entfernt Speicherseiten aus einem virtuellen Adressraum oder reduziert zumindest
 die Zugriffsrechte darauf
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
move
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur 
\emph on
allow
\emph default
 oder Root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Verschiebt Speicherseiten in einen anderen virtuellen Adressraum
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
sync
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Abhängig von Gegenseite
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Synchronisiert zwei Threads
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
io_allow
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Erlaubt bestimmte I/O-Systemaufrufe und I/O-Instruktionen für nicht-Root-Prozess
e
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
io_alloc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Mapt einen I/O-Adressbereich in den aktuellen virtuellen Adressraum
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
recv_irq
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Root / io_allow
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Meldet eine IRQ-Behandlung an und wartet auf diese.
 Führt ebenfalls die Rückkehr aus einer IRQ-Behandlung durch.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
recv_softints
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Fängt alle Software-Interrupts (Systemaufrufe etc.) eines Threads ab
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
read_regs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Liest die Registerinhalte eines anderen Threads
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
write_regs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Schreibt in die Register eines anderen Threads
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
set_paged
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Root
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Legt den aktuellen Thread als Paging-Dämon fest
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Fehlerbehandlung
\end_layout

\begin_layout Standard
Der Kernel kennt grundsätzlich drei Arten von Fehlern, die unterschiedlich
 behandelt werden: 
\emph on
Kernel-Mode Exceptions
\emph default
, 
\emph on
User-Mode Exceptions
\emph default
, 
\emph on
Systemaufrufsfehler
\emph default
.
\end_layout

\begin_layout Subsection
Kernel-Mode-Exceptions
\end_layout

\begin_layout Standard
Eine Kernel-Mode-Exception ist ein asynchrones Ereignis, das eintritt, wenn
 ein Programm im Kernel-Modus Code ausführt, dessen Ausführung auf Grund
 bestimmter Instruktionsparameter oder auf Grund der Instruktion selbst,
 von der CPU nicht gestattet werden kann.
 Ein klassisches Beispiel ist die 
\begin_inset Quotes gld
\end_inset

Division durch Null
\begin_inset Quotes grd
\end_inset

 oder der Zugriff auf eine ungültige Speicherseite.
 Da der Kernel mit größter Sorgfalt programmiert werden muss, um dem Anspruch
 des 
\begin_inset Quotes gld
\end_inset

vertrauenswürdigen Teils
\begin_inset Quotes grd
\end_inset

 des Systems gerecht werden zu können, ist eine Kernel-Mode-Exception immer
 ein Hinweis darauf, dass der Kernel einen Fehler enthält oder fehlerhaft
 ist, weil er Eingabeparameter eines Systemaufrufs nicht richtig geprüft
 hat.
 Seltener könnte auch ein schwerer Defekt der Hardware die Ursache für eine
 Kernel-Mode-Exception sein.
 Daher führt eine Kernel-Mode-Exception immer zum Stopp des gesammten Systems
 mit Ausgabe einiger kurze Debugging-Informationen.
 
\end_layout

\begin_layout Standard
Da der Kernel eine niedrige Komplexität besitzt und auch kaum erweitert
 werden dürfte, sollten Kernel-Mode-Exceptions nur in anfänglichen Testphasen
 der Systemimplementierung oder aber bei schweren Hardwaredefekten (z.B.
 defekten Speichermodulen) auftreten.
\end_layout

\begin_layout Standard
Die möglichen Fehlernummern und Fehlercodes für Kernel-Mode-Exceptions sind
 plattformspezifisch und können aus den Dokumentationen der jeweiligen verwendet
en CPU-Sorte bezogen werden.
\end_layout

\begin_layout Subsection
User-Mode-Exceptions
\end_layout

\begin_layout Standard
Eine User-Mode-Exception ist ähnlich einer Kernel-Mode-Exception ebenfalls
 ein asynchrones Ereignis, das eintritt, wenn ein Programm Code ausführt,
 den die CPU auf Grund von einem Parameter, einer Speicherreferenz oder
 der Instruktion selbst als fehlerhaft eingestuft hat.
 Im Unterschied zu einer Kernel-Mode-Exception handelt es sich jedoch um
 Code den ein Programm im Benutzermodus ausgeführt hat, was normalerweise
 auf einen Programmierfehler des ausgeführten Programms zurückzuführen ist.
 
\end_layout

\begin_layout Standard
Im Fall einer User-Mode-Exception wird der fehlerhafte Thread mit 
\emph on
freeze_subject
\emph default
 eingefroren und der Vorfall entweder dem Paging-Dämon oder aber an ein
 Programm weitergegeben, dass die Softwareinterrupts des fehlerhaften Programms
 abgegriffen hat.
 Diese sind dann für die weitere Behandlung der Exception verantwortlich.
 Die übliche Reaktion ist die Beendigung des fehlerhaften Threads oder der
 Aufruf eines Debuggers.
\end_layout

\begin_layout Standard
Der 
\emph on
hymk
\emph default
 unterscheidet zwischen User-Mode-Exceptions und Page Faults, auch wenn
 diese auf den meisten Plattformen grundsätzlich unter die Kategorie 
\begin_inset Quotes gld
\end_inset

Exception
\begin_inset Quotes grd
\end_inset

 fallen und beide auch über das Abgreifen der Softwareinterrupts ferngesteuert
 werden können.
 Dieser Unterschied wurde eingebaut, um dem Paging-Dämon eine schnellere
 und plattformunabhängige Unterscheidung von Page Faults und Exceptions
 zu ermöglichen.
\end_layout

\begin_layout Standard
User-Mode-Exceptions sind normalerweise mit einer plattformabhängigen Fehlernumm
er (repräsentiert durch den ausgelösten Softwareinterrupt) und einen plattformab
hängigen Fehlercode verbunden.
 Zusätzlich liefert der Kernel für den Paging-Dämon (und andere Programme)
 auch plattformunabhänige Fehlernummern für Usermode-Exceptions:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="6cm">
<column alignment="block" valignment="top" leftline="true" width="1in">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="5cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nummer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Bedeutung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
EXC_DIVISION_BY_ZERO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Division durch Null.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
EXC_PROTECTION_FAULT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Speicherzugriffsfehler.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
EXC_INVALID_INSTRUCTION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ungültige Instruktion.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
EXC_TRAP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Haltepunkt eines Debuggers wurde erreicht (Ursachen sind sehr plattformspezi
fisch).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
EXC_OVERFLOW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Bei einer Rechenoperation wurde erzeugt (Ursachen sind sehr plattformspezifisch).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
EXC_STACK_FAULT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Zugriff auf den Stack schlug fehl.
 
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
EXC_INVALID_PAGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es wurde auf eine ungültige Speicherseite zugegriffen oder der Paging-Dämon
 ist nicht verfügbar.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
EXC_SPECIFIC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es trat eine plattformspezifische Exception auf, für die keine generelle
 Fehlernummer existiert
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Systemaufrufsfehler
\end_layout

\begin_layout Standard
Neben Exceptions gibt es auch Fehler, die während der Ausführung eines Systemauf
rufs auftreten können und auf Grund ungültiger Parameter oder gesperrter
 Zugriffsrechte ausgelöst wurden.
 Diese Fehler werden vom Kernel einfach mit dem Rückgabewert des jeweiligen
 Systemaufrufs auf eine plattformspezifische Weise synchron zurückgegeben.
 Derzeit sind folgende Fehlernummern für die Systemaufrufe definiert:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="6cm">
<column alignment="block" valignment="top" leftline="true" width="1in">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="5cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Nummer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Bedeutung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NO_ERROR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Systemaufruf konnte ohne Fehler ausgeführt werden.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ROOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Dieser Systemaufruf kann (mit den gegebenen Parametern) nur von Root ausgeführt
 werden.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Zugriff auf diesen Thread ist verboten.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_RESOURCE_BUSY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Zugriff afu diesen Thread ist temporär nicht möglich, da er auf eine
 bestimmte SID eingeschränkt wurde oder anderweitig blockiert ist.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_TIMED_OUT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ein Timeout wurde erreicht.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ein allgemein ungültiger Parameter wurde übergeben.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Eine ungültige SID wurde als Parameter übergeben.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Eine ungültige Adresse wurde als Parameter angegeben.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ENOUGH_MEMORY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es existiert kein weiterer Kernelspeicher, um eine bestimmte Operation durchzufü
hren.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_PAGES_LOCKED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ein Speicherbereich enthält bereits Speicherseiten, die zuerst freigegeben
 werden müssen, ehe die gewählte Operation darauf angewendet werden kann.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_PAGING_DAEMON
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Für eine bestimmte Operation wäre ein funktionierender Paging-Dämon erforderlich
 gewesen oder es wurde eine Operation ausgeführt, die nur dem Paging-Dämon
 erlaubt ist.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_SYSCALL_RESTRICTED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Für diesen Systemaufruf existieren bestimmte plattformspezifische Einschränkunge
n, die überschritten worden sind.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Part
Schnittstellen der x86-Implementierung
\end_layout

\begin_layout Chapter
Architekturabhängige Verfahrensweisen
\end_layout

\begin_layout Section
Die Zielplattform
\end_layout

\begin_layout Standard
Die x86-Architektur ist eine Architektur mit einer langen Entwicklungsgeschichte.
 Sie fängt an mit der 8- und 16-bit Architektur der 8086er und der 80286er
 Serie, bis sie schließlich mit dem 80386 zu einer 32-bit Architektur erweitert
 wurde und heute mit der x86-64-Architektur von AMD letztlich auch als 64-bit
 Archiektur erhältlich ist.
\end_layout

\begin_layout Standard
Wenn in diesem Dokument von der x86-Architektur gesprochen wird, so werden
 damit nur alle 32-bit x86 Prozessoren ab der 80586-Serie bezeichnet.
 Die 80386 und 80486-er Serien werden bewusst nicht mehr unterstützt, um
 höhere Performance bei den heute noch gängigen x86-Architekturen zu erzielen
 und die Komplexität des Kernels so gering wie möglich zu halten (so ist
 z.B.
 keine FPU-Emulation erforderlich, da jede x86-CPU ab dem 80586 über eine
 eingebaute FPU verfügt).
 Die x86-64-Architektur von AMD, sowie die IA64-Architektur werden bei der
 x86-Implementierung des 
\emph on
hymk
\emph default
 nur in deren vollständigen 32-bit-Kompatibilitätsmodi unterstützt.
 Eine direkte 64-bit-Unterstützung würde eine Portierung des Kernels auf
 diese neuen Archietkuren erfordern, da sie sich von der bisher gängigen
 32-bit Intel-Architektur (IA32) zu stark unterscheiden.
 Eine solche Portierung ist in Zukunft aber durchaus denkbar.
\end_layout

\begin_layout Section
Der Startvorgang
\end_layout

\begin_layout Standard
Der Kernel wird auf der x86-Architektur durch den im Bereich der freien
 Software üblichen Bootloader 
\begin_inset Quotes gld
\end_inset

GRUB
\begin_inset Quotes grd
\end_inset

 gestartet.
 Dieser Bootloader lädt neben dem Kernel noch weitere Module in den Arbeitsspeic
her, die für den Betrieb des Gesamtsystems erforderlich sind.
\end_layout

\begin_layout Section
\begin_inset LatexCommand \label{sec:Aufb-virt-Addr}

\end_inset

Aufbau eines virtuellen Adressraums
\end_layout

\begin_layout Standard
Ein virtueller Adressraum hat in der x86-Architektur 4 GiB größe und ist
 in folgende Bereiche gegliedert:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="6cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="8cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Adressbereich
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Bedeutung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0x00000000 - 0x00000FFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Quotes gld
\end_inset

Zero-Page
\begin_inset Quotes grd
\end_inset

 - Der Zugriff auf diese Seite ist gesperrt, um NULL-Pointer leichter aufzudecke
n
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0x00001000 - 0xBFFFEFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Allgemeiner Benutzeradressraum
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0xBFFFF000 - 0xBFFFFFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Thread local storage
\emph default
 des aktuellen Threads (kein Caching; TLB wird bei jedem Kontext-Wechsel
 für diese Seite geleert)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0xC0000000 - 0xF7FFFFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Gesperrter Kernel-Adressraum (Mapping der unteren 896 MiB des physikalischen
 Adressraums)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0xF8000000 - 0xF8000FFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Haupt-Infopage
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0xF8001000 - 0xFB000FFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Prozesstabelle (Mapping der Prozessdeskriptoren; Im User-Mode nur lesbar,
 im Kernel-Mode R/W-Zugriff möglich)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0xFB001000 - 0xFE000FFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Threadtabelle (Mapping der Prozessdeskriptoren; Im User-Mode nur lesbar,
 im Kernel-Mode R/W-Zugriff möglich)
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0xFE001000 - 0xFFFDFFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Gesperrter Info-Page-Bereich (für spätere Versionen freigehalten)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0xFFFE0000 - 0xFFFFEFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Speichertransferpuffer (wird vom Kernel für Usermode-Speicherzugriffe verwendet
 - z.B.
 beim Copy-On-Write; kurz: UMCA)
\begin_inset LatexCommand \label{UMCA}

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0xFFFFF000 - 0xFFFFFFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Quotes gld
\end_inset

Last Page
\begin_inset Quotes grd
\end_inset

 - Der Zugriff auf diese Seite ist gesperrt, um NULL-Pointer zu vermeiden
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Caching und TLBs
\end_layout

\begin_layout Standard
Der Kernel verwendet die Caching-Fähigkeiten und die Translation-Lookaside-Buffe
r der x86-Architektur.
 Für Speicherseiten, die durch 
\emph on
io_alloc
\emph default
 in einen virtuellen Adressraum gemapt wurden, wird normalerweise der Cache
 deaktiviert - er kann aber auf Wunsch auch aktiviert werden.
 Normale Speicherseiten werden immer mit aktiviertem Cache gemapt.
 
\end_layout

\begin_layout Standard
Der 
\emph on
thread local storage
\emph default
 wird zwar mit aktiviertem Cache in einen virtuellen Adressraum eingeblendet,
 jedoch sorgt der Kernel mit der INVPLG-Instruktion der CPU dafür, dass
 der jeweilige TLB-Eintrag gelöscht wird, wenn ein Kontext-Wechsel zwischen
 Threads des gleichen Adressraums stattfindet.
 Gleiches gilt für die Info-Pages der Prozess- und Threadtabellen.
 Auch bei diesen wird automatisch eine INVPLG-Instruktion ausgeführt, sobald
 sich ein Mapping ändert.
\end_layout

\begin_layout Standard
Anonsten wird der TLB automatisch bei jeder 
\emph on
map
\emph default
, 
\emph on
unmap
\emph default
 oder 
\emph on
move
\emph default
 Operation automatisch geleert.
 TLB und Cache werden ebenfalls mit jedem Wechsel eines virtuellen Adressraums
 geleert.
 
\end_layout

\begin_layout Standard
Die unteren 896 MiB des Kernel-Adressraums, sowie alle Info-Pages werden
 durch das sog.
 Global-Flag der 80686-Architekturen markiert.
 Dieses Flag bewirkt, dass die CPU bei einem Adressraumwechsel den TLB für
 diese Speicherseiten nicht leert, was ebenfalls die Performance erhöhen
 kann.
 Da der Kernel ja statisch in jedem Adressraum liegt, ist dies kein größeres
 Problem.
\end_layout

\begin_layout Section
Systemaufrufe
\end_layout

\begin_layout Standard
Die Systemaufrufe des 
\emph on
hymk
\emph default
 werden durch Software-Interrupts mittels der INT-Instruktion der x86-Architektu
r realsiert.
 Während eines Systemaufrufs sie alle externen Interrupts gesperrt, da der
 Kernel derzeit nicth preemptiv implementiert ist.
 Nach einigen Systemaufrufen kann ein Kontext-Wechsel erfolgen, wodurch
 nicht sichergestellt sein kann, dass zwei aufeinanderfolgende Systemaufrufe
 - selbst bei gesperrten Interrupts - direkt nacheinander ausgeführt werden.
 
\end_layout

\begin_layout Standard
Die Systemaufrufe belegen die Interrupt-Vektoren 
\emph on
0xC0
\emph default
 bis 
\emph on
0xD5
\emph default
.
 Eine Ausweitung des Bereichs ist in späteren Versionen möglich.
\end_layout

\begin_layout Section
IRQs
\end_layout

\begin_layout Standard
Die 16 möglichen IRQs der x86-Architektur werden auf niedrigster Ebene im
 Kernel behandelt, aber von diesem an den Thread weitergegeben, der sich
 durch den Aufruf 
\emph on
recv_irqs
\emph default
 zur Behandlung eines IRQs gemeldet hat.
 Während ein Thread einen IRQ behandelt, wird die Behandlung des IRQs auf
 dem Interrupt-Controler der x86-Architektur (
\emph on
Programmable interrupt controler
\emph default
 - 
\begin_inset Quotes gld
\end_inset

PIC
\begin_inset Quotes grd
\end_inset

) gesperrt - es ist aber durchaus möglich, dass andere IRQs eintreten können.
 Somit dürfen IRQ-Behandlungsroutinen auch blockierende Operationen, wie
 
\emph on
sync
\emph default
, ausführen.
\end_layout

\begin_layout Standard
Der IRQ 0, der Interrupt der Systemuhr, wird vom Kernel mitverwendet, um
 die verbleibende CPU-Zeit eines Threads zu messen und ggf.
 (bei Ablauf dieser) einen Threadwechsel durchzuführen.
 Der IRQ 0 wird selbst bei Behandlung im Benutzer-Modus durch einen Thread
 nicht blockiert, wodurch durchaus während der Behandlung des IRQ 0 im Benutzerm
odus weitere Ereignisse des IRQs eintreten können, die von keinem weiteren
 Thread im Benutzer-Modues behandelt werden können.
 Daher kann z.B.
 durch die Behandlung des IRQ 0 im Benutzermodus nicht verlässlich als Zeitsigna
l zur Zeitmessung verwendet werden.
\end_layout

\begin_layout Standard
Die Software-Interrupts der IRQs leigen bei den Interrupt-Nummern 0xA0 bis
 0xAF.
 Sie sind für den Zugriff aus dem Benutzermodus gesperrt.
 Versucht ein Thread sie auszuführen löst er eine Schutzverletzung aus -
 es sei denn, seine Software-Interrupts werden durch einen anderen Thread
 mittels 
\emph on
recv_softints
\emph default
 behandelt.
\end_layout

\begin_layout Standard
Wichtig bei der Behandlung eines IRQs ist, dass der selbe Thread anschließend
 den gleichen IRQ wieder mit 
\emph on
recv_irqs
\emph default
 überwacht oder ihn durch 
\emph on
recv_irqs(0xFFFFFFFF)
\emph default
 freigibt - ansonsten bleibt der IRQ bis dahin gesperrt.
\end_layout

\begin_layout Section
Exceptions
\end_layout

\begin_layout Standard
Exceptions werden auf unterster Ebene durch den Kernel behandelt.
 Sie belegen die Software-Interrupts 
\emph on
0x00 
\emph default
bis 
\emph on
0x20
\emph default
, auch wenn die Intel-Architektur nicht alle davon verwendet.
 Die Exceptions sind in der Regel ebenfalls für den Zugriff aus dem Benutzermodu
s gesperrt.
 Einzige Ausnahme bilden die Softwareinterrupt 3, 4 und 5 die u.a.
 auch durch die Instruktionen 
\emph on
INTO
\emph default
 und 
\emph on
INT3
\emph default
 aufgerufen werden können.
 Alle Exceptions können durch 
\emph on
recv_softints
\emph default
 in den Benutzermodus umgeleitet werden, sowohl wenn sie durch einen tatsächlich
e Ausnahmefehler ausgelöst wurden, als auch wenn sie durch einen Software-Interr
upt mittels der 
\emph on
INT
\emph default
-Instruktion, 
\emph on
INTO
\emph default
 oder 
\emph on
INT3
\emph default
 ausgelöst wurden.
\end_layout

\begin_layout Section
Ungenutzte Softwareinterrupts
\end_layout

\begin_layout Standard
Der Aufruf der verbleibenden Interrupt-Vektoren ist prinzipiell zulässig.
 Der Kernel führt beim Aufruf eines unbenutzten Vektors keine weitere Operation
 durch.
 Es findet nur ein kurzer Wechsel zwischen Kernel- und Benutzer-Modus statt.
 Die ungenutzten Softwareinterrupts können ebenfalls durch 
\emph on
recv_softints
\emph default
 umgeleitet werden.
\end_layout

\begin_layout Section
Kernel-Debugging
\end_layout

\begin_layout Standard
Der Kernel bietet selbst kaum externe Eingriffsmöglichkeiten zum Kernel-Debuggin
g.
 Ist der Kernel jedoch im Debugging-Modus kompiliert worden, so gibt er
 eigenständig Fehlermeldungen aus.
\end_layout

\begin_layout Chapter
Die x86-Systemaufrufe
\end_layout

\begin_layout Section
Verwaltungsaufrufe
\end_layout

\begin_layout Subsection
alloc_pages
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC0
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Startadresse des Mapping
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Anzahl der zu reservierenden Speicherseiten
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Reserviert freie Seitenrahmen und fügt sie an der festgelegten Startadresse
 im aktuellen virtuellen Adressraum ein.
 Enthält ein Teil des Zielbereichs im aktuellen Adressraum bereits Seitenrahmen,
 so werden diese nicht überschrieben.
 Der Zielbereich darf weder ganz, noch teilweise im Kernel-Adressraum liegen.
 Er darf ebenfalls nicht im Bereich des
\emph on
 thread local storage
\emph default
 liegen.
 Der neue Speicherbereich wird als Lesbar, Beschreibbar und Ausführbar in
 den Adressraum eingeblendet.
\end_layout

\begin_layout Standard
Alle Bytes jeder neuegemappten Seite werden mit dem Wert 
\begin_inset Quotes gld
\end_inset

0
\begin_inset Quotes grd
\end_inset

 aufgefüllt.
 Bestehende Mappings, die von 
\emph on
alloc_pages
\emph default
 nicht ersetzt werden können, werden jedoch dabei nicht überschrieben.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Um einen zu langen Aufenthalt des Systems im Kernel-Mode zu verhindern,
 kann nur eine plattformspezifische Menge an Speicherseiten auf einmal alloziier
t werden.
 Für größere Bereiche sind mehrere Allokationen in Folge erforderlich.
 Die Anzahl der maximal alloziierbaren Seiten kann aus der Hauptinfopage
 entnommen werden.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ENOUGH_MEMORY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es steht nicht genug Speicher zur Verfügung.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_SYSCALL_RESTRICTED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es können nicht mehr als eine gewisse Anzahl von Seiten (normalerweise 8
 MiB) auf einmal alloziiert werden.
 Es fand keine Operation statt.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Zielbereich lag ganz oder teilweise im Kernel-Adressraum oder im 
\emph on
thread local storage
\emph default
.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
create_thread
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC1
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Startadresse des neuen Threads
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Anfangsadresse des Stacks des neuen Threads
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: SID des neuen Threads
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Erzeugt einen neuen Thread, der Anfangs noch durch 
\emph on
freeze_subject
\emph default
 eingefroren ist.
 Dieser neue Thread erbt von dem Thread, der ihn durch diesen Aufruf erstellt
 hat, dessen statische Priorität und dessen Schedulingklasse.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ENOUGH_MEMORY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es steht nicht genug Speicher zur Verfügung.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
create_process
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC2
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Startadresse des neuen Threads
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Anfangsadresse des Stacks des neuen Threads
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: SID des Controller-Threads des neuen Prozesses
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Erzeugt einen neuen Prozess mit leerem virtuellem Adressraum und richtet
 für ihn einen neuen Thread ein, der durch 
\emph on
freeze_subject 
\emph default
eingefroren ist, aber vom Erzeugerprozess gesendete map-Operationen gestattet.
 Der neue Thread erbt dabei sie statische Priorität und die Schedulingklasse
 seines Erzeugers.
 Der neue Thread wird automatisch als 
\emph on
controller thread
\emph default
 des neuen Prozesses verwendet.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ENOUGH_MEMORY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es steht nicht genug Speicher zur Verfügung.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
set_controller
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC3
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des neuen Controller-Threads
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Legt den Controller-Thread des aktuellen Prozesses fest.
 Der Thread muss selbstverständlich ein Thread des selben Prozesses sein.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die übergebene SID ist ungültig oder beschreibt keinen Thread, der zu diesem
 Prozess gehört.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
destroy_subject
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC4
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des betroffenen Prozess- oder Thread-Subjekts
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Vernichtet ein Subjekt und gibt seine Datenstrukturen frei.
 
\end_layout

\begin_layout Standard
Ein Prozess-Subjekt wird dabei allerdings nicht unmittelbar aufgelöst, sondern
 durch setzen eines Flags blockiert, so dass dessen Threads nicht mehr ausgeführ
t werden können.
 Dies ist sinnvoll, um die Threads eines Prozesses bereits vollständig und
 irreversibel zu blockieren, um dann Schritt für Schritt dessen Threads
 zu beenden.
 Dieser Blockade-Zustand wird als 
\begin_inset Quotes gld
\end_inset

Zombie-Modus
\begin_inset Quotes grd
\end_inset

 oder 
\begin_inset Quotes gld
\end_inset

Defunct-Modus
\begin_inset Quotes grd
\end_inset

 bezeichnet.
\end_layout

\begin_layout Standard
Ein Prozess wird erst dann tatsächlich aufgelöst, wenn alle seine Threads
 beendet wurden.
 Der Kernel gibt bei dieser Auflösung nicht die Speicherseiten des Prozesses
 frei - hierfür ist der Paging-Dämon zuständig.
 Der Kernel kümmert sich nur um die Freigabe der Deskriptoren, Seitentabellen
 und Seitenverzeichnisse.
 
\end_layout

\begin_layout Standard
Ein Thread-Subjekt wird bei diesem Vorgang tatsächlich beendet und alle
 dessen Datenstrukturen, wie Deskriptor, Kernelstack und 
\emph on
thread local storage
\emph default
 werden dabei vom Kernel freigegeben.
 War der Thread der 
\emph on
controller thread
\emph default
 seines Prozesses, so setzt der Kernel den Zeiger auf den 
\emph on
controller thread
\emph default
 des Prozesses auf 
\emph on
invalid
\emph default
.
 War der Thread der letzte Thread seines Prozesses, so wird der zugehörige
 Prozess anschließend auch aufgelöst (siehe oben).
 
\end_layout

\begin_layout Standard
Ein Thread kann sich durch den Aufruf von 
\emph on
destroy_subject
\emph default
 nicht selbst beenden.
 Ein Thread kann nur die Threads beenden, die zum selben Prozess gehören.
 Ist ein Thread Teil eines 
\emph on
root
\emph default
-Prozesses, so ist er auch in der Lage, fremde Threads zu beenden.
 Ein Prozess kann sich ebenfalls nicht durch den Aufruf von 
\emph on
destroy_subject
\emph default
 selbst in den Zombie-Modus versetzen.
 Hierfür ist der Aufruf von 
\emph on
destroy_subject 
\emph default
durch einen Root-Prozess erforderlich.
 Unabhängig davon können sich auch 
\emph on
root
\emph default
-Thrads und 
\emph on
root
\emph default
-Prozesse nicht selbst beenden.
 Das Ziel hierbei ist, ein unkontrolliertes Hinterlassen von Systemressourcen
 durch eine kontrollierte Beendigung der Prozesse zu vermeiden.
 
\end_layout

\begin_layout Standard
Versuchte ein anderer Thread sich mit dem zu zerstörenden Thread zu synchronisie
ren, so wird dessen Synchronisierung abgebrochen.
 Dies betrifft jedoch nur Threads, die sich ausdrücklich mit einem anderen
 Thread synchronisieren.
 Bei Synchronisation mit einem Prozess wird selbst bei Beendigung von diesem
 keine Aktion getätigt.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Bei Beendigung von Threads darf nur ein Thread des gleichen Prozesses einen
 anderen Thread beenden.
 
\emph on
root
\emph default
-Threads dürfen grundsätzlich alle Threads beenden.
 Ein Thread darf sich jedoch niemals selbst beenden.
\end_layout

\begin_layout Standard
Prozesse können ausschließlich nur durch 
\emph on
root
\emph default
-Threads beendet werden.
 Ein Prozess kann sich dabei auch nicht selbst beenden.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Threads des gleichen Prozesses und 
\emph on
root
\emph default
-Threads dürfen diesen Systemaufruf tätigen.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Sicherheitsfunktionen
\end_layout

\begin_layout Subsection
chg_root
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC5
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Prozess-Subjekt, das seinen root-Modus ändern soll.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Subjekt
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
0 soll den Root-Modus verlassen.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
1 soll den Root-Modus betreten.
\end_layout

\end_deeper
\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Wechselt einen Prozess in den Root-Modus oder entfernt ihn aus diesem.
 Beim Entfernen aus dem Root-Modus werden die I/O-Zugriffsrechte automatisch
 zurückgesetzt, d.h.
 der Zugriff auf I/O-Ports ist gesperrt.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Diese Operation ist nur Root-Prozessen erlaubt.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Prozess-SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Scheduler
\end_layout

\begin_layout Subsection
freeze_subject
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC6
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Threadsubjekts, das eingefroren werden soll (
\emph on
null
\emph default
 oder 
\emph on
invaild
\emph default
 für aktuellen Thread)
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Friert einen Thread ein.
 Dabei kann auch der aktuelle Thread eingefroren werden.
\end_layout

\begin_layout Standard
Wichtig ist, dass ein mehrfaches Einfrieren eines Subjekts dazu führt, dass
 es auch wieder mehrfach mit 
\emph on
awake_subject
\emph default
 aufgeweckt werden muss.
 
\end_layout

\begin_layout Standard
Das Einfrieren von Prozessen ist derzeit nicht möglich.
 Ebenfalls können Threads, die sich im Kernel-Modus befinden (z.B.
 weil sie auf eingehende Synchronisierungen warten) nicht eingefroren werden.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Diese Operation ist nur Root-Prozessen vorbehalten.
 Threads des gleichen Prozesses können diese Operationen ebenfalls untereinander
 anwenden.
 Der Zugriff auf den Kernel-Thread wird verweigert.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Ziel-SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ENOUGH_MEMORY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Das Subjekt wurde bereits so oft eingefroren, dass der zuständige Counter
 nicht mehr ausreicht.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
awake_subject
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC7
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Threadsubjekt, das aufgeweckt werden soll.
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Weckt einen eingefrorenen Thread wieder auf.
 Wichtig ist, dass jedes 
\emph on
freeze_subject
\emph default
 auf ein Subjekt ein 
\emph on
awake_subject
\emph default
 benötigt.
 D.h.
 wurde ein Subjekt zweimal eingefroren, muss es auch zwei Mal wieder aufgeweckt
 werden, ehe der Kernel es wieder in die Run-Queue des Schedulers aufnimmt.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Diese Operation ist nur Root-Prozessen vorbehalten.
 Threads des gleichen Prozesses können diese Operationen ebenfalls untereinander
 anwenden.
 Der Zugriff auf den Kernel-Thread wird verweigert.
 Das Aufwecken von Prozessen ist derzeit nicht möglich, kann aber ggf.
 in späteren Versionen eingeführt werden.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Ziel-SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Das betroffene Subjekt ist bereits aktiv.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
yield_thread
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC8
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Threads, der den Rest der effektiven Priorität empfangen soll
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Gibt die restliche effektive Priorität (also die CPU Zeit) des aktuellen
 Threads ab, so dass dieser die CPU solange verliert, bis alle anderen rechenber
eiten Threads vom Scheduler einmal aufgerufen worden sind
\begin_inset Foot
status collapsed

\begin_layout Standard
Wenn ein Thread, der mit 
\emph on
yield_thread
\emph default
 kurzzeitig die CPU abgegeben hat, von einem anderen Thread wieder ausreichend
 effektive Priorität über dessen 
\emph on
yield_thread
\emph default
-Operation erhält, so kann es passieren, dass er erneut aktiviert wird,
 bevor alle anderen Threads vom Scheduler bearbeitet wurden.
\end_layout

\end_inset

.
 Die restliche effektive Priorität kann dabei auch an einen anderen Thread
 weitergegeben werden, so dass dessen Chance erhöht wird, sofort nach dem
 aktuellen Thread aktiviert zu werden.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Ziel-SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
set_priority
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xC9
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des betroffenen Threads
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Neue Priorität (Zahl von 0 bis 40)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ECX: Neue Schedulingklasse
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
0 SCHED_REGULAR
\end_layout

\end_deeper
\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Ändert die statische Priorität eines Threads, sowie dessen Scheduling-Klasse
 (derzeit existiert nur eine).
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Nur Root-Prozesse können die Priorität oder die Scheduling-Klasse anheben.
 Andere Prozesse können sie nur absenken.
 Der Zugriff auf den Kernel-Thread wird verweigert.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Ziel-SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Priorität oder Scheduling-Klasse ist ungültig.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Gemeinsame Speichernutzung
\end_layout

\begin_layout Subsection
allow
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xCA
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID die für die Erlaubnis verwendet werden soll.
 Dies muss eine Thread-SID, eine Prozess-SID oder eine Prozessgruppen-SID
 sein.
 Wird 
\emph on
null
\emph default
 oder 
\emph on
invalid 
\emph default
verwendet, ist der Zugriff nur für den aktuellen Thread möglich - für alle
 anderen Threads ist er gesperrt.
 
\emph on
kernel
\emph default
 hat keine Wirkung.
 Die SID muss nicht gültig sein.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: SID des Threads, der die Allow-Operation ausführen soll (wichtig für
 Root-Threads).
 Soll die Operation im Namen des aktuellen Threads ausgeführt werden (Normalfall
), so wird einfach 
\emph on
invalid
\emph default
 als SID übergeben.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ECX: Startadresse des für die Operation genehmigten Bereichs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDX: Anzahl der Seiten des Bereichs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDI: Erlaubte Operationen (als Flags, die parallel gesetzt werden können):
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="block" valignment="top" width="4cm">
<column alignment="block" valignment="top" width="1.5cm">
<column alignment="block" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ALLOW_MAP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es ist erlaubt Seiten in den festgelegten Adressrbereich des virtuellen
 Adressraums des betroffenen Threads hineinzumappen (die Operation 
\emph on
move
\emph default
 eingeschlossen).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ALLOW_UNMAP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es ist erlaubt Seiten aus dem festgelegten Adressbereich des virtuellen
 Adressraums des betroffenen Threads zu entfernen oder die Zugriffsrechte
 darauf einzuschränken.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ALLOW_REVERSE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es ist erlaubt, Seiten mittels 
\emph on
MAP_REVERSE
\emph default
 aus dem Zieladressraum in den Quelladressraum zu mappen.
 (Impliziert 
\emph on
ALLOW_MAP
\emph default
)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Führt auf einen Thread die 
\emph on
allow
\emph default
 Operation aus, so dass auf einen bestimmten Speicherbereich des virtuellen
 Adressraums diees Threads die Speicheroperationen 
\emph on
map
\emph default
,
\bar under
 
\emph on
\bar default
unmap
\emph default
 und 
\emph on
move
\emph default
 angewendet werden können.
 Normalerweise führt ein Thread die Operation nur für sich selbst aus und
 setzt dabei als Ziel-SID auch 
\emph on
invalid
\emph default
.
 Die Freigabe des Kernel-Adressraums ist nicht zulässig.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die 
\emph on
allow
\emph default
 Operation kann normalerweise nur auf den eigenen Thread angewendet werden.
 Root-Prozesse haben das Recht die Operation auch auf andere Threads anzuwenden.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendeten Operationsflags sind ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Zieladresse überschneidet sich mit dem Kernel-Adressraum.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
map
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xCB
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Threads auf den die Operation angewandt werden soll (
\emph on
null
\emph default
 entspricht dem eigenen Thread)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Startadresse des Quellbereichs im eigenen Adressraum
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ECX: Anzahl der Seiten des Bereichs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDX: Flags:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features>
<column alignment="block" valignment="top" width="5cm">
<column alignment="block" valignment="top" width="1.8cm">
<column alignment="block" valignment="top" width="4cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAP_READ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Seiten können ausgelesen werden.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAP_WRITE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Seiten können beschrieben werden (auf x86 impliziert dies MAP_READ).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAP_EXECUTABLE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Speicherseiten können ausgeführt werden (auf x86 nicht verfügbar).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAP_COPYONWRITE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Speicherseiten sind für das Copy-On-Write Verfahren markiert, so dass
 effektiv kein gemeinsamer Speicherbereich, sondern eine Kopie des Speicherberei
chs entsteht.
 Hierbei werden ebenfalls die Seiten des Quellbereich für Copy-On-Write
 markiert!
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAP_PAGED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Speicherseite ist durch den Paging-Dämon geschützt.
 Ein Unmappen der Seite ist nicht gestattet (das Flag darf nur der Paging-Dämon
 verwenden).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAP_REVERSE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Mapping-Vorgang soll umgekehrt werden: Die Seiten des Zieladressraums
 sollen in den Quelladressraum gemappt werden.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EDI Offsetadresse im Zielbereich
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Richtet eine gemeinsame Speichernutzung aus dem gegebenen Speicherbereich
 des Adressraums des aktuellen Threads unter bestimmten Flags mit dem Adressraum
 eines Ziel-Threads ein.
 Das Mappen aus dem Kernel-Adressraum ist dabei nicht zulässig.
 
\end_layout

\begin_layout Standard
Ebenfalls dürfen bestehende Zugriffsbeschränkungen des eigenen Adressraums
 (z.B.
 Nur-Lesbarkeit eines Adressbereichs) nur dann im Zieladressraum durch die
 Flags aufgehoben werden, wenn der aufrufende Thread Teil eines Root-Prozesses
 ist (d.h.
 ist der zu mappende Bereich 
\begin_inset Quotes gld
\end_inset

nur lesbar
\begin_inset Quotes grd
\end_inset

, so können nicht-Root-Prozesse ihn auch nur als 
\begin_inset Quotes gld
\end_inset

nur lesbar
\begin_inset Quotes grd
\end_inset

 weitergeben).
 Das Erhöhen der Privilegien wird lediglich unterbunden und führt nicht
 zu einem Abbruch der Map-Operation.
 Root-Prozesse können dagegen fehlende Zugriffsrechte einer Speicherseite
 hinzufügen.
 Eigenschaften, wie ein abgeschaltetes Caching werden 
\begin_inset Quotes gld
\end_inset

vererbt
\begin_inset Quotes grd
\end_inset

.
\end_layout

\begin_layout Standard
Ist eine Seite im Quellmapping für Copy-On-Write markiert, so wird die Copy-On-W
rite-Prozedur für diese Seite im Quellmapping ausgelöst, um einen undefinierten
 Zustand der Seite bei der gemeinsamen Nutzung zu vermeiden.
 Dieser Vorgang wird jedoch unterbunden, wenn das Flag 
\emph on
MAP_COPYONWRITE
\emph default
 gesetzt ist und das Zielmapping somit eine auf Copy-On-Write basierte Kopie
 des Quellmappings darstellen soll.
\end_layout

\begin_layout Standard
Enthält ein Teil des Zieladressraums bereits Seitenrahmen, so bleiben diese
 bestehen.
 D.h.
 bevor in einen Bereich gemapt werden kann, muss sichergestellt sein, dass
 er keine Speicherseiten mehr enthält (dies ist die Aufgabe einer sauberen
 Speicherverwaltung im Benutzermodus).
 
\end_layout

\begin_layout Standard
Das Flag 
\emph on
MAP_REVERSE
\emph default
 kehrt die Richtung des Vorgangs um.
 Das Zielmapping wird zum Quellmapping und vice versa.
 Alle genannten Einschränkungen und Sicherheitsrichtlinien gelten entsprechend
 umgekehrt.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation erfordert, dass auf die Gegenseite zuvor eine 
\emph on
allow
\emph default
-Operation ausgeführt wurde, so dass die Zieladresse und die maximale Zielgröße
 und die Zugriffsbeschränkungen bekannt sind.
 Der Quellbereich muss in den Zielbereich hineinpassen.
 Der Zugriff kann verweigert werden, wenn die Zugriffsbeschränkungen der
 vorausgegangene 
\emph on
allow
\emph default
-Operation den Zugriff nicht gestattet hat.
\end_layout

\begin_layout Standard
Grundsätzlich kann nur eine bestimmte, plattformspezifische Anzahl von Speichers
eiten auf einmal von der 
\emph on
map
\emph default
-Operation verarbeitet werden.
 Der entsprechende Wert kann aus der Hauptinfoseite entnommen werden.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_PAGING_DAEMON
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Das Flag 
\family typewriter
MAP_PAGED
\family default
 kann nur durch den Paging-Dämon verwendet werden.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_PAGES_LOCKED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Copy-On-Write-Operation konnte für eine Seite nicht ausgeführt werden.
 Ursache könnte eine gesperrte Speicherseite oder mangelnder Arbeitsspeicher
 sein.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Ziel-SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_SYSCALL_RESTRICTED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es kann nur eine gewisse Anzahl von Seiten (normalerweise 8 MiB) auf einmal
 von 
\emph on
map
\emph default
 verarbeitet werden.
 Es fand keine Operation statt.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendeten Operationsflags sind ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Quelladresse überschneidet sich mit dem Kernel-Adressraum.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
unmap
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xCC
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Threads auf den die Operation angewandt werden soll.
 Wird 
\emph on
null
\emph default
 oder 
\emph on
invalid
\emph default
 übergeben, wird als Ziel der aktuelle Thread verwendet.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Startadresse des Zielbereichs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ECX: Anzahl der Seiten des Bereichs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDX: Flags:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="block" valignment="top" width="5cm">
<column alignment="block" valignment="top" width="1.5cm">
<column alignment="block" valignment="top" width="4cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
UNMAP_COMPLETE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Seiten sollen vollständig aus dem Adressraum entfernt werden.
 Der physikalische Seitenrahmen wird freigegeben, wenn kein anderer Prozess
 ihn mehr benutzt.
 Hierbei wird das Schutz-Flag des Paging-Dämons verändert.
 Ist der Aufrufer nicht der Paging-Dämon, so wird eine Paging-Exception
 ausgelöst, sofern der Paging-Dämon die Seite als geschützt markiert.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
UNMAP_AVAILABLE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Speicherseiten sollen als nicht-vorhanden markiert werden.
 Der physikalische Seitenrahmen wird freigegeben, wenn kein anderer Prozess
 ihn mehr benutzt.
 Das Schutz-Flag des Paging-Dämons bleibt dabei unberührt.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
UNMAP_WRITE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Seiten dürfen nur noch ausgelesen werden.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
UNMAP_EXECUTE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Speicherseiten dürfen nicht mehr ausgeführt werden.
 (auf x86 ineffektiv)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Entfernt einen Speicherbereich aus einem Adressraum, der einem bestimmten
 Thread zugeordnet ist oder reduziert zumindest die Zugriffsrechte auf diesen.
 Der Zugriff auf den Kernel-Adressraum ist auf keinen Fall gestattet.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation erfordert, dass auf die Gegenseite zuvor eine 
\emph on
allow
\emph default
-Operation ausgeführt wurde, so dass die Zieladresse und die Zugriffsbeschränkun
gen bekannt sind.
 Die Zieladresse und die Größe müssen in dem Bereich liegen, der von der
 
\emph on
allow
\emph default
-Operation freigegeben wurde.
 Der Zugriff kann verweigert werden, wenn die Zugriffsbeschränkungen der
 vorausgegangene 
\emph on
allow
\emph default
-Operation den Zugriff nicht gestattet hat.
\end_layout

\begin_layout Standard
Führt ein root-Prozess diese Operation aus, so kann er auch ohne vorangegangene
 
\emph on
allow
\emph default
-Operation 
\emph on
unmap
\emph default
 ausführen und ebenfalls den Zielbereich übertreten.
 Gleiches gilt ebenfalls, wenn ein Thread die Operation auf sich selbst
 ausführt.
\end_layout

\begin_layout Standard
Führt ein Thread die unmap-Operation auf sich selbst aus, kann dies ohne
 ein vorausgegangenes 
\emph on
allow
\emph default
 geschehen.
\end_layout

\begin_layout Standard
Es kann ferner nur eine gewisse, plattformspezifische Anzahl von Speicherseiten
 auf einmal von der 
\emph on
unmap
\emph default
-Operation verarbeitet werden.
 Die Anzahl kann aus der Hauptinfopage entnommen werden.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_PAGING_DAEMON
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Auf eine vom Paging-Dämon geschützte Seite konnte 
\emph on
unmap
\emph default
 nicht mit 
\emph on
UNMAP_COMPLETE
\emph default
 angewendet werden.
 Es wurde aber möglicherweise auf einige Seiten 
\emph on
unmap
\emph default
 ausgeführt.
 Dieser Fehler sollte nur bei sehr schwerwiegenden Systemfehlern auftreten
 und kann daher in der Regel vernachlässigt werden.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Ziel-SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_SYSCALL_RESTRICTED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es sollten mehr als die plattformspezifische Anzahl von Seiten (normalerweise
 8 MiB) auf einmal mit 
\emph on
unmap
\emph default
 bearbeitet werden.
 Es fand keine Verarbeitung statt.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendeten Operationsflags sind ungültig oder die Zieladresse überschneidet
 sich mit dem Kernel-Adressraum.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
move
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xCD
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Threads auf den die Operation angewandt werden soll
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Startadresse des Quellbereichs im lokalen Adressraum
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ECX: Anzahl der Seiten des Bereichs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDX: Flags (siehe 
\emph on
map
\emph default
)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDI Offsetadresse im Zielbereich
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Verschiebt einen Adressraum des aktuellen Threads in einen Adressraum eines
 bestimmten Ziel-Threads.
 Das Verschieben ist eine Kombinierte 
\emph on
map
\emph default
 Operation auf den Zieladressraum und eine im Anschluß stattfindende 
\emph on
unmap
\emph default
 Operation auf den lokalen Adressraum.
 Das Verschieben von Teilen des Kernel-Adressraums ist nicht zulässig.
 Enthält ein Teil des Zieladressraums bereits Seitenrahmen, so werden diese
 freigegeben und der Bereich durch das Quellmapping ersetzt.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation erfordert, dass auf die Gegenseite zuvor eine 
\emph on
allow
\emph default
-Operation ausgeführt wurde, so dass die Zieladresse und die Zugriffsbeschränkun
gen bekannt sind.
 Der Quellbereich muss in den Zielbereich passen, der von der 
\emph on
allow
\emph default
-Operation freigegeben wurde.
 Der Zugriff kann verweigert werden, wenn die Zugriffsbeschränkungen der
 vorausgegangene 
\emph on
allow
\emph default
-Operation den Zugriff nicht gestattet hat.
 
\end_layout

\begin_layout Standard
Für die Anzahl der Seiten, die von 
\emph on
move 
\emph default
maximal auf einmal verarbeitet werden können, gilt das gleiche, wie für
 
\emph on
map
\emph default
 und 
\emph on
unmap
\emph default
.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Ziel-SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_SYSCALL_RESTRICTED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es sollten mehr als die plattformspezifische Anzahl von Seiten (normalerweise
 8 MiB) auf einmal mit 
\emph on
move
\emph default
 bearbeitet werden.
 Es fand keine Verarbeitung statt.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendeten Operationsflags sind ungültig oder die Zieladresse überschneidet
 sich mit dem Kernel-Adressraum.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Synchronisation
\end_layout

\begin_layout Subsection
sync
\begin_inset LatexCommand \label{sub:sync}

\end_inset


\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xCE
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID der Gegenseite
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Länge des Timeouts (ungefähr) in Millisekunden (0 = kein Warten, 0xFFFFFFFF
 = unendlich)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ECX: Anzahl der Resync-Vorgänge (0 = kein Resync)
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: SID des Threads, der sich mit dem Aufrufer synchronisiert hat
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Synchronisiert zwei Threads innerhalb eines bestimmten (oder unendlichen)
 Timeouts miteinander - d.h.
 der Aufrufer wartet, bis ein gewählter anderer Thread (definiert durch
 den Parameter 
\emph on
SID
\emph default
) ebenfalls 
\emph on
sync
\emph default
 mit seiner SID aufruft.
 Wird das Timeout 0 gesetzt, wird nicht auf die Gegenseite gewartet, sondern
 die Operation sofort wieder abgebrochen.
\end_layout

\begin_layout Standard
Das Warten geschieht weitgehend passiv, so dass durch den Wartevorgang keine
 oder relativ wenig CPU-Zeit verbraucht wird.
 Der Kernel kann zur Umsetzung interne Warteschleifen einsetzen.
 Gewartet wird solange, bis die Gegenseite die Synchronisierung gestattet
 - d.h.
 auch wenn die Gegenseite sich derzeit auf eingehende Synchronisationen
 wartet, aber die Synchronisation mit dem Aufrufer verbietet, wartet der
 Aufrufer, bis sich dieser Zustand der Gegenseite ändert oder das Timeout
 abläuft.
\end_layout

\begin_layout Standard
Die Gegenseite, auf die ein Thread wartet, kann
\end_layout

\begin_layout Itemize
ein bestimmter Thread (definiert durch dessen Thread-SID) sein
\end_layout

\begin_layout Itemize
ein beliebiger Thread eines bestimmten Prozesses (definiert durch die Prozess-SI
D) sein
\end_layout

\begin_layout Itemize
ein beliebiger Thread aller Prozesse sein, die sich im 
\emph on
root
\emph default
-Modus befinden (definiert durch die 
\emph on
root
\emph default
-SID)
\end_layout

\begin_layout Itemize
ein beliebiger Thread (definiert durch die 
\emph on
everybody
\emph default
-SID) sein
\end_layout

\begin_layout Standard
Wichtig ist hierbei, dass bei einer Synchronisierung grundsätzlich einer
 der beiden Seiten eine konkrete Thread-SID angeben muss, da sonst das Ziel
 nicht genau spezifiziert ist.
\newline
Um unnötige Wechsel zwischen Kernel- und Benutzermo
dus zu vermeiden, kann ein Thread eine automatische Wiederholung des selben
 Synchronisationsvorgangs bei erfolgreicher Synchronisation anordnen.
 In einem Client-Server-System ist es z.B.
 oft der Fall, dass der Client sich zuerst mit dem Worker-Thread des Servers
 synchronisiert, um diesen zu signalisieren, dass ein neuer Auftrag ansteht
 und anschließend auf eingehende Synchronisation des Worker-Threads wartet,
 damit dieser ihm die Fertigstellung des Auftrags signalisiert.
 Durch die automatische Resynchronisierung kann hier ein überflüssiger Wechsel
 zwischen Kernel- und Benutzeradressraum vermieden werden.
\end_layout

\begin_layout Standard
Als Rückgabewert wird dem Aufrufer die Thread-SID der Gegenseite übermittelt,
 die sich tatsächlich synchronisiert hat.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation erfordert, dass die Gegenseite den Zugriff von einer SID erlaubt,
 die dem jeweiligen aufrufenden Thread zugänglich ist (Thread-SID, Prozess-SID,
 
\emph on
root
\emph default
/
\emph on
everybody
\emph default
).
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendeten Operationsflags sind ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_TIMED_OUT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Das Timeout wurde erreicht.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_RESOURCE_BUSY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Warteschlange für den Ziel-Thread ist voll.
 Ein passives Warten ist derzeit nicht möglich.
 Es wird aktives Warten im Benutzer-Modus empfohlen.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Eingabe/Ausgabe
\end_layout

\begin_layout Subsection
io_allow
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xCF
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Zielprozesses
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Flags:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="block" valignment="top" width="5cm">
<column alignment="block" valignment="top" width="1.5cm">
<column alignment="block" valignment="top" width="4cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
IO_ALLOW_IRQ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Prozess hat nun das Recht IRQs zu behandeln, auch wenn er kein Root-Prozess
 ist.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
IO_ALLOW_PORTS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Prozess hat nun das Recht auf I/O-Ports zuzugreifen, auch wenn er kein
 Root-Prozess ist.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Erlaubt einem Nicht-Root-Prozess bestimmte I/O-Systemaufrufe und I/O-Instruktion
en auszuführen, die sonst nur Root-Prozessen vorbehalten sind.
 Dadurch lassen sich Treiber realisieren, die nicht im Root-Modus laufen.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation kann nur von Root-Prozessen ausgeführt werden.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ROOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete Prozess-SID ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendeten Operationsflags sind ungültig.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
io_alloc
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xD0
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Zu reservierender Quellspeicherbereich
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Zielspeicherbereich des Mappings
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ECX: Anzahl der zu mappenden Seiten
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDX: Flags:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="block" valignment="top" width="5cm">
<column alignment="block" valignment="top" width="1.5cm">
<column alignment="block" valignment="top" width="4cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
IOMAP_READ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der gemappte Hardwarespeicherbereich darf ausgelesen werden.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
IOMAP_WRITE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der gemappte Hardwarespeicherbereich darf beschrieben werden (impliziert
 auf x86 IOMAP_READ).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
IOMAP_EXECUTE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der gemappte Hardwarespeicherbereich darf ausgeführt werden (auf x86 ineffektiv).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
IOMAP_WITH_CACHE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aktiviert den Cache beim Mappen (sollte bei den meisten Hardwarespeicherbreichen
 nicht verwendet werden!)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Mappt einen Hardwarespeicherbereich in den Adressraum des aktuellen Prozesses.
 Einige Speicherbereiche, z.B.
 Kernel-Code und Daten, sowie die PBT, FMT und der Page-Buffer können dabei
 nicht gemappt werden.
 Als Ziel kann nicht der Kerneladressraum verwendet werden.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation kann nur von Root-Prozessen ausgeführt werden.
 Außerdem kann nur eine bestimmte plattformspezifische Anzahl von Seiten
 auf einmal von 
\emph on
io_alloc
\emph default
 verarbeitet werden.
 Die Anzahl kann aus der Hauptinfopage in Erfahrung gebracht werden.
\end_layout

\begin_layout Standard
Bestehende Seitenmappings werden nicht aufgelöst.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ROOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der verwendete Ziel- oder Quellbereich ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_SYSCALL_RESTRICTED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es sollten mehr als die plattformspezifische Anzahl von Seiten (normalerweise
 8 MiB) auf einmal mit 
\emph on
io_alloc
\emph default
 bearbeitet werden.
 Es fand keine Verarbeitung statt.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendeten Operationsflags sind ungültig.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
recv_irq
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xD1
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Zu überwachender IRQ
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Lässt den aktuellen Thread auf einen eintreffenden IRQ warten.
 Wird während einer laufenden Behandlung des zu überwachenden IRQs dieser
 Aufruf auf denselben oder einen anderen IRQ gestartet, so wird die laufende
 Behandlung damit beendet und erneut auf den genannten IRQ gewartet, sofern
 nicht ein anderer Thread auf den IRQ wartet.
 Der Kernel übernimmt dabei auch die Informierung des PICs.
 Wird als zu überwachender IRQ während einer Behandlung die Nummer 0xFFFFFFFF
 angegeben, so wird die IRQ-Behandlung beendet, ohne auf neue IRQs zu warten.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation kann nur von Root-Prozessen ausgeführt werden, oder von Prozessen
 denen das Recht der IRQ-Behandlung über 
\emph on
io_allow
\emph default
 zugestanden wurde.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_ACCESS_DENIED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die verwendete IRQ-Nummer ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_RESOURCE_BUSY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der IRQ wird bereits von einem anderen Thread behandelt.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Thread-Fernsteuerung
\end_layout

\begin_layout Subsection
recv_softints
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xD2
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Zu überwachender Thread
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Timeout, (ungefähr) in Millisekunden (0 = kein Timeout, 0xFFFFFFFF
 unendliches Timeout)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ECX: Flags
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="block" valignment="top" width="5cm">
<column alignment="block" valignment="top" width="1.5cm">
<column alignment="block" valignment="top" width="4cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
RECV_AWAKE_OTHER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der zu beobachtende Thread soll beim Start der Beobachtung mit 
\emph on
awake_subject
\emph default
 aufgeweckt werden.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\begin_inset LatexCommand \label{RECV_TRACE_SYSCALL}

\end_inset

RECV_TRACE_SYSCALL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Tritt ein Systemaufruf ein, wird dessen Behandlung nicht unterdrückt, sondern
 nur weitergemeldet.
 Anschließend wird der überwachte Thread angehalten.
 Andere Arten von Softwareinterrupts (insb.
 Exceptions) werden auch weiterhin unterdrückt.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Eingetretener Software-Interrupt
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Überwacht auftretende Software-Interrupts eines Ziel-Threads.
 Tritt ein Software-Interrupt ein, wird dies an den Überwacher weitergemeldet.
 Der Software-Interrupt wird dabei nicht vom Kernel behandelt, sondern der
 überwachende Thread kann die Behandlung durchführen.
 Der überwachte Thread wird zudem mit 
\emph on
freeze_subject
\emph default
 angehalten.
\end_layout

\begin_layout Standard
Wird das Flag 
\emph on
RECV_TRACE_SYSCALL 
\emph default
gesetzt, so werden vom Kernel alle Software-Interrupts behandelt, die Systemaufr
ufe ausführen.
 Unabhängig davon wird der Software-Interrupt dennoch weitergemeldet und
 wird nach dessen Ausführung der überwachte Thread angehalten.
\end_layout

\begin_layout Standard
Für die Operation kann ein Timeout gesetzt werden.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation kann nur von Root-Prozessen ausgeführt werden.
 Der Zugriff auf den Kernel-Thread wird verweigert.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ROOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die SID des zu überwachenden Threads ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_TIMED_OUT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Das Timeout endete.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
read_regs
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xD3
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Threads, dessen Register gelesen werden sollen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Zu lesender Register-Typus
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="block" valignment="top" width="5.5cm">
<column alignment="block" valignment="top" width="1.5cm">
<column alignment="block" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
REGS_X86_GENERIC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(1) EAX
\end_layout

\begin_layout Standard
(2) EBX
\end_layout

\begin_layout Standard
(3) ECX
\end_layout

\begin_layout Standard
(4) EDX
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
REGS_X86_INDEX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(1) ESI
\end_layout

\begin_layout Standard
(2) EDI
\end_layout

\begin_layout Standard
(3) EBP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
REGS_X86_POINTERS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(1) ESP
\end_layout

\begin_layout Standard
(2) EIP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
REGS_X86_EFLAGS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(1) EFLAGS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: (1)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ECX: (2)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDX: (3)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ESI: (4)
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Liest einige Register eines Threads aus.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation kann nur von Root-Prozessen ausgeführt werden.
 Der Zugriff auf den Kernel-Thread wird verweigert.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ROOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die SID des zu kontrollierenden Threads ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der gewählte Registertyp ist ungültig.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
write_regs
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xD4
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: SID des Threads, in dessen Register geschrieben werden sollen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Zu schreibender Register-Typus
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="block" valignment="top" width="5.5cm">
<column alignment="block" valignment="top" width="1.5cm">
<column alignment="block" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
REGS_X86_GENERIC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(1) EAX
\end_layout

\begin_layout Standard
(2) EBX
\end_layout

\begin_layout Standard
(3) ECX
\end_layout

\begin_layout Standard
(4) EDX
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
REGS_X86_INDEX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(1) ESI
\end_layout

\begin_layout Standard
(2) EDI
\end_layout

\begin_layout Standard
(3) EBP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
REGS_X86_POINTERS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(1) ESP
\end_layout

\begin_layout Standard
(2) EIP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
REGS_X86_EFLAGS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(1) EFLAGS
\end_layout

\begin_layout Standard
Nur Änderung des ersten Bytes möglich
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
ECX: (1)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDX: (2)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ESI: (3)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EDI: (4)
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Ändert die Register eines Threads.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation kann nur von Root-Prozessen ausgeführt werden.
 Der Zugriff auf den Kernel-Thread wird verweigert.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ROOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die SID des zu kontrollierenden Threads ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ARGUMENT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der gewählte Registertyp ist ungültig.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Paging-Funktionen
\end_layout

\begin_layout Subsection
set_paged
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xD5
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
Keiner.
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Legt den aktuellen Thread als Paging-Dämon-Thread fest.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation kann nur von Root-Prozessen ausgeführt werden.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ROOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_PAGING_DAEMON
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Es ist bereits ein Thread als Paging-Dämon eingetragen.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
test_page
\end_layout

\begin_layout Description
Interrupt: 
\end_layout

\begin_deeper
\begin_layout Standard
0xD6
\end_layout

\end_deeper
\begin_layout Description
Eingabeparameter:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX Adresse der Speicherseite
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX Prozess SID des Zieladressraums (
\emph on
invalid
\emph default
 oder 
\emph on
null
\emph default
 für den aktuellen Adressraum)
\end_layout

\end_deeper
\begin_layout Description
Rückgabewerte:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
EAX: Fehlercode
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
EBX: Zugriffsflags der Page:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="block" valignment="top" width="5.5cm">
<column alignment="block" valignment="top" width="2cm">
<column alignment="block" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
PGA_READ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Lesen ist erlaubt.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
PGA_WRITE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Schreiben ist erlaubt.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
PGA_EXECUTE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Ausführen ist erlaubt.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Description
Beschreibung:
\end_layout

\begin_deeper
\begin_layout Standard
Gibt die Zugriffsrechte auf eine Speicherseite in einem Zieladressraum zurück.
\end_layout

\end_deeper
\begin_layout Description
Beschränkungen:
\end_layout

\begin_deeper
\begin_layout Standard
Die Operation kann nur von Root-Prozessen auf fremde Adressräume ausgeführt
 werden.
 Die Prüfung des eigenen Adressraums ist unbeschränkt.
\end_layout

\end_deeper
\begin_layout Description
Fehlercodes:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="block" valignment="top" width="6cm">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_NOT_ROOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Operationsbeschränkungen wurden übertreten.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die SID des Zieladressraums ist ungültig.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
ERR_INVALID_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die angegebene Adresse liegt im Kernel-Adressraum.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Chapter
Informationsseiten
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Die Info-Pages
\end_layout

\begin_layout Subsection
Die Hauptinfopage
\begin_inset LatexCommand \label{sub:Die-Hauptinfopage}

\end_inset


\end_layout

\begin_layout Standard
Die Hauptinfopage ist bei der x86-Architektur an Adresse 
\family typewriter
\size small
0xF8000000
\family default
\size default
 und ist wie jede andere x86-Seite 4096 Byte groß.
 Ihre Einträge sind 32-bit breit.
 Der Zugriff ist vom Kernel aus im Schreib-Lese-Modus und vom Benutzer-Modus
 aus im Lese-Modus möglich.
 Sie hat folgenden Aufbau:
\end_layout

\begin_layout Itemize
Die SID des aktuellen Prozesses
\end_layout

\begin_layout Itemize
Die SID des aktuellen Threads
\end_layout

\begin_layout Itemize
Einen Zeiger auf den Prozesstabelleneintrag des aktuellen Prozesses
\end_layout

\begin_layout Itemize
Einen Zeiger auf den Threadtabelleneintrag des aktuellen Threads
\end_layout

\begin_layout Itemize
Die Versionsnummer des Kernels
\end_layout

\begin_layout Itemize
SID des Paging-Dämons
\end_layout

\begin_layout Itemize
Der aktuelle RTC-Zähler (als 64-bit Wert verteilt über zwei 32-bit Einträge)
\end_layout

\begin_layout Itemize
Der Idendifikationscode für die CPU (z.B.
 0x80386)
\end_layout

\begin_layout Itemize
Die Größe einer Speicherseite auf dieser Plattform
\end_layout

\begin_layout Itemize
Anzahl von Seiten, die maximal in einem Systemaufruf (z.B.
 alloc_pages, io_alloc, map) 
\end_layout

\begin_layout Itemize
CPU-Daten:
\end_layout

\begin_deeper
\begin_layout Itemize
CPU-Name (12-Byte)
\end_layout

\begin_layout Itemize
CPU-Typ
\end_layout

\begin_layout Itemize
CPU-Familie
\end_layout

\begin_layout Itemize
CPU-Modell
\end_layout

\begin_layout Itemize
Stepping-ID
\end_layout

\begin_layout Itemize
Größe des physikalischen Adressraums
\end_layout

\end_deeper
\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
Die Prozesstabelle
\begin_inset LatexCommand \label{sub:Die-Prozesstabelle}

\end_inset


\end_layout

\begin_layout Standard
Die Prozesstabelle liegt bei der x86-Architektur im Adressbereich 
\family typewriter
\size small
0xF8001000 - 0xFA000FFF
\family default
\size default
.
 Sie besteht aus Einträgen zu je zwei Pages, wobei eine Page den Prozessdeskript
or, und die zweite dessen Speicherverwaltungstabelle enthält.
 Da maximal 4096 Prozesse zulässig sind, hätte sie somit eine Größe von
 32 MiB.
 Die Einträge für nicht aktive Prozesse werden mit dem gleichen leeren Speichers
eitenrahmen abgedeckt.
 Die restlichen Einträge bestehen aus beliebig allokierten Seitenrahmen,
 die in diese Tabelle vom Kernel eingeblendet wurden.
 Sie ist vom Kernel aus im Schreib-Lese-Modus erreichbar, vom Benutzer-Modus
 im Nur-Lese-Modus.
 
\end_layout

\begin_layout Subsubsection
Prozessdeskriptoren
\end_layout

\begin_layout Standard
Die Prozessdeskriptoren haben Einträge zu je 32-bit breite und folgenden
 Aufbau:
\end_layout

\begin_layout Itemize
Flag, das festlegt, ob der Deskriptor in gebraucht ist (1) oder nicht (0)
\end_layout

\begin_layout Itemize
Flag, das festlegt, ob der Prozess entgültig gestoppt wurde (1) oder nicht
 (0)
\end_layout

\begin_layout Itemize
SID des Prozesses
\end_layout

\begin_layout Itemize
SID des 
\emph on
controller threads
\end_layout

\begin_layout Itemize
Zeiger auf den Deskriptor des 
\emph on
controller threads
\end_layout

\begin_layout Itemize
Anzahl der verwendeten Speicherseiten
\end_layout

\begin_layout Itemize
I/O-Zugriffsrechte des Prozesses (IRQs, I/O-Ports)
\end_layout

\begin_layout Itemize
Seitenrahmen der obersten Seitentabelle (
\emph on
page directory
\emph default
) des Prozesses
\end_layout

\begin_layout Itemize
Flag, das festlegt, ob der Prozess ein Paging-Dämon ist (1) oder nicht (0)
\end_layout

\begin_layout Itemize
Zähler, der die Anzahl der Threads eines Prozesses angibt
\end_layout

\begin_layout Itemize
Zeiger auf den ersten Thread aus der Liste der Threads des Prozesses
\end_layout

\begin_layout Itemize
Eindeutige Prozess-ID
\end_layout

\begin_layout Subsubsection
\begin_inset LatexCommand \label{sub:Die-Speicherverwaltungstabelle}

\end_inset

Die Speicherverwaltungstabelle
\end_layout

\begin_layout Standard
Die Speicherverwaltungstabelle des Kernels enthält 1024 Einträge, wobei
 jeder Eintrag für einen Eintrag im Page-Directory des Prozesses steht und
 somit auch für einen entsprechenden 4 MiB-Speicherbereich im virtuellen
 Adressraum.
 Im Unterschied zur Page-Directory gibt die Speicherverwaltungstabelle nicht
 die Adressen der jeweiligen Seitentabellen an, sondern wieviele Seitendeskripto
ren in einer Seitentabelle derzeit aktiv sind und wieviele nicht.
 Dadurch ermittelt der Kernel u.a.
 wann eine Seitentabelle freigegeben werden darf udn wann nicht.
 Der Kernel-Adressraum ist hierin nicht abgebildet.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Subsection
Die Thread-Tabelle
\begin_inset LatexCommand \label{sub:Die-Thread-Tabelle}

\end_inset


\end_layout

\begin_layout Standard
Die Threadtabelle liegt bei der x86-Architektur im Adressbereich 
\family typewriter
\size small
0xFB001000 - 0xFD000FFF
\family default
\size default
.
 Sie besteht aus Einträgen zu je zwei Pages, wobei eine Page den Threaddeskripto
r und die andere dessen 
\emph on
thread local storage
\emph default
 enthält.
 Da maximal 4096 Threads zulässig sind, hat sie somit eine Größe von 32
 MiB.
 Die Einträge für nicht aktive Threads werden mit dem gleichen leeren Speicherse
itenrahmen abgedeckt.
 Die restlichen Einträge bestehen aus beliebig allokierten Seitenrahmen,
 die in diese Tabelle vom Kernel eingeblendet wurden.
 Sie ist vom Kernel aus im Schreib-Lese-Modus erreichbar, vom Benutzer-Modus
 im Nur-Lese-Modus.
 
\end_layout

\begin_layout Subsubsection
Implementationsunabhängige Daten
\end_layout

\begin_layout Itemize
Flag, das festlegt, ob der jeweilige Deskriptor in gebrauch ist (1) oder
 nicht (0)
\end_layout

\begin_layout Itemize
SID des Threads
\end_layout

\begin_layout Itemize
SID des Prozesses
\end_layout

\begin_layout Itemize
SID-Berechtigung (bzw.
 Ziel-SID) für 
\emph on
sync
\end_layout

\begin_layout Itemize
SID-Berechtigung für Speicheroperationen
\end_layout

\begin_layout Itemize
Zieladresse für Speicheroperationen
\end_layout

\begin_layout Itemize
Größe für Speicheroperationen
\end_layout

\begin_layout Itemize
Zulässige Speicheroperationen
\end_layout

\begin_layout Itemize
Erster Seitenrahmen des Kernel-Stacks des Threads (eine Adresse relativ
 zum Begin des Kernel-Adressraums)
\end_layout

\begin_layout Itemize
Zeiger auf den Deskriptor des Prozesses
\end_layout

\begin_layout Itemize
Weitere Flags:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features islongtable="true">
<column alignment="block" valignment="top" width="5.5cm">
<column alignment="block" valignment="top" width="1.9cm">
<column alignment="block" valignment="top" width="5.55cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_BUSY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread ist aus irgendeinem Grund blockiert und nicht rechenbereit (Grund
 als Flag sichtbar)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_KERNEL_MODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread befindet sich im Kernel-Modus.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_IRQ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread wartet auf IRQs
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_IRQ_HANDLING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread behandelt einen IRQ
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_SYNC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread synchronisiert sich mit einem anderen Thread.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_TIMEOUT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread hat ein Timeout gesetzt, das der Scheduler überwachen soll.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_RECV_SOFTINT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread wartet auf eingehende Softwareinterrupts eines anderen Threads.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_FREEZED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
128
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread ist eingefroren
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_WAIT_HYPAGED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
256
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread wartet auf den HyPageD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_PROC_DEFUNC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
512
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Dachprozess wurde mit 
\emph on
destroy_subject
\emph default
 beendet.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRSTAT_TRACE_ONLY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Sofern eine Überwachung der Software-Interrupts aktiviert ist, wird die
 Ausführung dieser nicht vom Überwacher unterbunden.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
THRSTAT_OTHER_FREEZE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Thread wurde wegen THRSTAT_IRQ, THRSTAT_SYNC, THRSTAT_RECV_SOFTINT,
 THRSTAT_WAIT_HYPAGED oder THRSTAT_PROC_DEFUNC eingefroren.
 Dieses Makro ist kein Flag im eigentliches Sinne, sondern fast die o.g.
 Flags zusammen.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Nummer des IRQs, falls der Thread auf IRQs wartet 
\family typewriter
0xFFFFFFFF
\family default
 wenn nicht
\end_layout

\begin_layout Itemize
Zähler, der festlegt, wie oft eine 
\emph on
freeze_subject
\emph default
-Operation auf den Thread ausgeführt wurde
\end_layout

\begin_layout Itemize
Zeiger auf vorheriges Element der Run-Queue des Scheduler, falls der Thread
 rechenbereit und Teil der Runqueue ist
\end_layout

\begin_layout Itemize
Zeiger auf nächstes Element der Run-Queue des Schedulers, falls der Thread
 rechenbereit und Teil der Runqueue ist
\end_layout

\begin_layout Itemize
SID des Threads, der Softwareinterrupts dieses Threads abgreift
\end_layout

\begin_layout Itemize
Effektive Priorität des Threads
\end_layout

\begin_layout Itemize
Statische Priorität des Threads
\end_layout

\begin_layout Itemize
Scheduling-Klasse des Threads
\end_layout

\begin_layout Itemize
Zeitpunkt an dem eine Timeout-Behaftete Operation (z.B.
 
\emph on
sync
\emph default
 oder 
\emph on
recv_softints
\emph default
) abgebrochen werden soll (64-bit Wert, der zwei Deskriptoreinträge verbraucht)
\end_layout

\begin_layout Itemize
Plattformunabhängige Nummer der letzten Exception (kann auch Page Fault
 sein)
\end_layout

\begin_layout Itemize
Nummer der letzten Exception (Wert plattformspezifisch)
\end_layout

\begin_layout Itemize
Ausführungsadresse bei letzter Exception (Wert plattformspezifisch)
\end_layout

\begin_layout Itemize
Fehlercode der letzten Exception
\end_layout

\begin_layout Itemize
Seitendeskriptor der Seite an der der letzte Pagefault auftrat (Wert plattformsp
ezifisch)
\end_layout

\begin_layout Itemize
Zeiger auf den vorherigen Thread in der Liste der Threads des Prozesses
\end_layout

\begin_layout Itemize
Zeiger auf den nächsten Thread in der Liste der Threads des Prozesses
\end_layout

\begin_layout Itemize
Letzter ausgeführter Software-Interrupt (falls Umleitung durch 
\emph on
recv_softints
\emph default
)
\end_layout

\begin_layout Itemize
Nummer des Threads, von dem der aktuelle Thread Software-Interrupts abgreift
\end_layout

\begin_layout Itemize
Eindeutige Thread-ID
\end_layout

\begin_layout Subsubsection
Implementierungsspezifische Statusinformationen
\end_layout

\begin_layout Itemize
Zeiger auf vorherigen Eintrag einer Sync-Warteschlange, in der der Thread
 Mitglied ist
\end_layout

\begin_layout Itemize
Zeiger auf nächsten Eintrag einer Sync-Warteschlange, in der der Thread
 Mitglied ist
\end_layout

\begin_layout Itemize
Zeiger auf erstes Element der eigenen Sync-Warteschlange
\end_layout

\begin_layout Itemize
Zeiger auf vorherigen Eintrag in der Timeout-Warteschlange, sofern der Thread
 ein Timeout gesetzt hat
\end_layout

\begin_layout Itemize
Zeiger auf nächsten Eintrag in der Timeout-Warteschlange, sofern der Thread
 ein Timeout gesetzt hat
\end_layout

\begin_layout Subsubsection
Plattformspezifische Statusinformationen
\end_layout

\begin_layout Itemize
Zu letzt verwendeter Wert des Stack-Pointers des Kernel-Stacks (eine Adresse
 relativ zum Begin des Kernel-Adressraums).
 Diese Information ist im 100.
 Doppelwort des Deskriptors abgespeichert.
\end_layout

\begin_layout Itemize
Die phyiskalische Adresse der Speicherseite des Thread Local Storage (101.
 Doppelwort)
\end_layout

\begin_layout Itemize
Die letzten 1024 Byte des Deskriptors sind für den FPU-Stack reserviert
\end_layout

\begin_layout Subsubsection
Der 
\emph on
thread local storage
\end_layout

\begin_layout Standard
Der 
\emph on
thread local storage
\emph default
 ist eine normale Speicherseite von 4096 Byte größe.
 Sie ist ebenfalls im Benutzeradressraum im Schreib-Lese-Modus eingeblendet.
 Die Inhalte werden vom jeweiligen Thread bzw.
 dessen API-Bibliothek bestimmt.
\end_layout

\begin_layout Part
Implementierung auf der x86-Architektur
\end_layout

\begin_layout Chapter
Grundaspekte der Implementierung
\end_layout

\begin_layout Section
Verwendete Schutzkonzepte
\end_layout

\begin_layout Standard
Die x86-Implementierung des 
\emph on
hymk
\emph default
 arbeitet vollständig im sog.
 
\begin_inset Quotes gld
\end_inset

Protected Mode
\begin_inset Quotes grd
\end_inset

 der x86-Architektur.
 In diesem Modus bietet die CPU eine Reihe von Schutzmechanismen, einen
 Paging-Mechanismus, sowie den Zugriff auf den vollen 32-bit Adressraum
 an.
 Da die CPU normalerweise in einem Kompatibilitätsmodus für die 8086-Architektur
 startet (der sog.
 
\begin_inset Quotes gld
\end_inset

Real Mode
\begin_inset Quotes grd
\end_inset

), muss beim Start des Systems der Modus gewechselt werden, was wiederum
 Aufgabe des verwendeten Bootloaders ist.
 Der Kernel übernimmt nach dem Start des Systems die volle Kontrolle über
 die verschiedenen, von der CPU im Protected Mode verwendeten Verwaltungstabelle
n (GDT, IDT etc.).
\end_layout

\begin_layout Standard
Die Details der x86-Architektur können in diesem Dokument nicht näher erwähnt
 werden.
 Nähere Informationen zur x86-Architektur können u.a.
 aus den Architektur-Handbüchern der Firma Intel entnommen werden.
 In diesem Kapitel wird tabelarisch erläutert, wie die verschiedenen Schutzmecha
nismen auf der x86-Architektur umgesetzt wurden.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features islongtable="true">
<column alignment="left" valignment="top" leftline="true" width="6cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="8cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Schutzmechanismus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Implementierung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Trennung der virtuellen Adressräume
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Wechsel der Page-Directories bei einem Kontext-Wechsel durch Änderung des
 CR3-Registers im Kernel-Modus (das CR3-Register kann NUR im Kernel-Modus
 geändert werden).
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Trennung von Kernel- und Benutzer-Modus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Über das 
\emph on
current privilege level
\emph default
 (CPL) der CPU, das die Ausführung bestimmter Instruktionen (etc.) einschränken
 kann.
 Der Kernel-Modus verwendet 
\begin_inset Quotes gld
\end_inset

Ring 0
\begin_inset Quotes grd
\end_inset

 - der Benutzermodus 
\begin_inset Quotes gld
\end_inset

Ring 3
\begin_inset Quotes grd
\end_inset

 (in letzterem sind Kernel-Speicherseiten und bestimmte Instruktionen der
 CPU gesperrt).
 Ein Wechsel in den Kernel-Modus findet immer bei IRQs und Exceptions statt.
 Die eigtl.
 IRQ-Behandlung durch den jeweiligen Gerätetreiber wird aber dann wieder
 im Benutzermodus, also Ring 3 durchgeführt.
\end_layout

\begin_layout Standard
Ansonsten ist ein Wechsel nur durch einen Systemaufruf möglich.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Schutz der Systemaufrufe
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Systemaufrufe werden über Softwareinterrupts realisiert.
 Die dafür zuständige Tabelle, die sog.
 IDT, kann nur vom Kernel verändert werden, so dass dieser festlegen kann,
 welcher Softwareinterrupt zulässig ist und zu welchem Systemaufruf ein
 Aufruf von diesem führt.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Schutz des Kernel-Adressraums
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Kernel-Adressraum in einem virtuellen Adressraum ist durch setzen des
 
\begin_inset Quotes gld
\end_inset

Supervisor
\begin_inset Quotes grd
\end_inset

-Flags in den jeweiligen Pagetable/Pagedirectory-Einträgen möglich.
 
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Schutz der Info-Pages
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die Info-Pages sind im Benutzermodus nur lesbar, da das Schreibzugriffsflag
 der jeweiligen Seiten deaktiviet ist.
 Im Kernel-Modus sind sie lesbar und beschreibbar.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Schutz der I/O-Ports
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die I/O-Ports werden über das 
\emph on
I/O privilege level
\emph default
 (IOPL) der CPU geregelt.
 Wird ein Thread ausgeführt, der auf die Ports zugreifen darf, so wird dessen
 IOPL so gesetzt, dass er Zugriff auf die Ports erhält.
 Die I/O-Permission-Bitmap, die zur Sperrung einzelner Ports gedacht ist,
 wird nicht verwendet.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Aufdeckung von Null-Pointern
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Null-Pointerzugriffe werden durch Sperrung der ersten und letzten Speicherseite
 der Programme leichter aufgedeckt.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Schutz der regulären Pageframes und des Kernels
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Adressraum des Kernels, sowie die regulären, zur Speicherung gedachten
 Seitenrahmen sind vom 
\emph on
io_alloc
\emph default
-Mechanismus ausgesperrt.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Bootvorgang
\end_layout

\begin_layout Standard
Der 
\emph on
hymk
\emph default
 wird auf der x86-Plattform durch den Bootloader GRUB gestartet.
 Da dieser bereits Fähigkeiten zum Wechsel in den Protected Mode besitzt,
 enthält der 
\emph on
hymk
\emph default
 selbst keinen Code mehr um eigenständig in den Protected Mode zu gelangen.
 Der GRUB-Bootloader lädt den Kernel in einen Speicherbereich oberhalb des
 ersten MiBs des Arbeitsspeichers.
 Außerdem lädt GRUB weitere essentielle Systemserver im Anschluß daran (siehe
 GRUB Multiboot-Spezifikationen).
 Darunter ist auch das Image des Init-Prozesses.
 Anschließend startet er den Kernel durch einen Sprung an die erste Ausführungsa
dresse.
 Im Kernel-Code liegt an dieser Adresse der Einsprungspunkt 
\emph on
start
\emph default
 (siehe 
\emph on
start.s
\emph default
).
 Das Programm an dieser reinitialisiert die GDT und IDT, wählt die Selektoren
 für die Kernel-Speichersegmente, setzt einen initialen Kernel-Stack und
 wechselt dann in die Routine 
\emph on
main
\emph default
 (siehe 
\emph on
init.c
\emph default
).
 Die Routine 
\emph on
main
\emph default
 kümmert sich um die weitere Initialisierung des Systems.
 Die genauen Details dieser Initialisierung können der Dokumentation innerhalb
 des Quellcodes und den Dokumentationen der jeweiligen Systemteile (Speicherverw
altung etc.) entnommen werden.
\end_layout

\begin_layout Standard
Nachdem der Kernel sich initialisiert hat, lädt er das Image von Init in
 einen neuen Prozess und startet diesen anschließend.
 Init hat dann die Aufgabe weitere Systemdienste zu laden.
\end_layout

\begin_layout Section
Verwendete Code-Konventionen
\end_layout

\begin_layout Standard
Vor dem weiteren Einstieg in die verwendeten Verfahren sollten noch einige
 Konventionen innerhalb des Kernel-Quellcodes erwähnt werden.
 
\end_layout

\begin_layout Subsection
Standard-Konformität
\end_layout

\begin_layout Standard
Der Kernel-Quellcode ist nicht auf ISO-Konformität hin entwickelt worden,
 sondern hin zu den Erweiterungen des ISO-C99-Standards durch den GNU-C-Compiler
 (gcc/gnu99).
 Es werden u.a.
 Inline-Assembler und die vom gcc angebotenen Funktionsartigen Makros benutzt.
 Daher dürfte es nur schwer möglich sein den Kernel mit einem anderen Compiler,
 als dem gcc zu kompilieren.
\end_layout

\begin_layout Standard
Der im Kernel-Code verwendete Assemblercode wurde für den GAS-Assemblierer
 ausgerichtet.
 Er baut nicht auf der Intel-Notation, sondern auf der AT&T-Notation auf.
 Die zu berücksichtigenden Unterschiede der Notationen können der GAS-Dokumentat
ion entnommen werden.
\end_layout

\begin_layout Subsection
Besondere Datentypen
\end_layout

\begin_layout Standard
Alle mehrbytingen Integer-Zahlen sind grundsätzlich im für Intel üblichen
 little Endian (
\begin_inset Quotes gld
\end_inset

lowest Byte first
\begin_inset Quotes grd
\end_inset

) Format gespeichert.
 Alle String-Ausgaben innerhalb des Kernels erfolgen im von IBM erweiterten
 ASCII-Zeichensatz der IBM-PC-Plattform.
\end_layout

\begin_layout Standard
Um eine spätere Portierung des Kernels zu erleichtern, verwendet der Kernel
 speziell benannte Datentypen, die immer bestimmten Anforderungen genügen
 müssen, um den Kernel korrekt zum Laufen zu bringen.
 Diese Datentypen sind:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
int8_t 8-bit Ganzzahl mit Vorzeichen (
\begin_inset Quotes gld
\end_inset

signed integer
\begin_inset Quotes grd
\end_inset

)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
int16_t 16-bit Ganzzahl mit Vorzeichen (
\begin_inset Quotes gld
\end_inset

signed integer
\begin_inset Quotes grd
\end_inset

)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
int32_t 32-bit Ganzzahl mit Vorzeichen (
\begin_inset Quotes gld
\end_inset

signed integer
\begin_inset Quotes grd
\end_inset

)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
uint8_t 8-bit Ganzzahl ohne Vorzeichen (
\begin_inset Quotes gld
\end_inset

unsigned integer
\begin_inset Quotes grd
\end_inset

)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
uint16_t 16-bit Ganzzahl ohne Vorzeichen (
\begin_inset Quotes gld
\end_inset

unsigned integer
\begin_inset Quotes grd
\end_inset

)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
uint32_t 32-bit Ganzzahl ohne Vorzeichen (
\begin_inset Quotes gld
\end_inset

unsigned integer
\begin_inset Quotes grd
\end_inset

)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
intptr_t Vorzeichenbehafte Ganzzahl, die durch (void*) in einen Zeiger konvertie
rt werden darf
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
uintptr_t Vorzeichenlose Ganzzahl, die durch (void*) in einen Zeiger konvertiert
 werden darf
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
size_t Anzahl der Bytes eines Objekt als vorzeichenlose Ganzzahl
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
bool_t Ganzzahl, deren Aussage mit dem Wert TRUE wahr und dem Wert FALSE
 (=0) falsch ist.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
bool Identisch zu bool_t
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
sid_t SID eines Subjekts (32-bit Länge, Verwendung als vorzeichenlose Ganzzahl
 zulässig)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
irq_t Nummer eines Interrupts (32-bit Länge, Verwendung als vorzeichenlose
 Ganzzahl zulässig)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
errno_t Fehlernummer (32-bit Länge, Verwendung als vorzeichenlose Ganzzahl
 zulässig)
\end_layout

\begin_layout Subsection
Häufige Idiome
\end_layout

\begin_layout Subsubsection
Umwandlung von Integer in Adresse
\end_layout

\begin_layout Standard
Um einen Integer in eine Adresse in der gcc-basierten x86-Implementierung
 korrekt umzuwandeln, ist das Idiom 
\end_layout

\begin_layout Standard
Zeiger = (void*)(uintptr_t)Integer
\end_layout

\begin_layout Standard
zu verwenden.
\end_layout

\begin_layout Subsubsection
Thread und Prozesstabelleneinträge
\end_layout

\begin_layout Standard
Die Thread und die Prozesstabelle sind als Vektoren des Typs uint32_t* umgesetzt
 worden.
 Um die Adresse eines Threaddeskriptors leichter zu ermitteln, wurden die
 Makros
\end_layout

\begin_layout Standard
THREAD(
\emph on
SID des Threads
\emph default
, 
\emph on
Nr.
 des Auszuwählenden Eintrags des Deskriptors
\emph default
)
\end_layout

\begin_layout Standard
PROCESS(
\emph on
SID des Threads
\emph default
, 
\emph on
Nr.
 des Auszuwählenden Eintrags des Deskriptors
\emph default
)
\end_layout

\begin_layout Standard
eingeführt.
 Mit diesen Makros kann mit Hilfe der SID eines Threads und der Nummer des
 Eintrags innerhalb des Deskriptors (die verschiedenen Eintragsnummern sind
 über die THRTAB und PRCTAB Makros erhältlich) auf einen Thread-Deskriptor
 zugegriffen werden.
\end_layout

\begin_layout Standard
Gelegentlich wird aus Gründen der besseren Lesbarkeit oder aus programmiertechni
schen Gründen statt dieser Makros direkt auf einen Deskriptor über einen
 Zeiger zugegriffen.
 Diese Zeiger werden wie folgt Initialisiert:
\end_layout

\begin_layout Standard
Thread_Zeiger = THREAD(
\emph on
SID des Threads
\emph default
, 0);
\end_layout

\begin_layout Standard
Prozess_Zeiger = PROCESS(
\emph on
SID des Threads
\emph default
, 0);
\end_layout

\begin_layout Standard
Innerhalb dieser Deskriptoren wird dann auf die Daten wie folgt zugegriffen:
\end_layout

\begin_layout Standard
Thread_Zeiger[
\emph on
Nr.
 des Auszuwählenden Eintrags des Deskriptors
\emph default
]
\end_layout

\begin_layout Standard
Prozess_Zeiger[
\emph on
Nr.
 des Auszuwählenden Eintrags des Deskriptors
\emph default
]
\end_layout

\begin_layout Standard
Eine besondere Rolle spielen die Zeiger 
\emph on
current_t
\emph default
 und 
\emph on
current_p
\emph default
 die jeweils auf den Deskriptor des aktuellen Threads bzw.
 Prozesses zeigen.
\end_layout

\begin_layout Subsection
Fehlerbehandlung innerhalb des Quelltextes
\end_layout

\begin_layout Standard
Innerhalb des Kernels können während der Arbeit Fehler auftreten.
 Wird ein Fehler nicht durch einen falschen Parameter eines Systemaufrufs
 direkt oder indirekt hervorgerufen, so ist der Kernel mit einer Fehlerbotschaft
 anzuhalten.
\end_layout

\begin_layout Standard
Tritt ein Fehler auf Grund eines falschen Parameters eines Systemaufrufs
 auf, so ist dessen Fehlernummer durch das Makro 
\emph on
SET_ERROR(<Fehlernummer>)
\emph default
 zu setzen.
 Dieses Makro ändern die Variable 
\emph on
sysc_error
\emph default
.
 Der Inhalt dieser Variable wird bei der Rückkehr aus dem Systemaufruf durch
 den Kernel an den aufrufenden Therad übermittelt.
\end_layout

\begin_layout Subsection
Inlines, Makros und Inline-Assembler
\end_layout

\begin_layout Standard
Im Kernel werden sowohl Inline-Funktionen, wie auch Makros, wie auch Inline-Asse
mbler verwendet.
 Grundsätzlich sollten komplizierte Makro-Verschachtelungen vermieden werden,
 um den Quelltext leserlich zu halten.
 Die Mischung mit dem Inline-Assembler sollte nur dann stattfinden, wenn
 dies aus Performance-Gründen oder aus Gründen der Leserlichkeit sinnvoll
 ist.
\end_layout

\begin_layout Subsection
Benennung von Symbolen
\end_layout

\begin_layout Standard
Alle globalen Symbole innerhalb des Kernels sind mit einem Sinngebenden
 Prefix zu versehen.
 Derzeit sind folgende Prefices vorgesehen:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
i386_ In Assembler implementierte Low-Level-Funktion
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
sysc_ Implementierung eines Systemaufrufs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
kmem_ Symbol das zur Speicherverwaltung gehört
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
kio_ Symbol das zur I/O-Leitung gehört
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ksubj_ Symbol das zur Subjekt-Verwaltung (Prozesse/Threads) gehört
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ksched_ Symbol das zum Scheduler gehört
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
kinfo_ Symbol das zur Systeminformation- oder zur Deskriptorverwaltung gehört
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ksync_ Symbol das zum 
\emph on
sync
\emph default
-Mechanismus gehötr
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
kremote_ Symbol das zur Threadfernsteuerung gehört
\end_layout

\begin_layout Standard
Eine Ausnahme gilt für globale Variablen, die ohne Prefix deklariert werden
 können.
\end_layout

\begin_layout Standard
Makros haben als Prefix meistens ein Prefix, dass sie zu ihrem Einsatzbereich
 zuordnet, so ist THRTAB_ z.B.
 eine Zuordnung zur Thread-Tabelle oder THRSTAT eine Zuordnung zu den Thread-Sta
tusflags.
 Ausnahme bilden Makros, die zur Vereinfachung von Berechnungen dienen -
 diese Tragen Prefices ihres Einsatzbereiches (abgesehen von den Makros
 PROCESS und THREAD).
\end_layout

\begin_layout Subsection
Kommentierung des Quelltextes
\end_layout

\begin_layout Standard
In der HydrixOS-Entwicklermailingliste (
\emph on
hydrixos-internal@hydrixos.org
\emph default
) wurde beschlossen, dass der Quelltext des Systems durchgehend in englischer
 Sprache kommentiert wird.
 In den Quelltext-Kommentar sind Beschreibungen über den Zweck größerer
 Arbeitsabschnitte einer Funktion aufzunehmen, sofern diese nicht trivial
 sind.
\end_layout

\begin_layout Standard
Ferner ist jede Funktionsdefinition mit einem darüberstehenden Kommentar
 zu versehen, der folgenden Aufbau haben muss:
\newline

\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "100col%"
special "none"
height "1pt"
height_special "totalheight"
status open

\begin_layout Standard

\family typewriter
/*
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
* <
\emph on
Funktionsname
\emph default
>(<
\emph on
Parameterliste
\emph default
>)
\end_layout

\begin_layout Standard
\InsetSpace ~
*
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
* <
\emph on
Funktionsbeschreibung, die auf Parameterliste Bezug nimmt
\emph default
>
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
*
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
* 
\emph on
<Beschreibung der möglichen Rückgabewerte
\emph default
>
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
*
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
* <
\emph on
Hinweise zur Implementierung>
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
*
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
*/
\end_layout

\end_inset


\newline

\end_layout

\begin_layout Standard
Die Parameterliste ist zur besseren Lesbarkeit ohne Datentypen auszuführen,
 zumal diese unterhalb des Kommentars ohnehin in der Funktionsdeklaration
 stehen.
 Nur bei Systemaufrufen sollte die Parameterliste seperat erklärt werden.
 Ansonsten reicht es aus, wenn die Funktionsbeschreibung auf die Parameter
 eingeht.
 Wenn zu viele Parameter vorkommen, sollte sie die in der Parameterliste
 verwendeten Namen eindeutig aufgreifen und diese in 'einfachen Anführungszeiche
n' enthalten.
\end_layout

\begin_layout Standard
Der Quelltext soll keine Beschreibung abstrakter und übergeordneter Vorgänge
 enthalten (z.B.
 wie ein Thread gewechselt wird), sondern nur lokal den jeweiligen Vorgang
 des folgenden Codeabschnitts beschreiben.
 Übergeordnete Beschreibungen sind in diesem Dokument extern dokumentiert.
\end_layout

\begin_layout Standard
Eine gute Dokumentation ist die Grundlage der Verstehbarkeit des Projektes.
 Freie Software soll es dem Benutzer ermöglichen in die Arbeit anderer Programmi
erer einsicht zu erhalten.
 Als praktisches Resultat soll er dabei selbst Fehler entdecken können.
 Dies und die allgemeine Weiterverwendung des Quelltextes ist nur mit einer
 guten Dokumentation möglich, die auch gemäß den Richtlinien durchgeführt
 wird.
 Wir bitten daher jeden Mitprogrammierer und besonders jeden späteren Maintainer
 eines HydrixOS-Projektes sich daran zu halten!
\end_layout

\begin_layout Subsection
Die Quelltextmodule und Header-Dateien
\end_layout

\begin_layout Standard
Der Quelltext ist in verschiedene Module und Header-Dateien getrennt.
 Derzeit liegt der gesamte Quelltext in 'src/hymk/x86'.
 Bei späteren Portierung kann es sinnvoll sein, den portablen Quelltext
 in ein getrenntes Verzeichnis unterzubringen.
 Die internen Header des 
\emph on
hymk
\emph default
 liegen im Verzeichnis 'src/hymk/include'.
 Sie sollten nicht mit den restlichen Headern des HydrixOS-Projektes vermischt
 werden, da sie nur intern im Quelltext des 
\emph on
hymk
\emph default
 Sinn ergeben.
 Der hymk verwendet ferner einige globale Header des HydrixOS-Projektes.
\end_layout

\begin_layout Standard
Zur Übersicht der vorhandenen Dateien:
\newline

\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\series bold
src/hymk/ Hauptverzeichnis des hymk-Quelltextes
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
Makefile Makefile des hymk
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
kmap Symbol-Map, die beim Linken des hymks entsteht
\newline

\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\series bold
include/ Include-Dateien des hymk
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\series bold
x86/ Include-Dateien der x86-Implementierung
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
current.h Header für Daten und Funktion hinsichtlich des aktuellen Betriebszustan
ds
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
error.h Header zur Fehlerbehandlung innerhalb von Systemaufrufen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
info.h Header zur Systeminformation und Deskriptorverwaltung
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
kcon.h Header für interne Debug-Konsole
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
mem.h Header für Speicherverwaltungsoperationen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
page.h Header für Seitenbezogene Speicherverwaltungsoperationen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
sched.h Header für Scheduling- und Kontextwechseloperationen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
setup.h Feineinstellungen des Kernels
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
stdarg.h Abgewandelter ISO-C Header 
\emph on
stdarg.h
\emph default
 (Debug-Konsole)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
stdio.h Abgewandelter ISO-C Header 
\emph on
stdio.h
\emph default
 (Debug-Konsole)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
string.h Abgewandelter ISO-C Header 
\emph on
string.h
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
sysc.h Header für die Implementierung der Systemaufrufe
\end_layout

\end_deeper
\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\series bold
x86/ Quelltext-Dateien des hymk
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
alloc.c Funktionen zur Allokation von Seitenrahmen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
current.c Funktionen für die Änderung des aktuellen Arbeitszustandes (insb.
 Thread- und Prozesswechsel)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
frame.c Funktionen zur Verwaltung von Kernel-Stacks
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
info.c Funktionen zur Deskriptor-Verwaltung und Verwaltung der Info-Pages
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
init.c Initialisierung des Systemkerns
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
intr.c Initialisierung des PICs; Lowlevel-Behandlung aller Software- und
 Hardwareinterrupts
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
io.c I/O-Systemaufrufe und Übergang zur Usermode-IRQ-Behandlung
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
irq.s Lowlevel-Behandlung von IRQs und Exceptions; Rückkehr aus Kernel-Mode;
 Lowlevel-Implementierung des Thread-Wechsels
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
kprintf.c Kernel-Debugkonsole
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
map.c Implementierung der Shared-Memory-Systemaufrufe
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
meminit.c Initialisierung der Kernel-Speicherverwaltungstabellen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
modules.c Verwaltung der von GRUB geladenen Zusatzmodule; Verwaltung der
 GRUB-Startdaten
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
page.c Verwaltung von Seitenrahmen und virtuellen Adressräumen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
paged.c Kommunikation mit dem Paging-Dämon
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
remote.c Systemaufrufe für Thread-Fernsteuerung und interne Operationen zur
 Softint-Umleitung (für 
\emph on
recv_softints
\emph default
)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
schedule.c Verwaltung der Run-Queue und Scheduler-bezogene Systemaufrufe
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
security.c Systemaufruf zum Wechsel in den Root-Modus
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
start.s Startup-Code des Kernels (wird von GRUB nach Ladens des Kernels aufgerufe
n)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
string.c Abgewandelte ISO-C String-Funktionen
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
subject.c Systemaufrufe zur Verwaltung von Subjekten (Threads und Prozesse)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
sync.c 
\emph on
sync
\emph default
-Mechanismus des Kernels und 
\emph on
sync
\emph default
-Systemaufruf
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
sysc.s Lowlevel-Eintrittscode für die Systemaufrufe
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
timeout.c Hilfsfunktionen für die Umsetzung zeitbasierter Timeouts (u.a.
 für 
\emph on
sync
\emph default
 und 
\emph on
recv_softints
\emph default
)
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
tss.c Initialisierung des Task-Status-Segments des Kernels
\newline

\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Der Kernel verwendet zusätzlich folgende Standard-Header des HydrixOS-Projektes
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\series bold
src/include/hymk Projektglobale Header zum hymk
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
sysinfo.h Makros für die Thread- und Prozesstabelleneinträge
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
x86-io.h x86-IO-Instruktionen als Makros
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\series bold
src/include/hydrixos HydrixOS-Header
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000
errno.h Makros für Fehlernummern
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
sid.h Makros für SID-Datentyp
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
types.h Standard-Datentypen innerhalb des HydrixOS-Projektes
\end_layout

\end_deeper
\begin_layout Subsection
Kernel-Debugging
\end_layout

\begin_layout Subsubsection
Bildschirmausgabe über kprintf
\end_layout

\begin_layout Standard
Um den Kernel-Quellcode debuggen zu können, gibt es eine interne Funktion
 
\emph on
kprintf
\emph default
, die auf den Textbildschirm der IBM-PC-Architektur Zeichen ausgibt.
 Diese Zeichen sind weiß hervorgehoben und haben am Zeilenanfang ein rotes
 
\begin_inset Quotes gld
\end_inset

>
\begin_inset Quotes grd
\end_inset

-Zeichen, um sie leichter dem Kernel zuordnen zu können.
 Die Kernel-Debugkonsole sollte ausschließlich zum Debuggen des Kernels
 verwendet werden.
\end_layout

\begin_layout Subsubsection
Debug-Modus
\end_layout

\begin_layout Standard
Der Kernel kann im Debug-Modus kompiliert werden - dort führen bestimmte
 Fehlerbehandlungen zum Stopp des Systems und werden verschiedene Ausgaben
 über die Debug-Konsole gemacht.
 Dieser Modus wird aktiviert, indem das Makro 
\emph on
DEBUG_MODE
\emph default
 in der Datei setup.h gesetzt wird.
 Alle Ausgaben, die im Debug-Modus des Kernels erscheinen sollen, sollten
 wie folgt implementiert werden:
\end_layout

\begin_layout Standard

\family typewriter
#ifdef DEBUG_MODE
\end_layout

\begin_layout Standard

\family typewriter
kprintf(
\emph on
AUSGABE
\emph default
);
\end_layout

\begin_layout Standard

\family typewriter
#endif
\end_layout

\begin_layout Standard
Soll bestimmter Code bei in besonders extensiven Debugging ausgeführt werden,
 so ist das Makro 
\emph on
STRONG_DEBUG_MODE
\emph default
 zu verwenden.
 Ist dieses Flag gesetzt, so führen z.B.
 Exceptions im Benutzermodus zum sofortigen Stillstand des Systems.
\end_layout

\begin_layout Subsubsection
Boot-Modus
\end_layout

\begin_layout Standard
Der Boot-Zustand des Systems kann über die Variable 
\emph on
kdebug_no_boot_mode
\emph default
 (
\emph on
init.c, kcon.h
\emph default
) festgestellt werden.
 Ist sie wahr (1), so hat der Kernel den Boot-Modus verlassen und das erste
 Programm gestartet.
 Ist sie falsch, so befindet sich der Kernel noch in der Initialisierung.
 Mit Hilfe dieser Variable können u.U.
 bestimmte Ausgaben während des Ladens des Kernels zu Debugging-Zwecken
 dargestellt werden, die später im Betrieb des Systems unterdrückt werden
 sollen.
\end_layout

\begin_layout Section
Kompiler-Parameter
\end_layout

\begin_layout Standard
Der Quelltext von HydrixOS erlaubt verschiedene Feineinstellungen, die über
 Makros in der Datei 
\emph on
setup.h
\emph default
 geregelt werden können.
 Diese sind derzeit:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="3">
<features islongtable="true" headBottomDL="true">
<column alignment="block" valignment="top" leftline="true" width="6cm">
<column alignment="block" valignment="top" leftline="true" width="3.2cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="4.8cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Makro-Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Standard-Wert
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Bedeutung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DEBUG_MODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(inaktiv)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Kernel soll in den Debug-Modus kompiliert werden.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
STRONG_DEBUG_MODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(inaktiv)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Kernel soll im besonderen Debug-Modus kompiliert werden.
 Exceptions im Benutzerodus führen dabei zum Stillstand des Systems!
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
HYMK_VERSION_MAJOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Major-Version des Kernels
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
HYMK_VERSION_MINOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Minor-Version des Kernels
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
HYMK_VERSION_REVISION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Revisionsnummer des Kernels
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
HYMK_VERSION_CPUID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x80586
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Wert des Erkennungs-Code für die Hauptinfopage, den der Kernel für die akteulle
 Plattform verwenden soll
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
KERNEL_STACK_PAGES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Anzahl der Speicherseiten die ein Kernel-Stacks benötigt
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
KERNEL_STACK_SIZE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8192
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Größe eines Kernel-Stacks in Byte
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ENABLE_PGE_EXTENSION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(aktiv)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Gibt an, ob die Paging-Global-Extension aktiv sein soll oder nicht (dies
 ist für alle neueren x86-CPUs zu empfehlen)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SCHED_PRIORITY_MAX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Maximale statische Priorität des Schedulers (muss größer als die Minimale
 sein)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SCHED_PRIORITY_MIN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Minimale statische Priorität des Schedulers (muss kleiner als die Maximale
 sein)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SCHED_CLASS_MAX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Maximale Scheduling-Klassennummer
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SCHED_CLASS_MIN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Minimale Scheduling-Klassennummer
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
TIMER_FREQUENCY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
100000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Timer-Frequenz in Hz
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
IRQ_THREAD_PRIORITY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Priorität, die ein Thread haben soll, wenn er in den IRQ-Behandlungsmodus
 wechselt
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Chapter
Speicherverwaltung
\end_layout

\begin_layout Section
Aufbau des physikalischen Adressraums
\end_layout

\begin_layout Subsection
Problematik Normal und High Zone
\end_layout

\begin_layout Standard
Da aus Platzgründen nur die unteren 896 MiB des physischen RAMs in den virtuelle
n Adressraums des Kernels einblendet werden können (siehe Übersicht in Kapitel
 
\begin_inset LatexCommand \ref{sec:Aufb-virt-Addr}

\end_inset

), kann er für alle internen Operationen auf Speicherseiten jenseits der
 896 MiB-Grenze nicht zugreifen.
 Aus diesem Grund müssen alle Speicherseiten, die der Kern für eigene Aufgaben
 verwendet unter dieser Adressgrenze liegen.
 Für Benutzerprogramme ist diese Grenze unwichtig, da deren Adressraum aus
 beliebigen Speicherseiten zusammengemappt werden kann.
\end_layout

\begin_layout Standard
Der Speicher wird daher grundsätzlich in eine Normal und eine High-Zone
 eingeteilt.
 Die Normal-Zone umfasst alle frei zur Verfügung stehenden Seietnrahmen
 unterhalb der physischen Adresse von 896 MiB, während die High-Zone alle
 Seitenrahmen jenseits dieser Adressen umfasst.
 Der Zugriff auf Seitenrahmen der High-Zone erfordert, dass der Kernel diese
 Seitenrahmen in seinen Teil des virtuellen Adressraums hinein abbildet.
\end_layout

\begin_layout Subsection
Grundsätzliche Gliederung des physischen Speichers
\end_layout

\begin_layout Standard
Grundsätzlich gliedert sich der physikalische Adressraum in der x86-Implementier
ung in drei Bereiche:
\end_layout

\begin_layout Itemize

\emph on
Den untere
\emph default
 
\emph on
Bereich
\emph default
, der Kernel-Code und Daten enthält, sowie x86-Spezifische Hardware-Speicherbere
iche und die Images der verschiedenen Boot-Server des HydrixOS-Betriebssystems.
 Der untere Teil beginnt am Anfang des physikalischen Adressraums.
\end_layout

\begin_layout Itemize

\emph on
Den mittlere
\emph default
 
\emph on
Bereich
\emph default
, der die Seitenrahmen (und erforderlichen Verwaltungstabellen) enthält,
 die von 
\emph on
alloc_pages
\emph default
 verwendet werden.
 Wobei der Kernel direkt nur die ersten 894 MiB des Bereichs verwenden kann,
 was bei internen Allokationen des Kernels beachtet werden muss ( im wesentliche
n sind davon Page-Tables und Page-Directories betroffen).
\end_layout

\begin_layout Itemize

\emph on
Den oberen Bereich
\emph default
, der weitere Hardware-Speicherbereiche enthalten kann und vollständig für
 io_alloc freigegeben ist.
 Dieser Bereich fängt direkt nach dem 
\emph on
mittleren Bereich
\emph default
 an und endet an der oberen Grenze des physikalischen Adressraums (4 GiB).
\end_layout

\begin_layout Subsection
Gliederung des unteren Bereichs
\end_layout

\begin_layout Standard
Der untere Bereich des physikalischen Adressraum hat eine statische Größe
 von 2 MiB und ist folgende Unterbereiche gegliedert:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="6cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="8cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Adressbereich
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Bedeutung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0x00000000 - 0x0000FFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
BIOS-Daten (freigegeben für io_alloc)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0x00010000 - 0x000B7FFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Itemize
Initialer Kernel-Stack bei 
\family typewriter
0x00090000
\family default
 (verfällt nach Initialisierung des Kernels; sollte nicht unter 
\family typewriter
0x00080000
\family default
 fallen)
\end_layout

\begin_layout Itemize
Nach Initialisierung des Systems kann dieser Bereich mittels io_alloc()
 verwendet werden
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0x000B8000 - 0x000FFFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EGA / VGA-Speicher; BIOS-ROM (freigegeben für io_alloc)
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\size small
0x00100000 - 0x001FFFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Itemize
Image des Kernels
\end_layout

\begin_layout Itemize
Image des Init-Servers
\end_layout

\begin_layout Itemize
Images weiterer Server
\end_layout

\begin_layout Standard
(freigegeben für io_alloc)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Gliederung des mittleren Bereichs
\end_layout

\begin_layout Standard
Der mittlere Bereichs des physikalischen Adressraums besitzt hingegen keine
 statische Größe und ist abhängig von der allgemeinen Größe des eingebauten
 RAMs (die Größe wird beim Start des Systems durch GRUB ermittelt).
 Er gliedert sich in folgende Bereiche (die Variable 
\emph on
R
\emph default
 ist die Größe des kompletten verfügbaren RAMs, 
\emph on
N
\emph default
 die Größe der kompletten Normal Zone, 
\emph on
H
\emph default
 die Größe der kompletten High Zone - jeweils in Byte):
\begin_inset LatexCommand \label{sec:IKP}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="3cm">
<column alignment="block" valignment="top" leftline="true" width="3cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="8cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Größe
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Bedeutung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Initial Kernel Page Tables (IKP)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1 MiB + 4 KiB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Enthält die initale Page Table und das Page Directory des Kernels.
 Die Page Tabels dieses Adressraums werden von allen anderen virtuellen
 Adressräumen mitbenutzt, um den Kerneladressraum abzubilden.
 Die IKB ist entlang einer Seitengrenze angepasst.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Page Buffer Table (PBT)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(
\emph on
R
\emph default
 / 4096) * 14 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Enthält eine Tabelle aus Einträgen zu je 4 Byte.
 Diese Tabelle beinhaltet einerseits einen Zähler, der angibt, für wieviele
 virtuelle Seiten ein Seitenrahmen des RAM derzeit verwendet wird (die Tabelle
 verwaltet alle Seiten ab der 1-MiB-Grenze).
 Ist der Zähler gleich 0, ist der Rahmen derzeit nicht verwendet.
 
\end_layout

\begin_layout Standard
Ist der Zähler gleich 1, wird er von einem Prozess an einer bestimmten Stelle
 verwendet.
 Die weiteren Byte des Eintrags beinhalten dann die SID des Prozesses und
 die Adresse, an welcher der Seitenrahmen im virtuellen Adressraum des Prozesses
 verwendet wird.
\end_layout

\begin_layout Standard
Ist der Zähler größer 1, wird die Seite möglicherweise von verschiedenen
 Prozessen verwendet und ist an verschiedenen virtuellen Seiten eingeblendet.
 Daher verweisen die folgenden Byte des Eintrags auf eine Liste aus Einträgen
 der PST, mit deren Hilfe herausgefunden kann, wo der Seitenrahmen derzeit
 verwendet wird.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Page Share Table (PST)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
((
\emph on
R
\emph default
 / 4096) * 0.2) * 12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Die PST ist keine konsistente Tabelle.
 Sie ist vielmehr eine Puffer, indem verkettete Listen angelegt werden können.
 Im Grundzustand besteht in der PST nur eine verkettete Liste, die alle
 ungenutzten Einträge der PST miteinander verkettet, so dass rasch ein neuer
 Eintrag der PST alloziiert werden kann.
\end_layout

\begin_layout Standard
Eine PST-Liste besteht aus Einträgen, die angeben, welcher Prozess (SID)
 an welcher virtuellen Adresse einen Seitenrahmen verwendet.
 Jeder Eintrag ist mit dem nächsten Eintrag dieser Liste verknüpft.
 Die Liste selbst ist einem PBT-Eintrag zugeordnet, der zu einem Seitenrahmen
 gehört, der an mehr als einer virtuellen Adresse eingeblendet ist.
\end_layout

\begin_layout Standard
Die PST ist so ausgelegt, dass für 20% aller Speicherseiten (beider Zonen)
 jeweils ein Eintrag in ihr reserviert ist.
 Eine dynamische Lösung könnte in späteren Versionen des 
\emph on
hymk
\emph default
 folgen.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Normal Zone Free Memory Stack (NZS)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(
\emph on
N
\emph default
 / 4096) * 4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der Normal Zone FMS ist ein LIFO-Stack, indem die physikalischen Adressen
 aller derzeit freier Seitenrahmen der Normal Zone abgespeichert sind, sofern
 sie aus dem 
\emph on
Page Buffer
\emph default
 stammen.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
High Zone Free Memory Stack (HZS)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(
\emph on
H
\emph default
 / 4096) * 4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Der High Zone FMS ist ein LIFO-Stack, indem die physikalischen Adressen
 aller derzeit freier Seitenrahmen der High Zone abgespeichert sind, sofern
 sie aus dem 
\emph on
Page Buffer
\emph default
 stammen.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Page Buffer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
R - 
\emph default
(
\emph on
PBT
\emph default
 - 
\emph on
PST
\emph default
 - 
\emph on
NZS
\emph default
 - 
\emph on
HZS
\emph default
)
\emph on
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Enthält die Seitenrahmen (wobei manche Kernel-Datenstrukturen in den ersten
 896 MiB des RAMs liegen müssen).
 Der Pagebufferr ist entlang einer Seitengrenze angepasst.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Organisation des virtuellen Adressraums
\end_layout

\begin_layout Standard
Zur 
\begin_inset Quotes gld
\end_inset

Konstruktion
\begin_inset Quotes grd
\end_inset

 des virtuellen Adressraums verwendet der 
\emph on
hymk
\emph default
 zwei plattformspezifische Mechanismen der x86-Architektur für Segmentierung
 und Paging.
 
\end_layout

\begin_layout Standard
Die Segmentierung setzt bei der x86-Architektur auf den durch das Paging
 gebildeten linearen Adressraum auf.
 Darüber ob nun dieser lineare Adressraum dem physikalischen Adressraum
 entspricht oder ein durch das Paging gebildeter virtueller Adressraum ist,
 gibt der Begriff 
\begin_inset Quotes gld
\end_inset

linearer Adressraum
\begin_inset Quotes grd
\end_inset

 keine Auskunft.
 Der Begriff wird in diesem Dokument nur verwendet, um vom segmentierten
 Adressraum zu unterscheiden (dessen Segmente zwar intern auch linear sind,
 aber nur über eine Kombination von Segment und Offsetadress adressiert
 werden können und somit von außen nicht mehr linear adressiert werden können).
 Ist der physikalische (und auch lineare) Adressraum gemeint, so wird dies
 explizit genannt - ebenso, wenn speziell ein linearer, virtueller Adressraum
 gemeint ist.
\end_layout

\begin_layout Subsection
Einsatz der Segmentierung
\end_layout

\begin_layout Standard
Die Segmentierung wird im wesentlichen nur dazu eingesetzt, um den Kernel-Code
 zu reloziieren.
 Nach dem Start des Systems wird der Kernel an die physikalische Speicheradresse
 1 MiB geladen.
 Wie aber aus Kapitel 
\begin_inset LatexCommand \ref{sec:Aufb-virt-Addr}

\end_inset

 entnommen werden kann, wird im Betrieb des Systems der Adressbereich des
 Kernels (der identisch mit den ersten 896 MiB des phyiskalischen Adressraums
 ist) im virtuellen Adressraum an Adressen > 3 GiB verlagert.
 Um die Implementierung einfach zu halten, wird für innerhalb des Kernel-Codes
 verwendete Adressen für direkte Speicherzugriffe auf den physikalischen
 Adressraum der ersten 896 MiB intern kein Offset verwendet und der Kernel-Code
 an die Adresse 1 MiB gelinkt.
 
\end_layout

\begin_layout Standard
In der x86-Architektur werden alle Segmente durch sog.
 Selektoren referenziert.
 Ein Selektor verweist mehr oder weniger auf einen Eintrag in der sog.
 globalen Deskriptorentabelle (global descriptor table, GDT).
 Dieser GDT-Eintrag beschreibt wiederum nebst verschiedenen Zugriffsrechten
 die Startadresse und die Größe des Segments.
 Immer wenn ein Programm auf der x86-Architektur auf den Speicher zugreift,
 muss es dies über eine Adresse tun, die einen Segmentselektor enthält,
 der das Segment referenziert und ein Offset innerhalb des Segments definiert.
 Der Segmentselektor wird meist implizit über eines der Segmentregister
 übergeben, wobei der hymk hier nur auf das Code-Segmentregister (CS) für
 Code-Zugriffe, das Daten-Segmentregister (DS) für Datenzugriffe und das
 Stack-Segmentregister (SS) für Stackzugriffe zurückgreift.
 Die anderen Segmentregister werden höchstens in Ausnahmefällen verwendet.
 Das GS-Segmentregister ist innerhalb des Kernels normalerweise auf das
 Datensegment des Benutzerprozesses gestellt, damit Speicherseiten aus diesem
 Bereich mittels 
\emph on
INVLPG 
\emph default
invalidiert werden können.
 
\end_layout

\begin_layout Standard
Wird nun auf den Speicher zugegriffen, so addiert die CPU die übergebene
 Offsetadresse auf die Startadresse des Segments und verwendet diese lineare
 Adresse, um auf den linearen Adressraum zuzugreifen.
 Zusätzlich ermöglichen Zugriffsrechte die Einschränkung der Verwendung
 von Segmenten für den Kernel- und den Benutzer-Modus über den sog CPL-Wert
 des Segmentdeskriptors (weitere Details können der IA32-Dokumentation von
 Intel entnommen werden).
\end_layout

\begin_layout Standard
Der Kernel verwendet insgesamt sieben Deskriptoren, wobei im wesentlichen
 davon nur vier verwendet werden.
 Diese Deskriptoren sind:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="5">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="1.7cm">
<column alignment="block" valignment="top" leftline="true" width="2.8cm">
<column alignment="block" valignment="top" leftline="true" width="2cm">
<column alignment="block" valignment="top" leftline="true" width="2.1cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="5.4cm">
<row topline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Sel.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Start
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Größe
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Zugriff
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Zweck
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Keiner
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Dummy-Deskriptor; von x86-Architektur vorgeschrieben; wird aber nicht verwendet
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x08
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x00000000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4 GiB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Kernel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Initiales Code-Segment, das den gesamten linearen Adressraum umfasst
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x00000000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4 GiB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Kernel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Initiales Daten/Stack-Segment, das den gesamten linearen Adressraum umfasst
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xC0000000 (~ 3 GiB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1 GiB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Kernel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Kernel-Code Segment
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xC0000000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1 GiB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nur Kernel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Kernel-Daten/Stack-Segment
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x00000000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4 GiB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Jeder
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
User-Code-Segment
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x00000000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4 GiB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Jeder
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
User-Daten/Stack-Segment
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0x38
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(Dynamisch)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
100 B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Kernel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Task-Status-Segment (von x86-Architektur vorgeschrieben)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Die GDT wird statisch durch das Symbol 
\emph on
i386_gdt_s
\emph default
 (
\emph on
start.s
\emph default
) definiert.
 Ihre nähere Beschreibung kann der IA-32-Dokumentation und der Quelltextkommenti
erung entnommen werden.
 Zum Laden der GDT muss ein Dummy-Deskriptor verwendet werden (siehe beschreibun
g der LGDT-Instruktion).
 Hierfür gibt es zwei Deskriptoren - einen, der vor (
\emph on
i386_gdt_des, start.s
\emph default
) und einen der nach (
\emph on
i386_gdt_des_new, start.s
\emph default
) Relokation des Kernels verwendet wird.
\end_layout

\begin_layout Standard
Auffällig ist, dass es ein initales Code- und Datensegment, sowie ein 
\begin_inset Quotes gld
\end_inset

normales
\begin_inset Quotes grd
\end_inset

 Code- und Datensegment für den Kernel gibt.
 Dies hängt ebenfalls mit der Relokation des Kernels zusammen - bevor der
 Kernel im linearen Adressraum neu plaziert wird, benötigt er eine Zugriffsmögli
chkeit auf den vollständigen linearen Adressraum (der zu diesem Zeitpunkt
 noch dem physikalischen entspricht).
 Dafür wird ein Segment angelegt, dass den linearen Adressraum komplett
 abbildet.
 Ist der Kernel im linearen Adressraum reloziiert worden, wird die neue,
 reloziierte IDT mit dem Deskriptor 
\emph on
i386_gdt_des_new, start.s
\emph default
 und die neuen Code- und Datensegment (0x18 bzw.
 0x20) geladen.
 Ab diesem Zeitpunkt kann der Kernel nur noch auf die unteren 896 MiB zugreifen.
\end_layout

\begin_layout Standard
Ebenfalls auffällig ist, dass der User-Code und die User-Daten sich mit
 dem linearen Adressbereich des Kernels überscheindet.
 Da hier der im Benutzermodus ausgeführte Code Zugriffsrecht hat, müsste
 ja zu befürchten sein, dass ein ungültiger Zugriff auf den Kernel-Speicher
 möglich ist.
 Dies wird jedoch auf Ebene des Pagings geregelt.
 Die Überschneidung ist notwendig, damit der ausgeführte Code im Benutzermodus
 Zugriff auf die Info-Pages erhalten kann.
\end_layout

\begin_layout Subsection
Einsatz des Pagings
\end_layout

\begin_layout Standard
Um einen virtuellen, linearen Adressraum zu bilden, verwendet der Kernel
 die Paging-Fähigkeiten der x86-Architektur.
 Diese bietet ein 2-Stufiges Paging-Verfahren an.
 Die 1.
 Stufe bildet die sog.
 Page Directory, deren 1024 Einträge jeweils die physikalische Adresse einer
 Page Table enthält.
 Die 1024 Einträge einer Page Table wiederum enthalten die physikalischen
 Adressen der Seitenrahmen, die für die jeweilige virtuelle Speicherseite
 verwendet werden soll.
 Mit 1024 Seiten die je 4096 Byte groß sind, die in 1024 Seitentabellen
 umschrieben werden, können folglich 4 GiB umschrieben werden (1024 * 1024
 * 4096 Byte = 2^32 Byte = 4 GiB).
 Alle Page-Table und Page-Directory-Einträge haben den Typ 
\emph on
uint32_t
\emph default
.
\end_layout

\begin_layout Standard
Die Einträge in der Page Table enthalten zudem neben der Adresse des Seitenrahme
s verschiedene Zugriffsrechte, die für die jeweilige Seite im virtuellen
 Adressraum gelten werden.
 Die Zugriffsrechte in den Einträgen der Page Directory wirken sich übergeordnet
 auf die Zugriffsrechte der jeweiligen Seite aus.
\end_layout

\begin_layout Standard
Die Zugriffsrechte der x86-Architektur werden im Kernel-Code durch die 
\emph on
PFLAG_
\emph default
*-Makros (
\emph on
mem.h
\emph default
) abgebildet.
 Intern sollten jedoch im Code die 
\emph on
GENFLAG_
\emph default
*-Makros (
\emph on
mem.h
\emph default
) verwendet werden, da diese die plattformspezifischen Flags mit plattformunabhä
ngigen Begriffe abbilden (dies soll spätere Portierungen erleichtern), da
 die x86-Architektur in ihrer Flexibilität bei den Seitenzugriffsrechten
 manchen Architekturen in eingem Nachsteht.
 Die Bedeutung der einzelnen 
\emph on
PFLAG_*
\emph default
-Makros bzw.
 
\emph on
GENFLAG_*
\emph default
-Makros sollte sich aus deren Namen und anhand der IA-32-Dokumentation erschließ
en lassen.
 Einige der 
\emph on
GENFLAG_*
\emph default
-Makros sind nicht Deckungsgleich mit den IA-32-Flags.
 Das Flag 
\emph on
GENFLAG_EXECUTABLE
\emph default
 hat kein IA-32-Gegenstück, existiert aber trotzdem, um eine nachträgliche
 Portierung des Quellcodes zu erleichtern.
 Das Flag 
\emph on
GENFLAG_DONT_OVERWRITE_SETTINGS
\emph default
 ist kein Page-Flag, sondern dient lediglich zur Informierung der internen
 Page-Mapping-Routine und wird später noch erläutert.
 
\end_layout

\begin_layout Standard
Das Flag 
\emph on
GENFLAG_DO_COPY_ON_WRITE 
\emph default
hat keine unmittelbare Hardware-Funktion.
 Es wird über das Flag 
\emph on
PFLAG_AVAILABLE_0
\emph default
, das dem Systemprogrammierer zur freien Verfügung steht, umgesetzt.
 Ist das Flag gesetzt, so soll auf diese Seite die Copy-On-Write-Operation
 ausgeführt werden.

\emph on
 
\emph default
Das Flag 
\emph on
GENFLAG_PAGED_PROTECTED
\emph default
 hat auch keine Hardware-Entsprechung.
 Dieses Flag löst bei einer 
\emph on
unmap
\emph default
-Operation, die nicht durch den Paging-Dämon ausgeführt wird, eine Exception
 aus, so dass der Paging-Dämon die Seite gesondert behandeln kann.
 Es wird effektiv über das Flag 
\emph on
PFLAG_AVAILABLE_1
\emph default
 gespeichert.
\end_layout

\begin_layout Standard
Nach der Initialisierung der Paging-Speicherverwaltung kann die Adresse
 der aktuell verwendeten Page-Directory dem Zeiger 
\emph on
i386_current_pdir
\emph default
 (
\emph on
mem.h
\emph default
).
 Die Page-Tables, die den Kernel-Adressraum umschreiben (und somit in jeder
 Page-Directory konstant vorhanden sind), liegen im IKP-Bereich des physikalisch
en Adressraums (siehe 
\begin_inset LatexCommand \ref{sec:IKP}

\end_inset

) und ist an eine entsprechende Adresse im Kerneladressraum (also Originaladress
e + 3 GiB) eingeblendet.
 Im Kernel-Code kann auf diesen Bereich über den Zeiger 
\emph on
ikp_start
\emph default
 (
\emph on
mem.h
\emph default
) zugegriffen werden.
 Die ersten 4096 Byte des IKP-Bereichs enthalten die ursprüngliche Kernel-Pagedi
rectory, die als Vorlage für neue Adressräume verwendet werden kann.
 Die restlichen 1 MiB der IKP enthalten die Seitendeskriptoren der oberen
 1 GiB des virtuellen 4-GiB-Adressraums.
 Die Verwendung der Deskriptoren kann der Beschreibung des oberen GiB des
 virtuellen Adressraums in Kapitel 
\begin_inset LatexCommand \ref{sec:Aufb-virt-Addr}

\end_inset

 entnommen werden.
\end_layout

\begin_layout Section
Verwaltung von Seitenrahmen
\end_layout

\begin_layout Subsection
Verwaltung freier Seitenrahmen
\end_layout

\begin_layout Standard
Die Hauptaufgabe einer Speicherverwaltung ist natürlich die Reservierung
 und Freigabe von Speicher.
 Die Speicherverwaltung des 
\emph on
hymk
\emph default
 wurde gezielt einfach gehalten.
 Sie verzichtet - im Unterschied zu vielen monolitischen Systemen - auf
 unterschiedliche Allokationswege für verschiedene Anforderungsarten (kleine
 Speicherbereiche etc.), sondern bietet nur einen Mechanismus zur Allokation
 von kompletten Seitenrahmen aus dem physikalischen Adressraum.
 Zusätzlich bietet sie noch einen Kontrollmechanismus bei der Speicherfreigabe,
 bzw.
 beim Seitenmapping, der eine möglichst übersichtliche und für einen Paging-Dien
st transparente Mehrfachnutzung von Seitenrahmen ermöglicht.
 
\end_layout

\begin_layout Standard
Die Allokationsstrategie der Speicherverwaltung ist recht schlicht gehalten.
 Sie baut im wesentlich auf einem Stack nach dem LIFO-Prinzip auf, dessen
 Einträge jeweils immer die physikalische Adresse eines freien Seitenrahmens
 enthält.
 Diese Art Stack wird im 
\emph on
hymk
\emph default
 als Free Memory Stack (FMS) bezeichnet.
 Auf Grund der begrenzten Größe des Kerneladressraums benötigt der 
\emph on
hymk
\emph default
 für die x86-Plattform zwei Stacks jeweils für die 
\emph on
Normal
\emph default
 und die 
\emph on
High-Zone
\emph default
 (in späteren Versionen könnte ebenfalls ein dritter Stack für den DMA-Controlle
r erforderlich sein.).
 
\end_layout

\begin_layout Standard
Seitenrahmen, die für den Kernel bestimmt sind können nur aus dem Stack
 der 
\emph on
Normal Zone
\emph default
 bezogen werden, während Benutzerprogramme aus beiden Stacks ihre Seitenrahmen
 beziehen können.
 Um so viel wie möglich an Normal-Zone-Speicher freizuhalten, werden - wenn
 möglich - für Allokationen aus dem Benutzeradressraum zuerst Seiten aus
 der 
\emph on
High-Zone
\emph default
 verwendet und erst nach Verbrauch dieser die 
\emph on
Normal-Zone
\emph default
 in Angriff genommen.
\end_layout

\begin_layout Standard
Wird ein freier Seitenrahmen angefordert wird von einem dieser FMS jeweils
 ein Eintrag vom Stack heruntergeladen und der Stackpointer inkrementiert.
 Wird hingegen ein Seitenrahmen wieder freigegeben, wird der Stackpointer
 dekrementiert und an dessen aktuelle Adresse dann die Adresse des neuen
 Seitenrahmens geschrieben.
 Vorteil dieses Verfahrens ist seine Einfachkeit - allerdings auf Kosten
 einer möglicherweisen hohen externen Fragmentierung (d.h.
 es kann nicht garantiert werden, dass Seitenrahmen, die in einem virtuellen
 Adressraum am Stück liegen auch tatsächlich im physikalischen Speicher
 am Stück gespeichert sind).
 Außerdem können niemals mehr als eine Speicherseite zusammenhängend alloziiert
 werden.
 Dies stellt allerdings kein größeres Problem dar, da der 
\emph on
hymk
\emph default
 ohnehin keine nicht fest vorgegebenen Datenstrukturen besitzt, die größer
 als eine Speicherseite sind und für Benutzerprogramme der physikalische
 Zusammenhang von Speicherseiten weniger Bedeutung trägt.
 Allerdings bedeutet dies auch, dass für die Alloziierung größerer Speichermänge
n viele kleine Einzelschritte erforderlich sind (wobei die Tatsache mehr
 ins Gewicht fällt, dass zur Erfüllung von gängigen Sicherheitsstandards
 alle Seitenrahmen nach der Alloziierung mit dem Wert 0 aufgefüllt werden).
 Ob sich dieses Verfahren bewährt, wird sich noch zeigen.
\end_layout

\begin_layout Standard
Da neben dem Alloziieren auch das Einblenden der Speicherseiten in den Benutzera
dressraum Zeit kostet, muss die maximale Anzahl von Seiten, die während
 eines Systemaufrufs alloziiert werden können, beschränkt werden.
 Derzeit liegt die Beschränkung bei 8 MiB (2048 Seiten), da diese Speichermenge
 selbst auf langsameren Rechnern mit wenig Zeitverbrauch möglich ist und
 nur relativ selten schlagartig alloziiert werden muss.
\end_layout

\begin_layout Subsection
Verwaltung benutzter Seitenrahmen
\end_layout

\begin_layout Standard
Wenn ein freier Seitenrahmen reserviert worden ist, wird er entweder vom
 Kernel für Speicherzwecke verwendet oder von Prozessen in deren virtuelle
 Adressräume eingebaut - und möglicherweise als gemeinsamer Speicherbereich
 mittels 
\emph on
map
\emph default
 über mehrere andere Prozesse hinweg gemeinsam genutzt.
 Damit sowohl der Kernel, als auch ein späterer Paging-Dienst herausfinden
 kann, in welchem Prozess und an welcher Adresse ein Seitenrahmen zu finden
 ist, ist eine 
\begin_inset Quotes gld
\end_inset

umgekehrte Seitentabelle
\begin_inset Quotes grd
\end_inset

 erforderlich, die eben dieses referenziert.
 Unter HydrixOS erledigen diese Aufgaben die 
\emph on
Page Buffer Table
\emph default
 (PBT) und die 
\emph on
Page Share Table 
\emph default
(PST).
 
\end_layout

\begin_layout Standard
Die PBT enthält für jeden Seitenrahmen des mittleren Bereichs einen Eintrag.
 Dieser Eintrag beschreibt, ob ein Seitenrahmen bereits genutzt wird und
 wenn ja, an wie vielen virtuellen Adressen.
 Wird dieser nur als Seitenrahmen für eine virtuelle Seite verwendet, enthält
 sie ferner noch ein sog.
 
\emph on
SID:VA-Paar
\emph default
 (= SID des Prozesses, der die Seite Verwendet und virtuelle Adresse in
 dessen Adressraum), über das eine Seite in einem bestimmten virtuellen
 Adressraum lokalisiert werden kann.
 Wird der Seitenrahmen hingegen an mehreren virtuellen Adressen und möglicherwei
se von verschiedenen Prozessen genutzt, verweist sie nur auf eine verkettete
 Liste aus 
\emph on
SID:VA-Paaren
\emph default
, die über die PST verteilt abgelegt sind.
 Dies wird dadurch realisiert, dass ein Element der PBT als Union deklariert
 ist und jenachdem vom Programmcode als 
\emph on
SID:VA-Paar
\emph default
 oder als Zeiger auf eine solche verkettete Liste gesehen wird.
 Ein solches 
\emph on
SID:VA-Paar
\emph default
 wird durch die Datenstruktur 
\emph on
page_user_t
\emph default
 (
\emph on
mem.h
\emph default
) näher beschrieben:
\end_layout

\begin_layout LyX-Code
typedef struct { 
\end_layout

\begin_deeper
\begin_layout LyX-Code
sid_t pid;          /* SID des Prozesses */
\end_layout

\begin_layout LyX-Code
uintptr_t u_adr;    /* Virtuelle Adresse */
\end_layout

\end_deeper
\begin_layout LyX-Code
}page_user_t;
\end_layout

\begin_layout Standard
Die PBT selbst ist vom Typ 
\emph on
pbtab_t
\emph default
 (
\emph on
mem.h
\emph default
).
 Das Union, das einerseits aus einem Zeiger auf eine PST-Liste und andererseits
 Einzelbenutzereinträge enthält ist vom Typ 
\emph on
page_usr_u
\emph default
 (
\emph on
mem.h
\emph default
).
 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
typedef union {
\end_layout

\begin_deeper
\begin_layout LyX-Code
page_user_t single;   /* Einzelbenutzer SID:VA */
\end_layout

\begin_layout LyX-Code
sidlist_t *multi;     /* PST-Liste für Mehrbentuzer */
\end_layout

\end_deeper
\begin_layout LyX-Code
}page_usr_u;
\newline

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
typedef struct {
\end_layout

\begin_deeper
\begin_layout LyX-Code
uint16_t usage;       /* Anzahl der Verwendungen */
\end_layout

\begin_layout LyX-Code
page_usr_u owner;     /* Benutzer-Union */
\end_layout

\end_deeper
\begin_layout LyX-Code
}pbtab_t;
\end_layout

\begin_layout Standard
Das Feld 'usage' gibt an, an wie vielen Stellen der Seitenrahmen nun verwendet
 wird.
 '0' bedeutet keiner, '1' bedeutet einer - wobei das 
\emph on
single
\emph default
-Element des Unions 
\emph on
owner
\emph default
 zu beachten ist, während '>1' bedeutet, dass mehrere den Seitenrahmen benutzen
 und das 
\emph on
multi
\emph default
-Element des Unions 
\emph on
owner 
\emph default
beachtet werden muss.
\end_layout

\begin_layout Standard
Deklariert ist die PBT durch die Variable 
\emph on
page_buf_table
\emph default
 (
\emph on
meminit.c
\emph default
; 
\emph on
mem.h
\emph default
).
 Um eine physikalische Adresse in einen PBT-Eintrag leicht umrechnen zu
 können, existiert das Makro 
\emph on
PAGE_BUF_TAB(___padr)
\emph default
 (
\emph on
mem.h
\emph default
).
 Dieses Makro erhält als Parameter die physikalische Adresse und kann selbst
 als PBT-Eintrag behandelt werden (z.B.
 
\family typewriter
\emph on
PAGE_BUF_TAB(addr)->usage
\emph default
 ++
\family default
).
\end_layout

\begin_layout Standard
Was sind nun diese PST-Listen? Die PST ist keine zusammenhängende Tabelle,
 sondern vielmehr ein Puffer für einfach verkettete Listen, deren Elemente
 jeweils eine feste Struktur haben (bestehend aus einem 
\emph on
SID:VA-Paar
\emph default
).
 Eine PST-Liste beschreibt schlichtweg alle Prozesse und alle virtuellen
 Adressen, an denen ein Seitenrahmen verwendet wird.
 Dadurch kann ein Paging-Dienst relativ schnell herausfinden, wo er eine
 Seite entfernen muss, damit er den Seitenrahmen z.B.
 auf die Festplatte auslagern kann.
 Die Liste ist nur einfach verkettet, d.h.
 es kann jeweils nur der Nachbar in vorwärtiger Richtung festgestellt werden.
 Der Anfang einer solchen Liste ist im 
\emph on
multi
\emph default
-Element des zum Seitenrahmen gehörenden PBT-Eintrags verzeichnet.
 
\end_layout

\begin_layout Standard
Jedes Element des Puffers hat den Typ 
\emph on
sidlist_t
\emph default
 (
\emph on
mem.h
\emph default
):
\end_layout

\begin_layout LyX-Code
typedef struct sidlist_st{
\end_layout

\begin_deeper
\begin_layout LyX-Code
page_user_t user; /* SID:VA-Paar */
\end_layout

\begin_layout LyX-Code
struct sidlist_st *nxt; /* Zeiger auf nächsten Eintrag */
\end_layout

\end_deeper
\begin_layout LyX-Code
}sidlist_t;
\end_layout

\begin_layout Standard
Alle freien Elemente der PST sind selbst auch als eine verkettete Liste
 der unbenutzten Einträge verbunden.
 Der Anfang dieser Liste kann über den Zeiger 
\emph on
page_share_table_free 
\emph default
(
\emph on
meminit.c
\emph default
; 
\emph on
mem.h
\emph default
) in Erfahrung gebracht werden.
 Immer wenn ein freies Element für eine PST-Liste benötigt wird, wird der
 erste Eintrag aus der Free-Liste herausgenommen und an den Anfang der anderen
 PST-Liste eingefügt (dies ist z.B.
 der Fall, wenn eine Seite durch 
\emph on
map
\emph default
 gemeinsam genutzt werden soll).
 Wird ein zuvor gebrauchter PST-Eintrag wieder freigegeben, wird er wieder
 in die Free-Liste eingefügt (dies geschiet z.B.
 bei 
\emph on
unmap
\emph default
).
\end_layout

\begin_layout Standard
Wenn ein Seitenrahmen von der Einfachebenutzung zur Mehrfachbenutzung wechselt,
 muss stets eine neue PST-Liste erstellt werden, die sowohl den neuen Mitbenutze
r, als auch die Daten des alten Benutzers des Rahmens (aus dem 
\emph on
single
\emph default
-Eintrag des zugeordneten PBT-Eintrags) enthält.
 Wechselt er hingegen von der Mehrfachbenutzung zur Einfachbenutzung, muss
 die PST-Liste (die nun nur noch einen Eintrag enthalten würde) aufgelöst
 werden, und der Inhalt des einen PST-Eintrags in das 
\emph on
single
\emph default
-Element des PBT-Eintrags des Seitenrahmens übernommen werden.
 Da diese ja als Union organisiert sind, überschreibt der Inhalt des 
\emph on
multi-
\emph default
Elements das 
\emph on
single-
\emph default
Element.
\end_layout

\begin_layout Standard
Durch dieses Verfahren kann relativ schnell, einfach und trotzdem platzsparend
 eine Verwaltung des belegten Speichers durchgeführt werden.
 Nachteil des Verfahrens ist derzeit noch, dass die PST-Liste eben nur aus
 Einträgen der PST bestehen kann, die ihrerseits eine statische Größe im
 Speicher ist.
 Ist die PST voll, können keine weiteren Speicherseiten mehr gemeinsam genutzt
 werden, selbst wenn noch genügend RAM frei wäre.
 In späteren Versionen soll hier die Verwaltung der PST selbst dynamisch
 gemacht werden.
\end_layout

\begin_layout Subsection
Interne Schnittstellen
\end_layout

\begin_layout Subsubsection
Reservierung von Seitenrahmen im Kernel
\end_layout

\begin_layout Standard
Intern gibt es zur Reservierung von Speicherseiten zwei Funktionen: 
\emph on
kmem_alloc_user_pageframe
\emph default
 (
\emph on
alloc.c
\emph default
; 
\emph on
mem.h
\emph default
) und 
\emph on
kmem_alloc_kernel_pageframe 
\emph default
(
\emph on
alloc.c; mem.h
\emph default
).
 Beide Funktionen reservieren über die Stacks einen einzelnen Seitenrahmen
 geben und einen 
\emph on
void
\emph default
-Zeiger auf die physikalische Adresse des Seitenrahmens zurück.
 Wird 
\emph on
NULL
\emph default
 zurückgegeben, schlug die Reservierung fehl.
\end_layout

\begin_layout Standard
Die Funktion 
\emph on
kmem_alloc_kernel_pageframe
\emph default
 bezieht Seitenrahmen nur aus der 
\emph on
Normal-Zone
\emph default
 und schreibt in den PBT-Eintrag der neu reservierten Seite als Besitzer
 den SID-Platzhalter 
\emph on
kernel
\emph default
 und als Adresse die Adresse des Seitenrahmens im virtuellen Kerneladressraum
 (Adresse des Seitenrahmens + 3 GiB) ein, wodurch ein Paging-Dienst erkennen
 sollte, dass dieser Seitenrahmen dem Kernel gehört und 
\emph on
auf keinen Fall
\emph default
 ausgelagert werden darf.
 Da diese Funktion die 
\emph on
Normal-Zone
\emph default
 belastet und die entsprechenden Kernel-Markierungen enthält, sollte sie
 eben nur für Anforderungen des Kernels verwendet werden.
 Sie sollte daher besser auch nicht durch 
\emph on
map
\emph default
 etc.
 in Benutzeradressräume gelangen.
\end_layout

\begin_layout Standard
Die Funktion 
\emph on
kmem_alloc_user_pageframe
\emph default
 hingegen bezieht Seitenrahmen zuerst aus der 
\emph on
High-Zone
\emph default
, bis diese aufgebraucht ist (falls sie überhaupt vorhanden war...) und erst
 dann aus der 
\emph on
Normal-Zone.

\emph default
 Somit können auf diese Seitenrahmen, die diese Funktion liefert nicht vom
 Kernel direkt zugegriffen werden.
 Als Parameter erhält diese Funktion das 
\emph on
SID:VA
\emph default
-Paar, dem der Seitenrahmen später einmal zugeordnet werden soll.
 Die Funktion trägt diese Daten als Einzelbenutzer in das 
\emph on
single-Element
\emph default
 des PBT-Eintrags des Seitenrahmens ein.
\end_layout

\begin_layout Standard
Beide Funktionen greifen auf ein Makro mit Namen 
\emph on
kmem_zero_out
\emph default
 (
\emph on
alloc.c
\emph default
) zurück.
 Dieses Makro füllt den Seitenrahmen mit 0-Bytes auf, so dass frisch alloziierte
 Seitenrahmen mit 0 initialisiert sind und keine früheren (möglicherweise
 Sicherheitskritischen) Inhalte mehr enthalten können.
 Hier ist zu beachten, dass der Kernel bei Allokationen aus der High-Zone
 zum Überschreiben der alten Seiteninhalte den Seitenrahmen zuerst in einen
 für ihn zugänglichen Speicherbereich (hierfür ist der UMCA-Bereich vorgesehen,
 siehe 
\begin_inset LatexCommand \ref{UMCA}

\end_inset

) mappen muss.
 Beide Funktionen setzen ebenfalls den Usage-Counter des Seitenrahmens auf
 1.
\end_layout

\begin_layout Standard
Die Funktion 
\emph on
sysc_alloc_pages
\emph default
 (
\emph on
alloc.c
\emph default
) ist die Implementierung des 
\emph on
alloc_pages
\emph default
-Systemaufruf.
 Diese sollte neben dem Copy-On-Write-Handler des Kernels (
\emph on
kmem__on_write, page.c
\emph default
) als einzige derzeit 
\emph on
kmem_alloc_user_pageframe
\emph default
 verwenden.
 Die Systemaufrufsimplementierung kann im Kernel intern auch zur Alloziierung
 und anschließenden Plazierung von Seitenrahmen verwendet werden.
 Der Systemaufruf wird im folgenden Kapitel über Page Mappings näher erläutert.
\end_layout

\begin_layout Subsubsection
Freigabe von Seitenrahmen des Kernels
\end_layout

\begin_layout Standard
Seitenrahmen, die zuvor mit 
\emph on
kmem_alloc_kernel_pageframe
\emph default
 reserviert wurden, müssen anschließend durch 
\emph on
kmem_free_kernel_pageframe
\emph default
 (
\emph on
alloc.c
\emph default
;
\emph on
 mem.h
\emph default
) wieder freigegeben werden.
 Als Parameter erhält diese Funktion einen 
\emph on
void
\emph default
-Zeiger auf den Seitenrahmen.
 Diese Funktion überführt den Seitenrahmen direkt in den passenden Zonenstack
 (sowohl Normal, als auch High-Zone, da die Funktion auch von 
\emph on
kmem_free_user_pageframe
\emph default
 verwendet wird).
 Der PBT-Eintrag wird ungeachtet irgendwelcher verknüpfter PST-Einträge
 zurückgesetzt - daher sollten mit dieser Funktion direkt nur Kernel-Seitenrahme
n freigegeben werden und diese Kernel-Seitenrahmen wiederum niemals mittels
 
\emph on
map
\emph default
 zur gemeinsamen Nutzung verwendet werden.
\end_layout

\begin_layout Subsubsection
Freigabe von Seitenrahmen aus dem Userland
\end_layout

\begin_layout Standard
Seitenrahmen, die hingegen zuvor mit 
\emph on
kmem_alloc_user_pageframe
\emph default
 reserviert wurden, müssen anschließend durch 
\emph on
kmem_free_user_pageframe
\emph default
 (
\emph on
alloc.c
\emph default
;
\emph on
 mem.h
\emph default
) freigegeben werden.
 Diese Funktion erhält als Parameter das 
\emph on
SID:VA
\emph default
-Paar, das beschreibt, an welcher Stelle der Seitenrahmen aus einem virtuellen
 Adressraum entfernt wurde.
 Die Funktion prüft anschließend, ob es diese Stelle gibt und entfernt diese
 ggf.
 aus der PST-Liste des Seitenrahmens.
 Wurde der Seitenrahmen zuvor nur noch von einem Prozess verwendet, gibt
 die Funktion den Seitenrahmen entgültig mittels 
\emph on
kmem_free_kernel_pageframe
\emph default
 wieder frei.
 Wenn andere Prozesse den Seitenrahmen noch verwenden, bleibt er hingegen
 weiterhin bestehen, nur die Nutzungsinformation wurde entfernt und der
 
\emph on
usage
\emph default
-Zähler des PBT-Eintrags wurde dekrementiert.
\end_layout

\begin_layout Section
Verwaltung virtueller Adressräume
\end_layout

\begin_layout Subsection
Erzeugung und Vernichtung virtueller Adressräume
\begin_inset LatexCommand \label{sub:Erzeugung-und-Vernichtung}

\end_inset


\end_layout

\begin_layout Standard
Ein virtueller Adressraum wird immer dann erstellt, wenn ein Prozess den
 Systemaufruf 
\emph on
create_process
\emph default
 aufruft.
 Die Behandlungsroutine des Systemaufrufs (
\emph on
sysc_create_process, subject.c
\emph default
) wiederum erstellt einen virtuellen Adressraum durch die Funktion 
\emph on
kmem_create_space
\emph default
 (
\emph on
page.c
\emph default
).
 Diese Funktion reserviert zuerst ein Kernel-Pageframe für eine Page-Directory.
 Die oberen 3 GiB des Page Directories werden mit den entsprechenden Einträgen
 der IKP verknüpft, so dass der virtuelle Kerneladressraum in den neuen
 Adressraum eingeblendet wird.
\end_layout

\begin_layout Standard
Für die Auflösung eines virtuellen Adressraums ist die interne Funktion
 
\emph on
kmem_destroy_space
\emph default
 (
\emph on
page.c
\emph default
) zuständig, die als Parameter die Adresse des Page-Directories des Adressraums
 erhält.
 Diese Funktion gibt zuerst alle im Page Directory aufgeführten Seitentabellen
 frei, die unterhalb der 3-GiB-Grenze liegen.
 Anschließend wird das Page-Directory freigegeben.
\end_layout

\begin_layout Subsection
Abrufen und Erzeugen von Seitentabellen
\end_layout

\begin_layout Standard
Wenn das Mapping von virtuellen Seiten geändert oder abgerufen werden soll,
 kann es oft passieren, dass zu einer entsprechenden virtuellen Seite noch
 keine Seitentabelleneintrag existiert.
 Um dies möglichst transparent zu gestalten, gibt es die Inline-Funktion
 
\emph on
kmem_get_table
\emph default
 (
\emph on
page.h
\emph default
).
 Diese Funktion sucht im gegebenen Page Directory nach dem Eintrag der gesuchten
 Page Table anhand einer übergebenen virtuellen Adresse.
 Ist keine Page Table vorhanden, wird von dieser Funktion automatisch eine
 erstellt, falls dieses gewünscht ist.
 Andernfalls wird ein NULL-Pointer zurückgegeben.
 Ist die Page Table jedoch vorhanden, wird einfach der Zeiger auf diese
 zurückgegeben.
\end_layout

\begin_layout Subsection
Einblenden von Seitenrahmen
\end_layout

\begin_layout Standard
Um einen Seitenrahmen an eine virtuelle Adresse einzublenden, muss der Seitendes
kriptor (der in einer über 
\emph on
kmem_get_table
\emph default
 erhältlichen Seitentabelle liegt) der zugeordneten virtuellen Seite geändert
 und dessen Zugriffsrechte und Steuerflags dem Bedarf entsprechend angepasst
 werden.
 Handelte es sich zuvor um eine Seite, deren 
\emph on
GENFLAG_GLOBAL
\emph default
-Flag gesetzt war oder um eine Seite des derzeit aktiven virtuellen Adressraums,
 muss anschließend der TLB für diese Seite invalidiert werden, da sonst
 die CPU möglicherweise noch einen falschen Seitendeskriptor im TLB hält
 und die virtuelle Seite dann falsch dereferenziert.
 Da es sich hierbei um eine Assembleranweisung (
\emph on
INVLPG
\emph default
) handelt, bietet der Kernel zur Vereinfachung ein gleichnamiges Makro 
\emph on
INVLPG
\emph default
 (
\emph on
mem.h
\emph default
) an, dass dieses übersichtlich erledigt.
 Außerdem muss immer dann, wenn eine aktive Speicherseite (
\emph on
GENFLAG_AVAILABLE
\emph default
 ist gesetzt) eingeblendet wird, in der Speicherverwaltungstabelle des Prozesses
 (siehe 
\begin_inset LatexCommand \ref{sub:Die-Speicherverwaltungstabelle}

\end_inset

) der Eintrag, der der jeweiligen Seitentabelle entspricht inkrementiert,
 bzw.
 beim Ausblenden dekrementiert werden.
\end_layout

\begin_layout Standard
Je nach Fall wird im Kernel das Einblenden der Speicherseiten für die einzelne
 Funktionalität jeweils separat implementiert oder es wird auf zwei Standardfunk
tionen zurückgegriffen, die der Kernel anbietet: 
\emph on
kmem_map_page_frame
\emph default
 (
\emph on
page.c
\emph default
, 
\emph on
mem.h
\emph default
) und 
\emph on
kmem_map_page_frame_cur
\emph default
 (
\emph on
page.c
\emph default
, 
\emph on
mem.h
\emph default
).
 Die erste Funktion muss immer dann verwendet werden, wenn ein Seitenrahmen
 in einen virtuellen Adressraum eingeblendet werden soll, der nicht dem
 aktuellen entspricht.
 Sie darf nicht verwendet werden, wenn der Zieladressraum dem aktuellen
 entspricht, da sie die TLB-Einträge nicht invalidiert.
 Die zweite Funktion kann nur für den aktuellen virtuellen Adressraum verwendet
 werden.
 
\emph on
kmem_map_page_frame_cur
\emph default
 greift zwar auf 
\emph on
kmem_map_page_frame
\emph default
 zurück - invalidiert aber im Nachhinein den TLB.
 Im wesentlichen wird durch beide Funktionen der Seitendeskriptor geändert
 und der Status in der Speicherverwaltungstabelle des dem Adressraum zugeordnete
n Prozesses geändert.
 Wenn als Parameter das Flag 
\emph on
GENFLAG_DONT_OVERWRITE_SETTINGS
\emph default
 übergeben wird, werden bereits bestehende Mappings von beiden Funktionen
 nicht überschrieben.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
alloc_pages
\end_layout

\begin_layout Standard
Der Systemaufruf 
\emph on
alloc_pages
\emph default
 wird durch die Funktion 
\emph on
sysc_alloc_pages
\emph default
 (
\emph on
alloc.c
\emph default
) implementiert.
 Der Systemaufruf alloziiert - nach Prüfung der übergebenen Parameter -
 einzelne Seitenrahmen über 
\emph on
kmem_alloc_user_page_frame
\emph default
 (
\emph on
alloc.c
\emph default
) und blendet diese in den aktuellen Adressraum mittels 
\emph on
kmem_map_page_frame_cur
\emph default
 ein.
 Wichtig ist, dass das 
\emph on
GENFLAG_DONT_OVERWRITE_SETTINGS
\emph default
-Flag gesetzt ist, da nach den Spezifikationen des Systemaufrufs bestehende
 Seitenrahmen nicht überschrieben werden drüfen.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
map
\end_layout

\begin_layout Standard
Der Systemaufruf 
\emph on
map
\emph default
 wird durch die Funktion 
\emph on
sysc_map
\emph default
 (
\emph on
map.c
\emph default
) implementiert.
 Zuerst prüft der Systemaufruf die verschiedenen Parameter und die Zugriffsrecht
e auf den Zielprozess.
 Anschließend lädt er verschiedene häufig verwendete Prozess-Eigenschaften
 und -Tabellen in lokale Variablen, darunter z.B.
 das Page Directory der Prozesse (
\emph on
l__pdir_d
\emph default
 und 
\emph on
l__pdir_s
\emph default
) oder die Speicherverwaltungstabelle des Zielprozesses (
\emph on
l__pstat
\emph default
_
\emph on
d
\emph default
).
 
\end_layout

\begin_layout Standard
Im zweiten Teil der Funktion werden dann in einer while-Schleife die Speichersei
ten in den Zieladressraum eingeblendet.
 Dort werden zuerst die Seitentabellen des Ziel- und Quelladressraums ermittelt,
 die die zu ändernden Deskriptoren enthalten.
 Die Funktion blendet keine Speicherseiten in den Zieladressraum ein, wenn
 entweder dort im Zielbereich bereits Speicherseiten eingeblendet sind oder
 im Quelladressraum die ausgewählten Speicherseiten als inaktiv markiert
 sind.
 Ist dem Quellbereich nicht einmal eine Seitentabelle zugeordnet, werden
 1024 Seiten übersprungen, um den Vorgang zu beschleunigen.
 Wenn jedoch eingeblendet werden kann, werden zu aller erst die PBT-Einträge
 angepasst.
 War eine Seite zuvor ohne PST-Liste, wird diese erstellt, andernfalls um
 die Daten des neuen Seitenmitbenutzers erweitert.
 Sind derzeit keine PST-Einträge mehr frei, wird die Operation mit einer
 Fehlermeldung abgebrochen.
 
\end_layout

\begin_layout Standard
Ist die Änderung des PBT-Eintrags erfolgreich gewesen, wird zuerst in der
 Speicherverwaltungstabelle des Zielprozesses der Eintrag frür die jeweilige
 Seitentabelle inkrementiert.
 Anschließend wird geprüft, ob es sich um ein Copy-On-Write-Mapping handelt.
 Ist dem so, wird ebenfalls der Eintrag des Quelladressraums für Copy-On-Write
 selektiert und der TLB für den Quelladressraum an der gegebenen Adresse
 mit 
\emph on
INVLPG
\emph default
 (
\emph on
mem.h
\emph default
) invalidiert, da der Quelladressraum ja dem derzeitig aktiven Adressraum
 entspricht.
 Anschließend wird der Seitentabelleneintrag des Zieladressraum geändert.
 Ist der Zieladressraum mit dem Quelladressraum identisch - also somit auch
 derzeit aktiver virtueller Adressraum -, wird für diesen ebenfalls mit
 
\emph on
INVLPG
\emph default
 der TLB für die gegebene Adresse invalidiert.
 
\end_layout

\begin_layout Standard
Zum Schluß werden Ziel und Quelladresse um 4096 erhöht und die Schleife
 wieder von vorne begonnen, es sei denn die angegebene Zahl von Seiten wurde
 abgearbeitet.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
unmap
\end_layout

\begin_layout Standard
Die Implementierung des Systemaufrufs 
\emph on
unmap
\emph default
 ist die Funktion 
\emph on
sysc_unmap
\emph default
 (
\emph on
map.c
\emph default
).
 Diese Funktion prüft ebenfalls zuerst alle Zugriffsrechte auf den Zielbereich
 und ermittelt Informationen, die während des eigentlichen Vorgangs später
 wichtig seien werden - darunter z.B.
 das Page Directory des Zielprozesses (
\emph on
l__pdir_d
\emph default
) und dessen Speicherverwaltungstabelle (
\emph on
l__pstat_d
\emph default
)
\end_layout

\begin_layout Standard
Im zweiten Teil der Funktion wird ebenfalls in einer while-Schleife die
 eigentliche Mapping-Operation durchgeführt.
 Zuerst wird die zuständige Seitentabelle mit 
\emph on
kmem_get_table 
\emph default
ermittelt.
 Hier ist anzumerken, dass 
\emph on
kmem_get_table
\emph default
 mitgeteilt wird, keine Seitentabelle zu erstellen, wenn bisher im Zieladdressra
um keine existierte, da ja beim Unmap-Vorgang keine Seitenrahmen neu hinzukommen
 werden.
 Handelt es sich beim Zielbereich tatsächlich um einen Bereich, dem keine
 Seitentabelle zugeordnet wurde, werden ferner 1024 Seitenrahmen übersprungen,
 um den Vorgang zu beschleunigen.
 Je nachdem, welche Parameter 
\emph on
unmap
\emph default
 übergeben wurden, wird dann im folgenden Teil der Schleife die Zugriffsflags
 der virtuellen Seite geändert oder die virtuelle Seite komplett entfernt
 (
\emph on
UNMAP_COMPLETE
\emph default
 oder 
\emph on
UNMAP_AVAILABLE
\emph default
).
 In letzterem Fall erfolgt die Freigabe des zugeordneten Seitenrahmens (bzw.
 des 
\emph on
SID:VA
\emph default
-Paares der zu entfernenden virtuellen Adresse aus der PST-Liste des PBT-Eintrag
s der Seite) über 
\emph on
kmem_free_user_page_frame
\emph default
 (
\emph on
alloc.c
\emph default
).
 
\end_layout

\begin_layout Standard
Wurde die Operation auf den aktuellen virtuellen Adressraum ausgeführt,
 wird mit 
\emph on
INVLPG
\emph default
 der TLB für die betroffenen Adressen invaildiert.
 Zum Schluß wird die Zieladresse um 4096 erhöht und die Schleife wiederholt,
 bis alle Seitenrahmen abgearbeitet wird.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
move
\end_layout

\begin_layout Standard
Der Systemaufruf 
\emph on
move
\emph default
 ist über die Funktion 
\emph on
sysc_move
\emph default
 (
\emph on
map.c
\emph default
) implementiert.
 Im wesentlichen ruft er intern die Implementierungen der Systemaufrufe
 
\emph on
map 
\emph default
und 
\emph on
unmap
\emph default
 (
\emph on
sysc_map 
\emph default
/
\emph on
 sysc_unmap
\emph default
,
\emph on
 map.c
\emph default
) auf.
 Tritt zwischen dem 
\emph on
map
\emph default
 und 
\emph on
unmap
\emph default
-Vorgang ein Fehler auf, wird die Operation vorzeitig abgebrochen.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
allow
\end_layout

\begin_layout Standard
Auch wenn der Systemaufruf 
\emph on
allow
\emph default
, der über die Funktion 
\emph on
sysc_allow
\emph default
 (
\emph on
map.c
\emph default
) implementiert ist, selbst keine Mapping-Operationen durchführt, ist sie
 der Vollständigkeit halber hier ebenfalls aufgeführt.
 Diese Operation ändert, nach Prüfung der Zugriffsrechte, lediglich die
 Thread-Deskriptoren, so dass die gewählten Zugriffsrechte für eine 
\emph on
map-
\emph default
 oder 
\emph on
unmap
\emph default
-Operation hergestellt oder verweigert werden können.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
io_alloc
\end_layout

\begin_layout Standard
Eine Sonderrole spielt der Systemaufruf 
\emph on
io_alloc
\emph default
, der zum Einblenden von Hardware-Speicherbereichen dient.
 Dessen Implementierung - 
\emph on
sysc_io_alloc
\emph default
 (
\emph on
io.c
\emph default
) - baut, neben den erforderlichen Prüfungen der Zugriffsrechte, im wesentlichen
 auf 
\emph on
kmem_map_pageframe_cur
\emph default
 auf, so dass eine weitere Beschreibung der internen Vorgänge nicht notwendig
 ist.
 Anzumerken ist, dass normalerweise das Flag 
\emph on
GENFLAG_NOT_CACHEABLE
\emph default
 gesetzt wird, um Zugriffe auf die Speicherseite unter Übergehung des CPU-Caches
 möglich zu machen.
 Dies kann jedoch durch den Systemaufrufsparameter 
\emph on
IOMAP_WITH_CACHE
\emph default
 unterbunden werden.
\end_layout

\begin_layout Section
Initialisierung der Speicherverwaltung
\end_layout

\begin_layout Subsection
Initialisierung der Speicherverwaltungstabellen
\end_layout

\begin_layout Standard
Die Speicherverwaltung wird beim Start des Systems durch die Funktion 
\emph on
kmem_init_tables
\emph default
 (
\emph on
meminit.c
\emph default
) initialisiert.
 Diese Funktion berechnet zuerst die Startadressen und die Größe von IKP
 (wobei diese statisch ist), PBT, PST, NZS, HZS und Page-Buffer.
 Anschließend initialisiert sie PBT, PST, NZS und ggf.
 die HZS entsprechend.
 
\end_layout

\begin_layout Standard
In allen Einträgen der PBT wird der 
\emph on
usage
\emph default
-Zähler, sowie die Einzelbenutzerdaten aus dem 
\emph on
single
\emph default
-Element auf 0 gesetzt.
 In der PST werden alle Einträge zur Free-Liste verkettet, so dass alle
 Elemente der kompletten PST als freigegeben gelten.
 Der Anfang der Free-Liste der PST (
\emph on
page_share_table_free, meminit.c
\emph default
) wird auf den ersten Eintrag gelegt.
 Der letzte Eintrag der PST - und somit der Free-Liste erhält als folge
 Eintrag einen NULL-Zeiger.
 
\end_layout

\begin_layout Standard
In den NZS und den HZS werden jeweils die verbleibenden Speicherseiten des
 Page-Buffers der jeweiligen Zone als Einträge auf den Stack gelegt.
 Anschließend werden deren Stack-Pointer jeweils auf den zuletzt initialisierten
 Eintrag der beiden Stacks gelegt.
 Der HZS wird logischerweise nicht initialisiert, wenn es keine High-Zone
 gibt.
\end_layout

\begin_layout Subsection
Initialisierung der Kernel-Seitentabellen
\end_layout

\begin_layout Standard
Nach diesen Initialisierungen wird die IKP initialisiert.
 Zuerst wird das Page-Directory (PD) der IKP auf die jeweiligen Page-Tables
 der IKP ausgerichtet - was nur die PD-Einträge der oberen 3 GiB betrifft.
 Zusätzlich wird der erste PD-Eintrag ebenfalls auf die erste Page-Table
 der IKP gestellt, da dies später für den Wechsel in den virtuellen Kerneladress
raum wichtig ist.
 
\end_layout

\begin_layout Standard
Anschließend werden alle Kernel-Page-Tables mit Einträgen aufgefüllt, die
 die ersten 896 MiB des Adressraums in die ersten 896 MiB der oberen 3 GiB
 des virtuellen Adressraums abbilden.
 Die verbleiebenden Page-Tables werden mit Einträgen aufgefüllt, die auf
 keine Seitenrahmen verweisen.
 Diese werden später initialisiert.
 Bei den Seitentabelleneinträge, die das erste MiB des physikalischen Adressraum
s beschreiben, wird das Cache-Disable-Flag gesetzt, da dieser Speicherbereich
 auf PC-Plattformen sehr viele Hardware-Speicherseiten enthält, die nicht
 gecached werden dürfen (z.B.
 VGA-Textmodus-RAM).
 Für alle Speicherseiten und Seitentabellen des Kernels setzt das System
 das Flag 
\emph on
PFLAG_GLOBAL
\emph default
 (bzw.
 
\emph on
GENFLAG_GLOBAL
\emph default
).
 Dadurch soll, wenn von der jeweiligen Plattform unterstützt, der Zugriff
 auf den Kernel-Adressraum mittels der Paging-Global-Extension der x86-Architekt
ur beschleunigt werden.
 Seiten mit gesetztem Global-Flag werden selbst bei einem Prozesswechsel
 nicht aus dem TLB entfernt.
 Werden sie geändert, muss immer der TLB durch die INVLPG-Instruktion invalidier
t werden.
\end_layout

\begin_layout Standard
Ist die IKP initialisiert worden, versucht der Kernel in den neuen virtuellen
 Adressraum zu wechseln.
 Dies erledigt die Funktion 
\emph on
kmem_switch_krnl_spc
\emph default
 (
\emph on
page.c
\emph default
; 
\emph on
mem.h
\emph default
).
 Diese Funktion führt als erstes den Plattformspezifischen Wechsel des Paging-Di
rectories durch, indem das CR3-Register der CPU auf die Adresse des IKP-Pagedire
ctories gelegt wird.
 Anschließend wird das Paging-Bit im Kontrollregister CR0 gesetzt, wodurch
 das Paging in der CPU aktiviert wird.
 In diesem Moment sind Kernel-Code/Daten noch an der Stelle im virtuellen
 Adressraum eingeblendet, an der sie von GRUB geladen wurden.
 Gleichzeitig ist aber bereits der virtuelle Kerneladressraum jenseits der
 3 GiB-Grenze aufgebaut.
 Um nun hier einen Wechsel zu vollziehen, werden die Daten- und Stacksegmentregi
ster der CPU auf das Kernel-Datensegment der GDT gesetzt, dass seinen Beginn
 an der 3 GiB-Grenze hat.
 Anschließend wird ein Long-Jump in das gleichliegende Kernel-Code-Segment
 vollzogen, so dass nun der Kernel-Code ausgeführt wird, der im virtuellen
 Kerneladressraum jenseits der 3 GiB-Grenze eingeblendet ist.
 Der Kernel-Code im alten Adressbereich (> 1 MiB) wird anschließend aus
 dem virtuellen Kerneladressraum ausgeblendet, so dass die IKP als Vorlage
 für andere Page-Directories verwendet werden kann.
\end_layout

\begin_layout Standard
Die Variable 
\emph on
i386_current_pdir
\emph default
 (
\emph on
page.c
\emph default
; 
\emph on
current.h
\emph default
), welche angibt, welches Page-Directory derzeit verwendet wird, wird auf
 das Page-Directory der IKP gesetzt.
 Somit ist der virtuelle Kernel-Adressraum initialisiert und als gültiger
 virtueller Adressraum aktiviert.
\end_layout

\begin_layout Section
Schlußbemerkungen
\end_layout

\begin_layout Standard
Die Speicherverwaltung ist einer der Hauptaufgaben des 
\emph on
hymk
\emph default
.
 An einigen Stellen ist jedoch bereits jetzt Verbesserungsbedarf erkennbar.
 In diesem Abschnitt sind entsprechende Hinweise zur Speicherverwaltung
 aufgeführt.
\end_layout

\begin_layout Subsection
Erweiterung um einen Paging-Dienst
\end_layout

\begin_layout Standard
Sollte eine Seitenauslagerung in HydrixOS auf Basis des 
\emph on
hymk 
\emph default
etabliert werden, so wird dringend eine Überprüfung des Codes empfohlen.
 In 
\emph on
kmem_get_table
\emph default
 (
\emph on
page.h
\emph default
) werden z.B.
 Seitenrahmen dann eingefügt, wenn der entsprechende Eintrag im Seitenverzeichni
s kein gesetztes 
\emph on
GENFLAG_PRESENT
\emph default
-Flag hat.
 Dementsprechend wäre es u.a.
 sinnvoll weitere Flags zu überprüfen, um zwischen nicht-presenenten (d.h.
 ausgelagerten) und inaktiven virtuellen Seiten zu unterscheiden.
 Ähnliches gilt für die Funktionen 
\emph on
map
\emph default
 und 
\emph on
unmap
\emph default
.
\end_layout

\begin_layout Standard
Der Paging-Dämon müsste ebenfalls selbstständig Copy-On-Write-Vorgänge für
 nicht-presente Seitenrahmen durchführen.
 Er sollte es grundsätzlich vermeiden Nicht-Copy-On-Write-Shares auszulagern.
 Auch dies müsste nachträglich bedacht werden, ob und in wie fern Seitentabellen
 ausgelagert werden dürfen und welche Zugriffsrechte auf diese dem Paging-Dienst
 gewärleistet werden müssen und dürfen.
\end_layout

\begin_layout Standard
Ohne Änderung des Kernel-Codes ist derzeit eine Erweiterung um Seitenauslagerung
sfähigkeiten des Gesamtsystems noch nicht möglich.
 Die Änderungen dürften aber nicht zu schwer sein.
 Der Aspekt wurde derzeit noch nicht beachtet, um später die Entwicklung
 eines Auslagerungsmechanismuses nicht durch ungünstige Vorgaben zu behindern.
\end_layout

\begin_layout Subsection
Verbesserung der PST
\end_layout

\begin_layout Standard
Die PST ist derzeit ein statischer Puffer.
 Es sollte hier überlegt werden, wie die Einführung eines dynamischen Puffers
 sinnvoll und Speicherplatzschonend gestaltet werden kann.
\end_layout

\begin_layout Subsection
DMA
\end_layout

\begin_layout Standard
Derzeit wurde die Verwendung eines DMA-Controllers noch nicht weiter beachtet.
 Da insbesondere die Intel-Architektur hier einige Restriktionen aufweist
 (u.a.
 müssen die Speicherseiten unterhalb der 1 MiB-Grenze liegen), müssten hier
 nachträglich besondere Allokationsmechanismen und evtl.
 ein zusätzlicher Systemaufruf für die Allokation von DMA-Speicher eingeführt
 werden - auch da ein DMA-Puffer normalerweise mehr als eine zusammenhängende
 physische Seite benötigt.
 Eine Mögilchkeit wäre, dass der Kernel für Treiber, die DMA-Puffer benötigen
 einige Kontingente an DMA-Puffern erst einmal bereithält und diese verbraucht,
 wenn Speicherknappheit eintritt.
 Die Sicherung der Kontingente für die jeweiligen Treiber würde ohnehin
 ja bereits zur Boot-Zeit des Systems geschehen oder könnte auch durch einen
 DMA-Dienst erfolgen.
\end_layout

\begin_layout Chapter
Subjektenverwaltung
\end_layout

\begin_layout Section
Die Infopages
\end_layout

\begin_layout Standard
Eine der Vorteile moderner Mikrokernel ist, dass das System gänzlich auf
 Systemaufrufe zur reinen Übergabe von Informationen vom Kernel an den Benutzer-
Modus verzichtet.
 Statt dessen werden Informationen direkt über eingeblendete Speicherseiten
 ausgetauscht.
 Unter HydrixOS wurde hierbei versucht, den Aktualisierungsaufwand dieser
 Informationsseiten so niedrig wie möglich zu halten.
 Daher werden die Tabellen, die der Kernel für die Prozess- und Thread-Verwaltun
g verwendet direkt dem Benutzer-Modus zum Lesen zur Verfügung gestellt.
 Um aufwendiges Suchen in verketteten Listen zu vermeiden, werden diese
 in einem eigens dafür angelegten Speicherbereich des virtuellen Adressraums
 eingeblendet.
 Da der Kernel diese Bereiche ebenfalls verwendet, liegen sie im Bereich
 des Kernel-Adressraums jenseits der 3 GiB-Grenze.
\end_layout

\begin_layout Subsection
Überblick über die Datenstrukturen
\end_layout

\begin_layout Standard
Alle Verwaltungstabellen im System sind als Arrays vom Typ 
\emph on
uint32_t
\emph default
 organisiert.
\end_layout

\begin_layout Standard
Die Haupt-Info-Page ist über den Zeiger 
\emph on
main_info
\emph default
 (
\emph on
info.c
\emph default
; 
\emph on
info.h
\emph default
) erreichbar, wobei der Zeiger an die virtuelle Adresse der Hauptinfopage
 relativ zum Begin des Kernel-Adressraums (d.h.
 der Zeiger kann direkt aus dem Kernel-Code heraus verwendet werden) deutet.
 Deren physische Adresse kann über die Variable 
\emph on
real_main_info
\emph default
 ermittelt werden.
 Die einzelnen Elemente der Hauptinfopage sind jeweils die einzelnen Elemente
 des Arrays.
 Um die Übersicht des Programmtextes zu erhalten, existieren die 
\emph on
MAININFO_*
\emph default
-Makros, die gleichermaßen im Kernel-Code, wie auch im Code von Programmen
 für den Benutzer-Modus eingesetzt werden können, da die identische Header-Datei
 verwendet wird (
\emph on
sysinfo.h
\emph default
).
 
\end_layout

\begin_layout Standard
Die zum Anfang des Kernel-Adressraums relative virtuelle Adresse der Threadtabel
le kann über den Zeiger 
\emph on
thread_tab
\emph default
 (
\emph on
info.c
\emph default
;
\emph on
 info.h
\emph default
) referenziert werden.
 Der Array der Thread-Tabelle beschreibt tatsächlich alle Threads - d.h.
 jedes 8192.
 Element des Arrays entspricht einem weiteren Thread-Eintrag in der Thread-Tabel
le, wobei auf einem x86-System natürlich nur die unteren 12-bit einer Thread-SID
 beachtet werden dürfen.
 Die Elemente jedes Thread-Eintrags können dann wiederum durch Addition
 über die 
\emph on
THRTAB_*
\emph default
-Makros (
\emph on
sysinfo.h
\emph default
) gleichermaßen in Kernel- und Benutzer-Code verwendet werden.
 Um den Quelltext weiter zu vereinfachen, wurde das 
\emph on
THREAD
\emph default
-Makro (
\emph on
info.h
\emph default
) eingeführt, über das mittels Thread-SID und eines 
\emph on
THRTAB_*
\emph default
-Makros die jeweilige Information über einen Thread abgerufen oder geändert
 werden kann.
\end_layout

\begin_layout Standard
Für die Prozesstabelle gilt im wesentlichen das gleiche.
 Ihre relative virtuelle Adresse kann über den Zeiger 
\emph on
process_tab
\emph default
 (
\emph on
info.c
\emph default
; 
\emph on
info.h
\emph default
) ermittelt werden.
 Auch in diesem Array beschreibt jeddes 8192.
 Element den nächsten Prozess.
 Die einzelenen Prozess-Informationen können durch Addition des jeweiligen
 
\emph on
PRCTAB_*
\emph default
-Makros ermittelt werden.
 Auch hier existiert ein Makro zur Quelltextvereinfachung, das den Namen
 
\emph on
PROCESS
\emph default
 (
\emph on
info.h
\emph default
) trägt und ebenfalls Thread-SID und das entsprechende 
\emph on
PRCTAB_*
\emph default
-Makro zum Abruf oder zur Manipulation von Prozessinformationen als Parameter
 erhält.
\end_layout

\begin_layout Standard
Beide Tabellen bestehen - im Unterschied zur Hauptinfopage - nicht aus einem
 kontinuierlichen physischen Adressbereich.
 Die einzelnen Seitenrahmen eines Deskriptors werden durch Page-Mappings
 zusammengesetzt (der Mapping-Vorgang für Tabellendeskriptoren wird später
 erläutert).
 Alle Deskriptoren in einer der beiden Tabellen, die inaktiv sind, enthalten
 im ersten Element den Wert 0.
 Sie sind alle auf den gleichen leeren physischen Seitenrahmen, dessen physische
 Adresse über die Variable 
\emph on
real_empty_info
\emph default
 ermittelt werden kann.
\end_layout

\begin_layout Subsection
Verwaltung von Subjektdeskriptoren
\end_layout

\begin_layout Standard
Die Verwaltung der Subjektdeskriptoren wird von zwei Funktionen übernommen:
 
\emph on
kinfo_new_descr
\emph default
 (
\emph on
info.c
\emph default
; 
\emph on
info.h
\emph default
) und 
\emph on
kinfo_del_descr
\emph default
 (
\emph on
info.c
\emph default
; 
\emph on
info.h
\emph default
).
 Beide Funktionen erhalten als Parameter die SID des zu bearbeitenden Subjekts.
 Da die SID bereits die Information über die Subjektart enthält (Prozess
 oder Thread), entscheiden die Funktionen selbstständig, in welche der beiden
 Tabellen Deskriptoren einzublenden sind.
\end_layout

\begin_layout Standard
Die Funktion 
\emph on
kinfo_new_descr
\emph default
 liefert als Rückgabewert einen Zeiger auf den letzten verwendeten physikalische
n Seitenrahmen des Deskriptors, da die physikalische Adresse des letzten
 Seitenrahmen bei der Threadverwaltung für dessen Thread-Local-Storage ständig
 verwendet wird (prinzipiell kann jedoch die Adresse jedes verwendeten physikali
schen Seitenrahmens eines Deskriptors über den Seitendeskriptor des zugeordneten
 Prozess- oder Threadtabelleneintrags ermittelt werden).
\end_layout

\begin_layout Standard
Das Mapping in beiden Funktionen ist direkt implementiert.
 Zu beachten ist, dass beim Einblenden eines neuen Deskriptors in eine Tabelle
 neben 
\emph on
PFLAG_PRESENT
\emph default
 nur 
\emph on
PFLAG_USER
\emph default
 und 
\emph on
PFLAG_GLOBAL
\emph default
 gesetzt sein darf.
 Das Schreibzugriffsflag darf nicht gesetzt werden, da ansonsten Benutzerprogram
me zugriff auf die Daten der Tabelle hätten (der Kernel kann auch bei gelöschtem
 Schreibzugriffsflag auf die Seite schreibend zugreifen).
 Bei jedem Mapping wird logischerweise der TLB mittels 
\emph on
INVLPG
\emph default
 invalidiert.
\end_layout

\begin_layout Standard
Der wesentliche Unterschied zwischen Installation eines neuen Deskriptors
 und der Entfernung eines bestehenden liegt darin, dass in einem Fall ein
 oder mehrere frisch alloziierte Seitenrahmen eingeblendet werden (
\emph on
kinfo_new_descr
\emph default
) und im anderen Fall 
\emph on
real_empty_info
\emph default
 an den Ort der Tabelleneinträge eingeblendet wird, um wieder einen leeren
 Eintrag zu erhalten (
\emph on
kinfo_del_descr
\emph default
).
 Wichtig ist noch, dass 
\emph on
kinfo_new_descr
\emph default
 jeweils bei der ersten Seite des neuen Deskriptors das erste 
\emph on
uint32_t
\emph default
-Element jeweils auf den Wert 1 setzt, so dass der Deskriptor als aktiviert
 gilt.
 
\end_layout

\begin_layout Subsection
Initialisierung des Infopage-Systems
\end_layout

\begin_layout Standard
Das Infopage-System wird durch die Funktion 
\emph on
kinfo_init
\emph default
 (
\emph on
info.c
\emph default
; 
\emph on
info.h
\emph default
) initialisiert.
 Diese Funktion alloziiert physische Seitenrahmen für 
\emph on
real_main_info
\emph default
 und 
\emph on
real_empty_info
\emph default
 und blendet anschließend 
\emph on
real_main_info
\emph default
 im Bereich der Hauptinfopage als globale, für den benutzer nicht beschreibbare
 Speicherseite ein.
 Ebenfalls wird die Infopage auf einige initiale Informationswerte gesetzt,
 die Auskunft über die CPU, Speichergröße etc.
 geben.
 Hier ist zu beachten, dass bestimmte plattformspezifische Werte (z.B.
 CPU-Typ, Speichergröße etc.) deshalb schon vor dem Aufruf von 
\emph on
kinfo_init
\emph default
 initialisiert werden müssen.
\end_layout

\begin_layout Standard
Ferner initialisiert die Funktion die Prozess- und Thread-Tabelle, indem
 sie jede virtuelle Seite des Tabelle auf den physischen Seitenrahmen 
\emph on
real_empty_info
\emph default
 verweisen lässt (wobei der TLB natürlich ebenfalls invalidiert wird).
\end_layout

\begin_layout Subsection
Die Makros der Hauptinfopage
\end_layout

\begin_layout Standard
Die für den Zugriff auf die Hauptinfopae verwendeten Makros haben derzeit
 folgende Bedeutung (siehe auch 
\begin_inset LatexCommand \ref{sub:Die-Hauptinfopage}

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="21" columns="2">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="8cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="8cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Makro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Bedeutung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_CURRENT_PROCESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SID des aktuellen Prozesses.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_CURRENT_THREAD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SID des aktuellen Threads.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_PROC_TABLE_ENTRY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zeiger auf den aktuellen Prozesstabelleneintrag (absolute virtuelle Adresse).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_THRD_TABLE_ENTRY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zeiger auf den aktuellen Threadtabelleneintrag (absolute virtuelle Adresse).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_KERNEL_MAJOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Hauptversion des Kernels.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_KERNEL_MINOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nebenversion des Kernels.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_KERNEL_REVISION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Revisionsnummer des Kernels.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_RTC_COUNTER_LOW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zeit-Zähler des Kernels seit Systemstart (niederwertige 32-bit).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_RTC_COUNTER_HIGH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zeit-Zähler des Kernels seit Systemstart (höherwertige 32-bit).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_CPU_ID_CODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
HydrixOS CPU-Identifikationsnummer.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_PAGE_SIZE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Größe einer Speicherseite auf diesem System.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_MAX_PAGE_OPERATION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Maximale Größe (in Seiten) einer Speicheroperation auf diesem System.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_X86_CPU_NAME_PART_1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Erster Teil des CPU-Namens (x86-Spezifisch)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_X86_CPU_NAME_PART_2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zweiter Teil des CPU-Namens (x86-Spezifisch)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_X86_CPU_NAME_PART_3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Dritter Teil des CPU-Namens (x86-Spezifisch)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_X86_CPU_TYPE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CPU-Typ (x86-Spezifisch, siehe 
\emph on
CPUID
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_X86_CPU_FAMILY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CPU-Familie (x86-Spezifisch, siehe 
\emph on
CPUID
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_X86_CPU_MODEL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CPU-Modell (x86-Spezifisch, siehe 
\emph on
CPUID
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_X86_CPU_STEPPING
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CPU-Stepping (x86-Spezifisch, siehe 
\emph on
CPUID
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
MAININFO_X86_RAM_SIZE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Größe des RAMs in Byte.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Die Makros der Prozesstabelle
\end_layout

\begin_layout Standard
Die für den Zugriff auf die Prozesstabelle verwendeten Makros haben derzeit
 folgende Bedeutung (siehe auch 
\begin_inset LatexCommand \ref{sub:Die-Prozesstabelle}

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="2">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="8cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="8cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Makro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Bedeutung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_IS_USED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Gibt an, ob der Deskriptor derzeit verwendet wird oder nicht.
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_IS_DEFUNCT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Gibt an, ob der Prozess durch
\emph on
 destroy_subject
\emph default
 inaktiviert wurde.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SID des Threads.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_CONTROLLER_THREAD_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SID des Kontroller-Threads des Threads.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_CONTROLLER_THREAD_DESCR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zeiger auf den Deskriptor des Kontroller-Threads.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_PAGE_COUNT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Anzahl der vom Prozess verwendeten Speicherseiten.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_IO_ACCESS_RIGHTS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
I/O-Zugriffsrechte des Threads (siehe 
\emph on
io_allow
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_PAGEDIR_PHYSICAL_ADDR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Physikalische Adresse des Seitenverzeichnisses des Prozesses.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_IS_ROOT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Gibt an, ob der Prozess ein Root-Prozess ist (1) oder nicht (0).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_IS_PAGED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Gibt an, ob der Prozess der Paging-Dämon ist (1) oder nicht (0).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_THREAD_COUNT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Anzahl der Threads des Prozesses
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_THREAD_LIST_BEGIN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Erster Thread in der Thread-Liste des Prozesses.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_UNIQUE_ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Eindeutige Prozesskennung (32-bit-Zahl)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
PRCTAB_X86_MMTABLE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Anfang der im Deskriptor enthaltenen Speicherverwaltungstabelle des Prozesses
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Die Makros der Threadtabelle
\end_layout

\begin_layout Standard
Die für den Zugriff auf die Threadtabelle verwendeten Makros haben derzeit
 folgende Bedeutung (siehe auch 
\begin_inset LatexCommand \ref{sub:Die-Thread-Tabelle}

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="42" columns="2">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="8cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="8cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Makro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Bedeutung
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_IS_USED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Gibt an, ob der Deskriptor derzeit verwendet wird oder nicht.
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SID des Threads.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_PROCESS_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SID des Dachprozesses.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_SYNC_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SID der aktuellen 
\emph on
sync
\emph default
-Operation.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_MEMORY_OP_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Von 
\emph on
allow
\emph default
 freigegebene SID für Mapping-Operationen.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_MEMORY_OP_DESTADR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Von 
\emph on
allow
\emph default
 freigegebene Zieladresse für Mapping-Operationen.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_MEMORY_OP_MAXSIZE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Von 
\emph on
allow
\emph default
 angegebene Größe (in Seiten) des Zielbereichs für Mapping-Operationen.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_MEMORY_OP_ALLOWED
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Von 
\emph on
allow
\emph default
 freigegebene Mapping-Operationen.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_KERNEL_STACK_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Adresse des Kernel-Stacks relativ zum Kernel-Adressraum.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_PROCESS_DESCR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Direkter Zeiger zum Prozess-Deskriptor (relativ zum Kernel-Adressraum)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_THRSTAT_FLAGS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zustandsinformationen des Threads.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_IRQ_RECV_NUMBER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Von 
\emph on
recv_irq
\emph default
 angefragter IRQ.
 0xFFFFFFFF = 
\emph on
kein Thread
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_FREEZE_COUNTER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zähler, der angibt, wie viele 
\emph on
freeze_subject
\emph default
 Operationen auf diesen Thread angewandt wurden.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_RUNQUEUE_PREV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vorgänger des Threads in der Runqueue (
\emph on
NULL
\emph default
, wenn am Anfang oder - wenn 
\emph on
NEXT
\emph default
 gleich 
\emph on
NULL -
\emph default
 außerhalb der Runqueue).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_RUNQUEUE_NEXT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Auf diesen Thread folgender Thread in der Runqueue (
\emph on
NULL
\emph default
, wenn am Ende oder - wenn PREV
\emph on
 
\emph default
gleich 
\emph on
NULL
\emph default
 - außerhalb der Runqueue).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_SOFTINT_LISTENER_SID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Thread der die Software-Interrupts dieses Threads mittels 
\emph on
recv_softint
\emph default
 derzeit abhört.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_EFFECTIVE_PRIORITY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Effektive Priorität des Threads (plattformspezifischer Wert).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_STATIC_PRIORITY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Statische Priorität des Threads.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_SCHEDULING_CLASS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Scheduling-Klasse des Threads
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_TIMEOUT_LOW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zeitpunkt, an dem eine Timeout-behaftete Operation abgebrochen werden soll
 (niederwertige 32-Bit).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_TIMEOUT_HIGH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Zeitpunkt, an dem eine Timeout-behaftete Operation abgebrochen werden soll
 (höherwertige 32-Bit).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_LAST_EXCPT_NUMBER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Plattformunabhängige Nummer der letzten unbehandelten Exception, die in
 diesem Thread aufgetreten ist.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_LAST_EXCPT_NR_PLATTFORM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Plattformspezifische Nummer der letzten unbehandelten Exception, die in
 diesem Thread aufgetreten ist.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_LAST_EXCPT_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Adresse der letzten unbehandelten Exception, die in diesem Thread aufgetreten
 ist.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_LAST_EXCPT_ERROR_CODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Plattformspezifischer Fehler-Code der letzten unbehandelten Exception, die
 in diesem Thread aufgetreten ist.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_PAGEFAULT_DESCRIPTOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Page-Deskriptor des letzten unbehandelten Seitenfehlers, der in diesem Thread
 aufgetreten ist.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_PAGEFAULT_LINEAR_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Lineare Adresse des letzten unbehandelten Seitenfehlers, der in diesem Thread
 aufgetreten ist.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_PREV_THREAD_OF_PROC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vorgehendes Mitglied der Liste der Threads des Dachprozesses (
\emph on
NULL = Listenende
\emph default
).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_NEXT_THREAD_OF_PROC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nachfolgendes Mitglied der Liste der Threads des Dachprozesses (
\emph on
NULL = Listenende
\emph default
).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_RECEIVED_SOFTINT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Mittels 
\emph on
recv_softint
\emph default
 zuletzt empfangener Software-Interrupt.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_RECV_LISTEN_TO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SID des Threads, dessen Software-Interrupts derzeit mittels 
\emph on
recv_softints
\emph default
 abgehört werden.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_CUR_SYNC_QUEUE_PREV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vorheriges Mitglied in der Sync-Warteschlange eines Threads, auf den derzeit
 mittels 
\emph on
sync
\emph default
 gewartet wird (
\emph on
NULL 
\emph default
= Erstes Mitglied der Schleife).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_CUR_SYNC_QUEUE_NEXT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nächstes Mitglied in der Sync-Warteschlange eines Threads, auf den derzeit
 mittels 
\emph on
sync
\emph default
 gewartet wird (
\emph on
NULL 
\emph default
= Letztes Mitglied der Schleife).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_OWN_SYNC_QUEUE_BEGIN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Erstes Mitglied der eigenen Sync-Warteschlange.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_TIMEOUT_QUEUE_PREV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vorheriges Mitglied der Timeout-Warteschlange, falls Timeout gesetzt ist
 (
\emph on
NULL
\emph default
 = erstes Mitglied).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_TIMEOUT_QUEUE_NEXT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nächstes Mitglied der Timeout-Warteschlange, falls Timeout gesetzt ist (
\emph on
NULL
\emph default
 = letztes Mitglied).
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_UNIQUE_ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Eindeutige Threadkennung (32-bit-Zahl)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_X86_KERNEL_POINTER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Stack-Pointer des Kernel-Stacks
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_X86_TLS_PHYS_ADDRESS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Physikalische Adresse des Seitenrahmens, der den 
\emph on
Thread local storage
\emph default
 enthält.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_X86_FPU_STACK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Anfang des 512 Byte großen Bereichs im Deskriptor, in den der aktuelle FPU
 / MMX (etc.)-Zustand gespeichert werden soll.
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
THRTAB_LOCAL_STORAGE_BEGIN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Anfang des 
\emph on
Thread local storage
\emph default
.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Threadverwaltung
\end_layout

\begin_layout Subsection
Kernel-Stacks
\end_layout

\begin_layout Subsubsection
Aufbau eines Kernel-Stacks
\begin_inset LatexCommand \label{sub:Aufbau-eines-Kernel-Stacks}

\end_inset


\end_layout

\begin_layout Standard
Eine weitere wichtige Datenstruktur des Kernels sind die sog.
 Kernel-Stacks.
 Jeder Thread besitzt neben seinem normalen User-Mode-Stack, auf den der
 Benutzer-Code des Threads ohne weiteres zugreifen kann, einen Kernel-Mode-Stack
, der vor allen Zugriffen aus dem Benutzermodus geschützt ist.
 
\end_layout

\begin_layout Standard
Immer dann, wenn ein Thread in den Kernel-Modus wechselt, wird mittels einer
 speziellen Fähigkeit der x86-Architektur der Stackpointer auf einen vom
 Kernel festgelegten Kernel-Mode-Stack gewechselt, um anschließend darauf
 den aktuellen Benutzermodus-Zustand (Registerinhalte, Programmzeiger etc.)
 des unterbrochenen Threads zu speichern.
 Ferner wird der Kernel-Stack innerhalb des Kernel-Codes als regulärer Stack
 verwendet.
\end_layout

\begin_layout Standard
Ein Kernel-Stack ist genau eine Speicherseite (also 4 KiB) groß.
 Die letzten 68 Byte
\begin_inset Foot
status collapsed

\begin_layout Standard
Dies ergibt sich aus der Tatsache, dass es sich um einen Stack handelt,
 der nach dem LIFO-Prinzip arbeitet.
 Wenn ein Prozess aus dem Benutzer-Modus in den Kernel-Modus wechselt, ist
 der zugehörige Stackpointer auf die oberste Adresse des Stacks gerichtet.
 Beim Ablegen von Daten wird der Stackpointer dekrementiert und die Daten
 in abwärtiger Richtung auf dem Stack gespeichert.
\end_layout

\end_inset

 enthalten (derzeit) stets den aktuellen CPU-Zustand (abgesehen des FPU-Stack
 / der XMM-Register etc.).
 Wobei der Aufbau dieser 68 Byte derzeit wie folgt ist:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="3">
<features islongtable="true">
<column alignment="block" valignment="top" leftline="true" width="3cm">
<column alignment="block" valignment="top" leftline="true" width="3cm">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="8cm">
<row topline="true" bottomline="true" endhead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
DWord ab Blockbeginn
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Register
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Anmerkungen
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EDI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ESI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EBP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(Ungenutzt)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\emph on
Siehe x86-Handbuch: PUSHA
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EBX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EDX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ECX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EAX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
GS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
GS-Datensegment im Benutzer-Modus (
\emph on
DS_USER
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
FS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
FS-Datensegment im Benutzer-Modus (
\emph on
DS_USER
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ES-Datensegment im Benutzer-Modus (
\emph on
DS_USER
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DS-Datensegment im Benutzer-Modus (
\emph on
DS_USER
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EIP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Programm-Zeiger im Benutzer-Modus (
\emph on
DS_USER
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Codesegment im Benutzer-Modus (
\emph on
CS_USER
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EFLAGS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Flag-Register
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ESP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Stack-Zeiger des Benutzer-Stacks
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
SS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Stacksegment im Benutzer-Modus (
\emph on
DS_USER
\emph default
)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Verwaltung von Kernel-Stacks
\end_layout

\begin_layout Standard
Zur Einrichtung und Vernichtung von neuen Kernel-Stacks existieren die Funktione
n 
\emph on
ksched_new_stack
\emph default
 (
\emph on
frame.c
\emph default
; 
\emph on
sched.h
\emph default
) und 
\emph on
ksched_del_stack 
\emph default
(
\emph on
frame.c
\emph default
; 
\emph on
sched.h
\emph default
).
 Diese Funktionen rufen derzeit lediglich die normalen Speicherverwaltungsroutin
en zur Allokation bzw.
 Freigabe einer Kernel-Seite auf.
\end_layout

\begin_layout Standard
Neben diesen reinen Verwaltungsfunktion existiert noch eine Funktion zur
 Initialisierung eines Kernel-Stacks 
\emph on
ksched_init_stack
\emph default
 (
\emph on
frame.c
\emph default
; 
\emph on
sched.h
\emph default
).
 Diese Funktion initialisiert einen neuen Kernel-Stack.
 Sie setzt dabei den Code-Zeiger für den Betrieb im Benutzermodus des neuen
 Threads an dessen gewünschte Anfangsadresse.
 setzt im EFLAGS-Register das Interrupt-Flag, so dass mit dem neuen Thread
 die IRQs aktiv werden.
 Den Code- und Daten-Segmenten werden die verschiedenen Standard-Segmente
 zugewiesen.
 Als Rückgabewert liefert die Funktion einen Stack-Zeiger.
 Die Funktion kann wahlweise auch Stacks für Threads erstellen, die gleich
 von Anfang an im Kernel operieren und nicht sofort in den Benutzermodus
 wechseln.
 
\end_layout

\begin_layout Standard
Dazu muss der Parameter 
\emph on
mode
\emph default
 der Funktion auf 
\emph on
KSCHED_KERNEL_MODE
\emph default
 gesetzt werden.
 Hierbei werden die jeweiligen Segmentdeskriptoren auf Kernel-Segmente gesetzt.
 Außerdem wird kein Stacksegment für den Kernel eingerichtet, da die 
\emph on
IRET
\emph default
-Instruktion, die zur Rückkehr von Interrupts eingesetzt wird, bei einer
 Rückkehr eines Programms in den gleichen Betriebsmodus (Kernel-Mode nach
 Kernel-Mode) keine Angaben über den Stack erwartet.
 
\end_layout

\begin_layout Standard
Soll eine Rückkehr in den Benutzermodus beim Ersten Start des Threads erreicht
 werden, ist der Parameter 
\emph on
mode
\emph default
 auf 
\emph on
KSCHED_USER_MODE
\emph default
 zu setzen.
 Derzeit wird 
\emph on
KSCHED_KERNEL_MODE
\emph default
 nur bei der Erzeugung des 
\emph on
idle
\emph default
-Threads verwendet, da dieser im Kernel-Code enthalten ist (dies wird später
 noch einmal genauer erläutert).
\end_layout

\begin_layout Subsection
Erzeugung von Threads
\end_layout

\begin_layout Standard
Für die Erzeugung neuer Threads ist die interne Funktion 
\emph on
ksubj_create_thread
\emph default
 (
\emph on
subject.c
\emph default
) zuständig.
 Diese Funktion wird von den Systemaufrufen zur Thread- und Prozesserzeugung
 verwendet und konfiguriert einen neuen Thread nur so, dass er für beide
 Arten von Threaderzeugung weiterverwendet werden kann.
\end_layout

\begin_layout Standard
Die Suche nach einer freien Thread-SID erfolgt derzeit einfach dadurch,
 dass die Thread-Tabelle nach leeren Deskriptoren durchsucht wird.
 Wurde ein inaktiver Deskriptor gefunden, wird die SID des Deskriptors errechnet
 und über 
\emph on
kinfo_new_descr
\emph default
 (
\emph on
info.c
\emph default
; 
\emph on
info.h
\emph default
) ein neuer Deskriptor erzeugt.
 Der Rückgabewert von 
\emph on
kinfo_new_descr
\emph default
 gibt, wie bereits erwähnt, die physikalische Adresse des letzten Seitenrahmens
 zurück.
 Da dieser Seitenrahmen für den 
\emph on
Thread local storage
\emph default
 des neuen Threads verwendet werden soll, wird diese Adresse im 
\emph on
THRTAB_X86_TLS_PHYS_ADDR
\emph default
-Feld des Deskriptors gespeichert.
 Anschließend wird ein neuer Kernel-Stack mittels 
\emph on
ksched_new_stack
\emph default
 erstellt und im weiteren Verlauf durch 
\emph on
ksched_init_stack
\emph default
 (
\emph on
frame.c; sched
\emph default
.
\emph on
h
\emph default
) mit
\emph on
 KSCHED_USER_MODE
\emph default
 als Benutzer-Modus-Thread initialisiert.
\end_layout

\begin_layout Standard
Der neue Thread liegt nach dem Aufruf noch nicht in der Ausführungswarteschlange
 des Schedulers vor und gehört dem aktuellen Prozess.
 Er ist allerdings noch nicht in die Liste der Threads des Prozesses eingereiht
 worden.
 Nun ist es Aufgabe der verschiedenen Systemaufrufe, den Thread weiter zu
 initialisieren.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
create_thread
\end_layout

\begin_layout Standard
Die Implementierung des Systemaufrufs 
\emph on
create_thread
\emph default
 - die Funktion 
\emph on
sysc_create_thread
\emph default
 (
\emph on
subject.c
\emph default
; 
\emph on
sysc.h
\emph default
) baut im wesentlichen auf 
\emph on
ksubj_create_thraed
\emph default
 (
\emph on
subject.c
\emph default
) auf und führt nach Erstellung des Threads durch diese nur noch weitere
 Schritte zur Initialisierung des Threads als weiteren Thread des aktuellen
 Prozesses durch.
 So wird u.a.
 der neue Thread in die Thread-Liste des aktuellen Prozesses eingereiht.
\end_layout

\begin_layout Subsection
Vernichtung von Threads
\begin_inset LatexCommand \label{sub:Vernichtung-von-Threads}

\end_inset


\end_layout

\begin_layout Standard
Da innerhalb des Kernels keine interne Verwendung für die Vernichtung von
 Threads besteht, ist die dafür zuständige Routine direkt in den Systemaufruf
 
\emph on
sysc_destroy_subject
\emph default
 (
\emph on
subject.c
\emph default
; 
\emph on
sysc.h
\emph default
) implementiert.
 Da diese Funktion auch für die Blockade von Prozessen zuständig ist, liegt
 der Abschnitt zur Vernichtung von Thread-Subjects in folgendem If-Block:
\end_layout

\begin_layout LyX-Code
if ((sid & SIDTYPE_THREAD) == SIDTYPE_THREAD)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
...
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Nachdem die verschiedenen Ausführungsvoraussetzungen geprüft wurden (Gültiger
 Thread; Thread ist nicht aktueller Thread;), wird der Thread aus der Run-Queue
 und der Thread-Liste seines Prozesses entfernt.
 Anschließend werden Threads aufgeweckt, die versucht haben, eine 
\emph on
sync
\emph default
-Operation auszuführen.
 Hat der Thread selbst derzeit eine 
\emph on
sync
\emph default
-Operation durchgeführt, so wird er aus der Liste des Zielthreads der 
\emph on
sync
\emph default
-Operation entfernt
\begin_inset Foot
status collapsed

\begin_layout Standard
Zu den verschiedenen Operationen, bei denen Threads sich mit dem zu zerstörenden
 Threads synchronisieren oder dieser sich mit anderen synchronisiert (
\emph on
sync
\emph default
, 
\emph on
recv_softints
\emph default
), wird zum besseren Verständnis die Dokumentation der jeweiligen Mechanismen
 empfohlen (u.a.
 für die Funktionen 
\emph on
ksync_interrupt_other
\emph default
 und 
\emph on
ksync_remove_from_waitqueue
\emph default
, so wie die verschiedenen Timeout-Operationen).
\end_layout

\end_inset

.
 Ist der Thread der letzte Thread des Prozesses wird er im Anschluß durch
 Aufruf der Funktion 
\emph on
ksubj_kill_proc
\emph default
 (
\emph on
subject.c
\emph default
) ebenfalls beendet.
 Sein Kernel-Stack wird durch 
\emph on
ksched_del_stack
\emph default
 (
\emph on
frame.c
\emph default
; 
\emph on
sched.h
\emph default
) freigegeben.
 Hat der Thread zuvor auf eingehende IRQs gewartet, so wird der IRQ mittels
 
\emph on
kio_renable_irq
\emph default
 (
\emph on
io.c
\emph default
; 
\emph on
sched.h
\emph default
) wieder freigegeben.
 Threads, die Software Interrupts des aktuellen Threads abgreifen, werden
 daraufhin ebenfalls gestartet.
 Gleichermaßen wird der Zugriff auf Threads, deren Software Interrupts durch
 den zu zerstörenden Thread abgehört werden, aufgehoben.
 Schließlich wird der Thread-Deskriptor durch 
\emph on
kinfo_del_descr
\emph default
 (
\emph on
info.c
\emph default
; 
\emph on
info.h
\emph default
) freigegeben.
\end_layout

\begin_layout Section
Prozessverwaltung
\end_layout

\begin_layout Subsection
Erzeugen von Prozessen
\end_layout

\begin_layout Standard
Der Kernel hat keinen Bedarf für eine interne Funktion zur Erzeugung von
 Prozessen.
 Die Erzeugung von Prozessen wird daher vollständig von der Behandlungsroutine
 des Systemaufruf 
\emph on
create_process
\emph default
, 
\emph on
sysc_create_process 
\emph default
(
\emph on
subject.c
\emph default
, 
\emph on
sysc.h
\emph default
) übernommen.
 
\end_layout

\begin_layout Standard
Als erstes wird von dieser Funktion ein neuer Deskriptor ermittelt, indem
 einfach in einer Schleife nach dem nächsten freien Deskriptor gesucht wird.
 Der neue virtuelle Adressraum des Prozesses wird über 
\emph on
kmem_create_space
\emph default
 (
\emph on
page.c
\emph default
, 
\emph on
mem.h
\emph default
, siehe 
\begin_inset LatexCommand \ref{sub:Erzeugung-und-Vernichtung}

\end_inset

) erzeugt.
 Der neue Deskriptor wird über 
\emph on
kinfo_new_descr
\emph default
 (
\emph on
info.c
\emph default
, 
\emph on
info.h
\emph default
) erzeugt.
 
\end_layout

\begin_layout Standard
Gemäß den Spezifikationen wird ein initaler Thread erzeugt.
 Dies geschiet über 
\emph on
ksubj_create_thread 
\emph default
(
\emph on
subject.c
\emph default
).
 Der neue Thread erlaubt dem Prozess, der den Aufruf 
\emph on
create_process
\emph default
 gestartet hat, Speicherseiten einzublenden.
 Der neue Thread ist zudem nach dem Start vorerst noch eingefrohren und
 muss mit 
\emph on
awake_subject
\emph default
 reaktiviert werden.
 Der neue Thread wird als Controller-Thread des neuen Prozesses festgelegt.
\end_layout

\begin_layout Standard
Ist der Erzeguerprozess ein Root-Prozess, so werden die Root-Rechte weitervererb
t.
\end_layout

\begin_layout Subsection
Stoppen von Prozessen
\end_layout

\begin_layout Standard
Ein Prozess kann über den Aufruf 
\emph on
destroy_subject
\emph default
 durch den Paging-Dämon blockiert werden, so dass keiner seiner Threads
 wieder aktiv werden kann, um anschließend jeden Thread des Prozesses einzeln
 mit 
\emph on
destroy_subject
\emph default
 beenden zu können.
 Die Implementierung von 
\emph on
destroy_subject
\emph default
 ist in 
\emph on
sysc_destroy_subject
\emph default
 (
\emph on
subject.c
\emph default
, 
\emph on
sysc.h
\emph default
) enthalten.
 Da diese Funktion ebenfalls für die Vernichtung von Threads zuständig ist,
 ist der für Prozesse zuständige Teil in folgendem If-Block enthalten:
\end_layout

\begin_layout LyX-Code
if ((sid & SIDTYPE_PROCESS) == SIDTYPE_PROCESS)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
...
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In diesem Block wird im wesentlichen der Prozess durch das Flag 
\emph on
PRCTAB_IS_DEFUNCT
\emph default
 als suspendiert gemeldet.
 Ebenfalls werden alle Threads des Prozesses aus der Runqueue entfernt.
\end_layout

\begin_layout Subsection
Vernichten von Prozessen
\end_layout

\begin_layout Standard
Ein Prozess wird immer dann vernichtet, wenn sein letzter Thread vernichtet
 wird.
 Dies geschiet in der Funktion 
\emph on
sysc_destroy_subject
\emph default
 (
\emph on
subject.c
\emph default
, 
\emph on
sysc.h
\emph default
) in folgendem If-Block, der dem Routinenteil zur Threadvernichtung untergeordne
t ist 
\begin_inset LatexCommand \ref{sub:Vernichtung-von-Threads}

\end_inset

:
\end_layout

\begin_layout LyX-Code
/* Decrement the thread counter of the process */
\end_layout

\begin_layout LyX-Code
l__process[PRCTAB_THREAD_COUNT] --;             
\end_layout

\begin_layout LyX-Code
                
\end_layout

\begin_layout LyX-Code
/* Last thread? Kill the process, too.
 */
\end_layout

\begin_layout LyX-Code
if (l__process[PRCTAB_THREAD_COUNT] == 0)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
ksubj_kill_proc(l__process);
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Der Aufruf 
\emph on
ksubj_kill_proc
\emph default
 (
\emph on
subject.c
\emph default
) ist also für die Vernichtung von Prozessen zuständig und wird gestartet,
 wenn der Thread-Counter des Prozesses 0 erreicht hat.
 Der Unteraufruf gibt im wesentlichen anhand der Speicherverwaltungstabelle
 des Prozesses die Seitentabellen des Prozesses wieder frei und zerstört
 den Adressraum über 
\emph on
kmem_destroy_space
\emph default
 (
\emph on
page.c
\emph default
, 
\emph on
mem.h
\emph default
, siehe 
\begin_inset LatexCommand \ref{sub:Erzeugung-und-Vernichtung}

\end_inset

).
 Ebenfalls wird der Deskriptor über 
\emph on
kinfo_del_descr
\emph default
 (
\emph on
info.c
\emph default
,
\emph on
 info.h
\emph default
) freigegeben.
\end_layout

\begin_layout Subsection
Ändern des Controller-Threads
\end_layout

\begin_layout Standard
Der Controller-Thread eines Prozesses wird durch den Systemaufruf 
\emph on
set_controller
\emph default
, implementiert durch 
\emph on
sysc_set_controller
\emph default
 (
\emph on
subject.c
\emph default
, 
\emph on
sysc.h
\emph default
), geändert.
 Der Aufruf prüft lediglich ob der Aufrufer die nötigen Zugriffsrechte auf
 den Zielthread hat und ändert anschließend den Prozesstabellen-Eintrag
 
\emph on
PRCTAB_CONTROLLER_THREAD_SID
\emph default
 und 
\emph on
PRCTAB_CONTROLLER_THREAD_DESCR
\emph default
 des Prozessdeskriptors entsprechend.
\end_layout

\begin_layout Subsection
Root-Mitgliedschaft ändern
\end_layout

\begin_layout Standard
Der Systemaufruf zum Vergeben oder Aufgeben der Root-Rechte 
\emph on
chg_root
\emph default
 wird durch die Routine 
\emph on
sysc_chg_root
\emph default
 (
\emph on
security.c
\emph default
, 
\emph on
sys.h
\emph default
) implementiert.
 Zu diesem Systemaufruf ist nichts weiteres zu erwähnen.
 Er überprüft die Zugriffsrechte, ändern anschließend den Eintrag 
\emph on
PRCTAB_IS_ROOT
\emph default
 entsprechend der Aufrufparameter und passt die IO-Zugriffsrechte des Prozesses
 entsprechend an.
\end_layout

\begin_layout Chapter
Die Ausführungsschicht
\end_layout

\begin_layout Section
Kernel-Eintritt
\end_layout

\begin_layout Standard
Immer wenn ein Thread einen Systemaufruf tätigt, durch einen IRQ unterbrochen
 wird, einen ungültigen Software-Interrupt auslöst oder eine Exception verursach
t, findet ein Wechsel vom Benutzer-Modus in den Kernel-Modus statt.
 Für jede dieser vier Möglichkeiten existieren im Kernel unterschliedliche
 Kernel-Eintrittsverfahren, die nun in diesem Abschnitt näher beleuchtet
 werden, wobei in diesem Abschnitt nur der Einsprung selber erläutert wird,
 nicht die Aktion, für die der Thread eigentlich in den Kernel gewechselt
 hat.
 
\end_layout

\begin_layout Standard
Die Kernel-Einsprungspunkte für IRQs, Exceptions und ungültige Software-Interrup
ts sind in der Datei 
\emph on
irq.s
\emph default
 definiert.
 Die Kernel-Einsprungspunkte für Systemaufrufe in der Datei 
\emph on
sysc.s
\emph default
, da für jeden Systemaufruf ein eigener Einsprungscode verwendet wird.
\end_layout

\begin_layout Subsection
Die Zugriffsmodi der x86-Architektur
\end_layout

\begin_layout Standard
Die x86-Architektur verfügt im Protected Mode über vier verschiedene Betriebsmod
i, die auch als 
\begin_inset Quotes gld
\end_inset

Ring
\begin_inset Quotes grd
\end_inset

 bezeichnet werden.
 Davon sind die ersten drei Betriebsmodi (Ring 0 bis 2) für das Betriebssystem
 und der letzte Betriebsmodus (Ring 3) für Anwendungsprogramme gedacht.
 Je nach Betriebsmodus der CPU sind verschiedene Zugriffe und Instruktionen
 erlaubt oder verboten, wobei im Ring-0-Modus maximale Zugriffsrechte bestehen.
 Der 
\emph on
hymk
\emph default
 verwendet derzeit nur Ring 0 (Kernel-Modus) und Ring 3 (Benutzer-Modus).
 
\end_layout

\begin_layout Subsection
Die Interrupt Descriptor Table
\end_layout

\begin_layout Standard
Soll von einem Modus zum anderen gewechselt werden, so ist dies nur über
 Far-Jumps, Interrupts und sog.
 Call-Gate-Deskriptoren möglich, wobei der 
\emph on
hymk
\emph default
 nur Wechsel über Interrupts (IRQs, Software-Interrupts/Systemaufrufe, Exception
s) gestattet.
 Für jeden Interrupt ist hierbei in der sog.
 Interrupt Deskriptor Table - die IDT - (definiert durch 
\emph on
i386_idt_s
\emph default
 in 
\emph on
start.s
\emph default
) ein sog.
 Interrupt-Gate-Deskriptor (siehe 
\emph on
idt_t
\emph default
 in 
\emph on
sched.h
\emph default
) abgelegt.
 
\end_layout

\begin_layout Standard
In dieser Tabelle sind gemäß den IA-32-Spezifikationen die ersten 32 Interrupts
 für die Exceptions belegt.
 Der 
\emph on
hymk
\emph default
 belegt außerdem für die IRQs die Interrupts 
\emph on
0xA0
\emph default
 - 
\emph on
0xAF
\emph default
 und für die Systemaufrufe die Interrupts 
\emph on
0xC0 - 0xD5
\emph default
 (wobei in späteren hymk-Versionen weitere Interrupts belegt werden könnten).
 Alle anderen Software-Interrupts werden nicht verwendet.
 Ihr Aufruf führt zu keiner Aktion.
 Der Aufruf von Exception- und IRQ-Handlern führt zu einer Schutzverletzung
 (es sei denn 
\emph on
recv_softints
\emph default
 wird auf den Thread angewandt), wobei die Breakpoint-Exception, die Overflow-Ex
ception und die Bound-Range-Exceed-Exception (
\emph on
0x3
\emph default
 - 
\emph on
0x5
\emph default
) auch vom Benutzermodus aufgerufen werden können.
\end_layout

\begin_layout Standard
Soll also in den Kernel-Modus gewechselt werden, ist ein Interrupt erforderlich.
 Ein Software-Interrupt wird über die Instruktion 
\emph on
INT
\emph default
 ausgelöst, eine Exception durch einen Fehler/Trap oder die Instruktion
 
\emph on
INTO
\emph default
 (Overflow-Exception), einen IRQ durch ein externes Gerät.
 In jedem Fall lädt der Prozessor den Kernel-Stack und dessen Stacksegment
 anhand zuvor festgelegter Daten (wie später erläutert wird).
 Auf den Kernel-Stack werden dann das im Benutzermodus verwendete Stack-Segment
 (
\emph on
SS
\emph default
) und der zugehörige Stack-Pointer (
\emph on
ESP
\emph default
), die Maschienenflags (
\emph on
EFLAGS
\emph default
), das Code-Segment (
\emph on
CS
\emph default
) und der Programmzeiger (
\emph on
EIP
\emph default
) durch die CPU gespeichert.
 Anschließend wird die in der IDT festgelegte Routine aufgerufen, wobei
 auf Grund des IDT-Eintrags als Code-Segment das Kernel-Codesegment verwendet
 wird.
 
\end_layout

\begin_layout Subsection
Kernel-Einsprung durch IRQs
\begin_inset LatexCommand \label{sub:Kernel-Einsprung-durch-IRQs}

\end_inset


\end_layout

\begin_layout Standard
Für alle IRQs lautet diese Low-Level-Routine 
\emph on
i386_irqhandleasm_0
\emph default
 - 
\emph on
i386_irqhandleasm_15
\emph default
 (
\emph on
irq.s
\emph default
, 
\emph on
sched.h
\emph default
).
 Damit diese Routinen nicht tatsächlich 16 Mal implementiert werden müssen,
 bedient sich der 
\emph on
hymk
\emph default
-Code Assembler-Makros.
 Das für die IRQ-Routinen zuständige Makro heißt 
\emph on
MIRQ
\emph default
.
 Als Parameter erhält es einerseits die Nummer des IRQs.
 Andererseits erhält es auch das Kontroll-Port des zu verwendenden Interrupt-Con
trolers, da alle IRQs ab dem IRQ 8 einen anderen Controler verwenden.
 Die Portnummern sind 
\emph on
0x20
\emph default
 für den Master-Controller und 
\emph on
0xA0
\emph default
 für den Slave-Controller.
\end_layout

\begin_layout Standard
Die Behandlungsroutine selbst sperrt alle IRQs durch das Löschen des Interrupt-F
lags und sichert zuerst die restlichen Segmentregister (
\emph on
DS
\emph default
, 
\emph on
ES
\emph default
, 
\emph on
FS
\emph default
, 
\emph on
GS)
\emph default
, dann die übrigen generellen Register (siehe auch 
\begin_inset LatexCommand \ref{sub:Aufbau-eines-Kernel-Stacks}

\end_inset

).
 Anschließend werden die Datensegmentregister des Kernels geladen.
 Die darauf folgenden Codeabschnitte sind nur noch für die IRQ-Behandlung
 interessant: dort wird die IRQ-Nummer auf den Stack gelegt, die Kernel-Behandlu
ng gestartet und der IRQ als abgearbeitet markiert - die genauen Abläufe
 werden in späteren Abschnitten näher erläutert.
\end_layout

\begin_layout Subsection
Kernel-Einsprung durch Exceptions
\end_layout

\begin_layout Standard
Die Behandlung von Exceptions läuft im wesentlichen ähnlich ab.
 Die Routinen zur Exception-Behandlung heißen 
\emph on
i386_exhandleasm_0
\emph default
 - 
\emph on
i386_exhandleasm_31
\emph default
 (
\emph on
irq.s
\emph default
, 
\emph on
sched.h
\emph default
).
 Auch sie sind über ein Assembler-Makro realisiert.
 Dieses Makro trägt den Namen 
\emph on
MEX
\emph default
.
 Als Parameter erhält das Makro einerseits die Exception-Nummer und andererseits
 den Hinweis darauf, ob die Exception mit einem Fehlercode verbunden ist
 oder nicht.
 Die Routine unterscheidet sich zur IRQ-Routine nur am Anfang.
 Dort wird zuerst der Fehlercode des Systems in verschiedene Puffer gesichert
 (dazu später mehr), bevor der Prozessorstatus auf dem Stack gespeichert
 wird.
 Existiert ein Fehlercode, so wird dieser zuvorls gesichert und vom Stack
 geholt.
 Anschließend wird wie bei einer IRQ-Routine verfahren und darauf die High-Level
-Exceptionbehandlung gestartet.
\end_layout

\begin_layout Subsection
Kernel-Einsprung durch Systemaufrufe
\end_layout

\begin_layout Standard
Auch Systemaufrufe werden ähnlich eingeleitet, allerdings besteht hier für
 jeden Systemaufruf eine eigene Implementierung, die jeweils den Namen des
 Systemaufrufs mit dem Prefix 
\emph on
i386_sysc_
\emph default
 trägt (siehe 
\emph on
start.s
\emph default
, 
\emph on
sysc.h
\emph default
).
 Hier besteht der Unterschied darin, dass der Software-Interrupt an die
 Routine 
\emph on
kremote_received
\emph default
 weitergegeben werden kann, wenn die Umleitung von Software-Interrupts für
 diesen Thread aktiviert ist - bei IRQs und Exceptions geschiet dies in
 einem anderen Codeteil (dies wird später näher erläutert).
 Auch hier wird der CPU-Status auf den Stack geschrieben und anschließend
 die High-Level-Routine (
\emph on
sysc_*
\emph default
) gestartet.
\end_layout

\begin_layout Subsection
Kernel-Einsprung durch unbelegte Software-Interrupts
\end_layout

\begin_layout Standard
Schließlich gibt es noch 187 Software-Interrupts, die weder einem IRQ, noch
 einer Exception, noch einem Systemaufruf zugewiesen sind.
 Diese Software-Interrupts können prinzipiell aus dem Benutzermodus aufgerufen
 werden, führen aber zu keiner Aktion - es sei denn, auf den Thread wurde
 eine Umleitung der Software-Interrupts mittels 
\emph on
recv_softints
\emph default
 angewendet.
 Diese Interrupts dürfen nicht gesperrt sein, da ja u.a.
 bei der Emulation fremder Betriebssysteme deren Systemaufrufe nicht über
 die gleichen Software-Interrupts wie die des 
\emph on
hymk
\emph default
 laufen.
\end_layout

\begin_layout Standard
Die Low-Level-Routine für unbelegte Softwareinterrupts trägt den Namen 
\emph on
i386_emptyint_handler
\emph default
 (
\emph on
irq.s
\emph default
, 
\emph on
sched.h
\emph default
).
 Im Unterschied zu den übrigen Einsprungroutinen, ist dieser Routine nicht
 direkt bekannt, welcher Interrupt Auslöser des Aufrufs war.
 Diese Routine muss - nach der üblichen Sicherung des Prozessorstatus -
 dies selbst herausfinden.
 Da als Quelle nur Software-Interrupts über den 
\emph on
INT
\emph default
-Befehl in Frage kommen, liest die Funktion einfach an der zuletzt ausgeführten
 Adresse im Benutzer-Modus den ein Byte großen Parameter des 
\emph on
INT
\emph default
-Befehls nach.
 Die High-Level-Behandlung (dabei u.a.
 die Weiterleitung an andere Threads, falls 
\emph on
recv_softints
\emph default
 angewendet wurde) erfolgt über die Routine 
\emph on
i386_handle_emptyint
\emph default
 (
\emph on
intr.c
\emph default
, 
\emph on
sched.h
\emph default
).
\end_layout

\begin_layout Section
Kernel-Austritt
\end_layout

\begin_layout Standard
Ist ein Systemaufruf ausgeführt, ein IRQ, eine Exception oder ein unbelegter
 Software-Interrupt behandelt worden, so findet wieder ein Rückwechsel in
 den Benutzer-Modus statt.
 Jenachdem ob und wie der Scheduler zuvor entschieden hat, wird dabei ebenfalls
 ein Threadwechsel durchgeführt.
 In der Regel wird der Kernel-Austritt dadurch eingeleitet, dass die High-Level-
Behandlungsroutine durch 
\emph on
return
\emph default
 wieder zur Low-Level-Routine zurückkehrt.
 Diese führt ggf.
 noch weitere spezifische Anweisungen aus (z.B.
 Speichern des Rückgabewerts eines Systemaufrufs).
 Zur eigentlichen Rückkehr aus dem Systemaufruf kommt es dann durch einen
 Sprung in den Codeabschnitt 
\emph on
i386_do_context_switch
\emph default
 (
\emph on
irq.s
\emph default
)
\begin_inset Foot
status collapsed

\begin_layout Standard
Hier sei angemerkt, dass es sich wirklich um einen Codeabschnitt und nicht
 um eine Unterroutine handelt, da werder Rücksprungadresse noch etwaige
 Parameter auf dem Stack gespeichert werden.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Weitere Wege zum Kernel-Austritt
\end_layout

\begin_layout Standard
Ein weiterer Weg zur Rückkehr aus dem Kernel- in den Benutzer-Modus ist
 die Aufgabe der CPU-Zeit eines Threads während der Ausführung im Kernel
 über den Aufruf 
\emph on
i386_yield_kernel_thread
\emph default
 (
\emph on
irq.s
\emph default
, 
\emph on
current.h
\emph default
), bzw.
 über das darauf aufbauende Makro 
\emph on
SYSCALL_YIELDS_THREAD
\emph default
.
 Dies ist z.B.
 erforderlich, wenn ein Thread während einer 
\emph on
sync
\emph default
-Operation auf die Gegenseite warten muss.
 Diese Yield-Operation sichert den aktuellen Kernel-Zustand auf dem Stack
 und speichert als Rückkehradresse bei erneuter Aktivierung des Threads
 die Funktion 
\emph on
i386_awake_kernel_thread 
\emph default
(
\emph on
irq.s
\emph default
), die durch ein einfaches Return die Rückkehr zur unterbrochenen Kernel-Routine
 einleitet.
\end_layout

\begin_layout Subsection
Die Austrittsroutine
\end_layout

\begin_layout Standard
Der eigentliche Austritt aus dem Kernel-Modus findet also über die Routine
 
\emph on
i386_do_context_switch
\emph default
 (
\emph on
irq.s
\emph default
) statt.
 Wie der Name schon sagt, kann diese Routine zu einem Kontext-Wechsel führen
 (sie muss aber nicht).
 Die Routine kümmert sich effektiv nur um den Wechsel zwischen Kernel- und
 Benutzermodus und ggf.
 um den Wechsel des aktuellen Threads.
 Die Auswahl des neuen Threads und der Wechsel des virtuellen Adressraums
 wird von der Scheduler-Funktion 
\emph on
ksched_next_thread
\emph default
 (
\emph on
current.c
\emph default
, 
\emph on
sched.h
\emph default
) übernommen, die in späteren Abschnitten näher erläutert wird.
\end_layout

\begin_layout Subsubsection
Argumente des Aufrufs
\end_layout

\begin_layout Standard
Da es sich nicht um einen Funktionsaufruf im eigentlichen Sinne handelt,
 werden die Argumente dieser Routine nicht über den Stack, sondern über
 feste Puffer übergeben
\begin_inset Foot
status collapsed

\begin_layout Standard
bei einer SMP-Implementierung des 
\emph on
hymk
\emph default
 muss dies geändert werden.
\end_layout

\end_inset

.
 Diese Puffer sind:
\end_layout

\begin_layout Description
ksched_change_thread Diese Variable gibt an, ob ein Kontext-Wechsel stattfinden
 soll (1) oder nicht (0).
\end_layout

\begin_layout Description
i386_old_stack_pointer Diese Variable ist ein Zeiger auf einen Puffer, in
 den der Stackpointer des Kernel-Stacks des aktuellen Threads gespeichert
 werden soll, wenn ein Thread-Wechsel stattfindet.
 Dieser Puffer selbst ist das Element 
\emph on
THRTAB_X86_KERNEL_POINTER
\emph default
 im Deskriptor des alten, auszutauschenden Threads.
\end_layout

\begin_layout Description
i386_new_stack_pointer Diese Variable ist ein Zeiger auf einen Puffer, der
 den Stackpointer des Kernel-Stacks des Threads enthält, der aktiviert werden
 soll, wenn ein Thread-Wechsel stattfindet.
 Dieser Puffer selbst ist das Element 
\emph on
THRTAB_X86_KERNEL_POINTER
\emph default
 im Deskriptor des neu zu ladenden Threads.
\end_layout

\begin_layout Description
kinfo_io_map Diese Variable ist ein Zeiger auf die IO-Zugriffsrechte des
 zu ladenden Threads (dies ist für das Setzen der Zugriffsrechte auf die
 I/O-Ports wichtig).
 Die IO-Zugriffsrechte stehen im Element 
\emph on
PRCTAB_IO_ACCESS_RIGHTS
\emph default
 im Prozess-Deskriptor des neu zu ladenden Threads.
\end_layout

\begin_layout Description
i386_esp0_ret Diese Variable ist ein Zeiger auf das ESP0-Feld des Kernel-TSS.
 Der Zeiger selbst ist während des Systembetriebs konstant.
 Beim Wechsel aus dem Benutzer-Modus in den Kernel-Modus setzt die CPU den
 Stackpointer auf den Wert des ESP0-Feldes.
 Das ESP0-Feld wird von 
\emph on
i386_do_context_switch
\emph default
 auf die Kernel-Stackadresse gesetzt, bei der der Kernel in den Benutzermodus
 gewechselt hat.
\end_layout

\begin_layout Subsubsection
Ablauf des Austritts
\end_layout

\begin_layout Standard
Als erstes wird von 
\emph on
i386_do_context_switch
\emph default
 über den Wert der Variable 
\emph on
ksched_change_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) geprüft, ob ein Threadwechsel stattfinden soll.
 Soll kein Wechsel stattfinden, wird direkt zur eigentlichen Rückkehrroutine
 
\emph on
i386_do_context_switch_ret
\emph default
 gewechselt.
 Andernfalls wird mit dem Threadwechsel begonnen.
 Zuerst wird 
\emph on
ksched_change_thread
\emph default
 wieder auf 0 zurückgesetzt, so dass die Variable nach Abschluß der Routine
 keinen undefinierten Wert hat.
 Anschließend wird der Kernel-Stackzeiger des auszutauschenden Thread über
 den Zeiger 
\emph on
i386_old_stack_pointer 
\emph default
(
\emph on
irq.s
\emph default
, 
\emph on
sched.h
\emph default
) in dessen Deskriptor gespeichert, so dass bei späterem Aufruf des Threads
 wieder der korrekte Kernel-Stack geladen werden kann.
 Aus dem Puffer, auf den 
\emph on
i386_new_stack_pointer
\emph default
 (
\emph on
irq.s
\emph default
, 
\emph on
sched.h
\emph default
) zeigt, wird anschließend der Kernel-Stackzeiger des neuen Threads geladen.
 Anschließend ist prinzipiell der für den Threadwechsel spezifische Teil
 getan.
\end_layout

\begin_layout Standard
Nun wird der Rückkehrzeiger für den Kernel-Stack im TSS-Segment (
\emph on
ESP0
\emph default
) über den Zeiger 
\emph on
i386_esp0_ret
\emph default
 (
\emph on
irq.s
\emph default
, 
\emph on
sched.h
\emph default
) auf den Wert des neuen Stackpointers gesetzt.
 Wenn ein Interrupt auftritt, wird die CPU genau diesen Zeiger als Stackzeiger
 des Kernel-Modus-Stacks verwenden.
 
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{Ist-im-IO-Zugriffsfeld}

\end_inset

Ist im IO-Zugriffsfeld des neuen Prozesses das Flag 
\emph on
IO_ALLOW_PORTS
\emph default
 gesetzt, was anhand von 
\emph on
kinfo_io_map
\emph default
 (
\emph on
info.c
\emph default
, 
\emph on
info.h
\emph default
) geprüft wird, wird das sog.
 IOPL (I/O priviledge level) der CPU auf 3 gesetzt, wodurch der nun startende
 Ring-3-Code Zugriff auf die I/O-Ports erhält.
 Andernfalls wird das IOPL auf 0 gesetzt und somit der Zugriff auf die Ports
 gesperrt.
\end_layout

\begin_layout Standard
Schließlich folgt der Abschnitt 
\emph on
i386_do_context_switch_lastret
\emph default
 der nun die eigentliche Rückkehr ausführt.
 Es werden zuerst die auf dem Kernel-Stack beim Kernel-Eintritt gespeicherten
 Register vom Stack geladen und anschließend durch ein 
\emph on
IRET
\emph default
 von der CPU eine Rückkehr in den Benutzermodus anhand der auf dem Kernel-Stack
 gespeicherten Daten über den Benutzermodus-Wert des Stacksegments (
\emph on
SS
\emph default
), des Stackzeigers (
\emph on
ESP
\emph default
), des Flag-Registers (
\emph on
EFLAGS
\emph default
), des Code-Segment (
\emph on
CS
\emph default
) und des Programmzeigers (
\emph on
EIP
\emph default
) durchgeführt.
 Da im EFLAGS-Register im CPL-Feld der Wert 3 steht, weiß die CPU, dass
 ab jetzt wieder die unprivilegierte Ausführung stattfinden soll.
\end_layout

\begin_layout Section
Zusammenfassung des Ein- und Austrittsmechanismus
\begin_inset LatexCommand \label{sec:Zusammenfassung-des-Ein-}

\end_inset


\end_layout

\begin_layout Standard
Um den Mechanismus nun noch einmal jenseits der Implementationsdetails zu
 betrachten: Im wesentlich wird beim Kernel-Eintritt auf dem Kernel-Stack
 der Zustand der CPU im Benutzermodus gespeichert, so dass bei Abruf dieser
 Daten die Ausführung im Benutzer-Modus fortzusetzen.
 Beim Kernel-Austritt werden diese Daten wiederhergestellt
\begin_inset Foot
status collapsed

\begin_layout Standard
Ausgenommen sind hierbei sämtliche FPU-Register, da diese an anderer Stelle
 wiederhergestellt werden.
\end_layout

\end_inset

.
 Bei einem Threadwechsel wird lediglich der Stack vor der eigentlichen Rückkehr
 gewechselt, so dass bei der Rückkehr nun die Zustandsdaten eines anderen,
 zuvor unterbrochenen Threads geladen werden.
 Grundsätzlich kann 
\emph on
i386_do_context_switch
\emph default
 nicht aufgerufen werden, sondern steht immer am Schluß einer Eintrittsroutine,
 da ja der Zeiger des Kernel-Stacks wieder an der Stelle angelangt sein
 muss, an der beim Eintritt die Register gespeichert wurden.
\end_layout

\begin_layout Standard
Eine Ausnahme hierbei bildet 
\emph on
SYSCALL_YIELDS_THREAD
\emph default
.
 Hier wird vor Beendigung einer Kernel-Routine die Ausführung unterbrochen,
 da der Kernel evtl.
 auf Ressourcen für den Thread wartet.
 Bevor 
\emph on
i386_do_context_switch
\emph default
 aufgerufen wird, speichert 
\emph on
i386_yield_kernel_thread
\emph default
 den Betriebszustand des Kernels an der Stelle auf dem Kernel-Stack, an
 der der Aufrufer von 
\emph on
SYSCALL_YIELDS_THREAD
\emph default
 seine Ausführung unterbrochen hat.
 Bei Wiederaufruf des Kernels wird statt eines Benutzermodus-Zustandes der
 Kernelzustand geladen.
\end_layout

\begin_layout Standard
Da der Zustand des Benutzermodus jedoch immer an fester Adresse liegt, können
 somit die Benutzermodus-Register eines Threads durch die Systemaufrufe
 
\emph on
read_regs
\emph default
 und 
\emph on
write_regs
\emph default
 manipuliert werden - die Register eines im Kernel festsitzenden Threads
 jedoch nicht, da diese eben an anderer Stelle auf dem Kernel-Stack gespeichert
 sind.
 Bei Initialisierung eines neuen Kernel-Stacks (siehe 
\begin_inset LatexCommand \ref{sub:Aufbau-eines-Kernel-Stacks}

\end_inset

) wird aus gleichem Grund am Ende des Kernel-Stacks ein Prototyp-Status
 gespeichert, der bei Aktivierung des Threads von 
\emph on
i386_do_context_switch
\emph default
 schließlich geladen wird.
\end_layout

\begin_layout Standard
Insgesamt ist dieser Mechanismus etwa genauso effektiv, wie der von Intel
 angebotene TSS-Mechanismus.
 Der 
\emph on
hymk
\emph default
 verwendet das TSS-Segment nur um das Stack-Register für den Ring-0 (
\emph on
ESP0
\emph default
) für den Eintritt in den Kernel bereitzulegen, wie es die CPU-Spezifikation
 fordert.
 Der eigentliche CPU-Zustand wird im TSS nicht gespeichert.
 Es existiert daher im übrigen nur ein einziges TSS-Segment, dass durch
 die Datenstruktur 
\emph on
i386_tss_struct
\emph default
 (
\emph on
tss.c
\emph default
) beschrieben wird
\begin_inset Foot
status collapsed

\begin_layout Standard
Nähere Informationen zum Aufbau des TSS-Segments können der IA-32-Dokumentation
 entnommen werden.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Der Scheduler
\end_layout

\begin_layout Subsection
Der Scheduling-Algorithmus
\end_layout

\begin_layout Standard
Der Scheduling-Algorithmus des 
\emph on
hymk
\emph default
 ist recht primitiv
\begin_inset Foot
status collapsed

\begin_layout Standard
Vermutlich wird jeder etwas besser gebildete Akademiker dieses gebilde nicht
 Scheduler nennen wollen.
\end_layout

\end_inset

.
 Es handelt sich um einen prioritätsbasierten Scheduler nach Round-Robin-Prinzip
 mit zusätzlicher Bevorzugung von I/O-intensiven Threads.
 Der Scheduler unterscheidet zwischen zwei Arten von Thread-Prioritäten:
 Die statische und die effektive Priorität.
 
\end_layout

\begin_layout Subsubsection
Prioritäten
\end_layout

\begin_layout Standard
Die statische Priorität wird durch den Systemaufruf 
\emph on
set_priority
\emph default
 durch einen berechtigten Prozess festgelegt.
 Sie besteht aus Zahlen zwischen 0 und 40, wobei 40 der höchsten Priorität
 entspricht.
 Normale Threads dürfen ihre statische nur absenken.
 Threads von Root-Prozessen können sie auch anheben.
 
\end_layout

\begin_layout Standard
Die effektive Priorität hingegen wird jedesmal errechnet, wenn ein Thread
 aus einer I/O-Operation aufwacht oder wieder regulär nach der Warteschlange
 (die sog.
 
\emph on
Runqueue
\emph default
) zur Ausführung kommt.
 Die effektive Priorität gibt zugleich an, wieviele Uhrenticks (1 ms) ein
 Thread ausgeführt werden darf, ehe er die CPU-Zeit verliert.
 Kommt ein Thread normal an die Reihe entspricht dies auf x86-Systemen dem
 doppelten Zahlenwert der statischen Priorität.
 Wacht jedoch ein Thread aus einer I/O-Operation auf, so wird ihm zusätzlich
 noch die Hälfte der effektiven Priorität gutgeschrieben, die noch übrig
 war, als er die CPU auf Grund der I/O-Blockade abgegeben hatte.
\end_layout

\begin_layout Subsubsection
Scheduling-Policies
\end_layout

\begin_layout Standard
Daneben gibt es theoretisch auch mehrere Scheduling-Klassen (
\emph on
Policies
\emph default
), mit deren Hilfe zwischen unterschiedlichen Scheduling-Verfahreng gewechselt
 werden kann.
 Derzeit ist aber nur eine verfügbar, 
\emph on
SCHED_REGULAR
\emph default
 (
\emph on
sched.h
\emph default
).
 Die Scheduling-Klassen sind bestimmten numerischen Werten zuzuweisen.
 Bei Änderung der Klasse gilt, dass Threads normaler Prozesse nur Klassen
 mit Nummern auswählen können, die kleiner oder gleich dem aktuellen Klassenwert
 sind.
 Root-Prozesse hingegen können auch größere Werte verwenden.
 Dadurch soll später auch eine Priorisierung der Scheduling-Policy vorgenommen
 werden können (z.B.
 Echtzeit vs.
 Normalbetrieb).
 Derzeit existiert jedenfalls nur eine Klasse mit Nummer 0.
\end_layout

\begin_layout Subsubsection
Die Runqueue
\end_layout

\begin_layout Standard
Die wichtigste Datenstruktur des Schedulers ist die Runqueue.
 In ihr sind alle Threads enthalten, die derzeit ausgeführt werden sollen.
 Sie ist genaugenommen eine verkette Liste, die jeweils über die Elemente
 
\emph on
THRTAB_RUNQUEUE_PREV
\emph default
 und 
\emph on
THRTAB_RUNQUEUE_NEXT
\emph default
 der jeweiligen Thread-Deskriptoren verknüpft ist.
 Den Beginn der Liste bildet immer der sog.
 
\emph on
idle
\emph default
-Thread - alle anderen Threads folgen ihm.
 Der Deskriptor des aktuellen Threads wird durch die Variable 
\emph on
current_t
\emph default
 (
\emph on
current.c
\emph default
, 
\emph on
current.h
\emph default
) angezeigt.
\end_layout

\begin_layout Subsubsection
Der 
\emph on
idle
\emph default
-Thread
\begin_inset LatexCommand \label{sub:Der-idle-Thread}

\end_inset


\end_layout

\begin_layout Standard
Dieser Thread läuft stets im Kernel-Mode und dient dazu, die CPU mit energiespar
enden HLT-Instruktionen zu versorgen (siehe 
\emph on
ksched_idle_loop
\emph default
, 
\emph on
schedule.c
\emph default
), wenn alle Threads auf Eingaben warten.
 Außerdem frisst er rein formal die übrige CPU-Zeit auf, solange alle Threads
 blockiert sind.
 Auf den Deskriptor dieses 
\emph on
idle
\emph default
-Thread ist im Kernel in der Variable 
\emph on
ksched_idle_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) ein Zeiger abgelegt.
 
\end_layout

\begin_layout Subsubsection
Umsetzung der Prioritätenregel
\end_layout

\begin_layout Standard
Normalerweise wird ein Thread einfach solange ausgeführt, bis seine CPU-Zeit
 abgelaufen ist.
 Anschließend wird der nächste Thread in der Liste ausgewählt.
 
\end_layout

\begin_layout Standard
Wird jedoch während dieser Ausführungszeit durch ein Ereignis (IRQ oder
 Aufhebung einer Blockade durch einen Systemaufruf) ein anderer Thread mit
 höherer effektiver Priorität aufgeweckt, so wird dieser Thread als Nachfolger
 des aktuellen Threads in die Runqueue eingefügt und ein Threadwechsel forciert.
 Dadurch soll eine kürzere Antwortzeit bei I/O-Operationen erreicht werden,
 da i.d.R.
 Threads, die auf Eingaben warten noch verbleibende Restprioritäten haben
 und diese bei Reaktivierung auf Grund der eintreffenden Eingabe gutgeschrieben
 wird.
 Dies ist sinnvoll, um dem Anwender einen befriedigenden Eindruck von Reaktionsz
eit und Geschwindigkeit des Systems zu liefern.
\end_layout

\begin_layout Subsection
Verwaltung der Runqueue
\end_layout

\begin_layout Subsubsection
Aufnahme in die Runqueue
\end_layout

\begin_layout Standard
Zur Aufnahme von Threads in die Runqueue ist die Kernel-interne Funktion
 
\emph on
ksched_start_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) zuständig.
 Diese Funktion prüft selbstständig, ob ein Thread bereits Mitglied der
 Queue ist und in wiefern er überhaupt aufgenommen werden darf.
 Darf er aufgenommen werden, wird von der Funktion die effektive Priorität
 ausgerechnet.
 Ist die effektive Priorität des neuen Threads größer als die Priorität
 des aktuellen, so wird der Thread direkt nach dem aktuellen Thread in die
 Runqueue eingereiht und ein Threadwechsel forciert..
 Andernfalls wird der Thread an den Anfang der Runqueue direkt nach dem
 
\emph on
idle
\emph default
-Thread eingereiht
\begin_inset Foot
status collapsed

\begin_layout Standard
Etwaige Benachteiligungen anderer Thread dadurch werden derzeit dabei vernachläs
sigt.
 Eine Alternative wäre, den neuen Thread direkt vor den aktuellen Thread
 einzureihen, so dass er wirklich erst nach allen anderen Drankommt.
 Es könnte natürlich auch eine Einreihung nach Priorität durchgeführt werden.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Anschließend wird das Flag 
\emph on
THRSTAT_BUSY
\emph default
 aus dem Thread-Status 
\emph on
THRTAB_THRSTAT_FLAGS
\emph default
 entfernt, so dass der Thread wieder als Betriebsbereit gilt.
 Ebenfalls wird der Zähler für aktive Threads 
\emph on
ksched_active_threads
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) inkrementiert.
\end_layout

\begin_layout Subsubsection
Entfernen aus der Runqueue
\end_layout

\begin_layout Standard
Soll ein Thread aus der Runqueue entfernt werden, muss der Aufruf 
\emph on
ksched_stop_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) getätigt werden.
 Dieser Aufruf entfernt den Thread aus der Runqueue und setzt dessen Felder
 
\emph on
THRTAB_RUNQUEUE_PREV
\emph default
 und 
\emph on
THRTAB_RUNQUEUE_NEXT
\emph default
 auf Null.
 Der Zähler 
\emph on
ksched_active_threads
\emph default
 wird dekrementiert und das 
\emph on
THRSTAT_BUSY
\emph default
-Flag gesetzt.
\end_layout

\begin_layout Standard
Dieser Aufruf forciert keinen Threadwechsel durch Änderung von 
\emph on
ksched_change_thread
\emph default
, falls der zu stoppende Thread gleich dem aktuellen Thread ist.
 Die aufrufende Routine hat dies zu erledigen.
\end_layout

\begin_layout Subsection
Forcieren eines Threadwechsels
\end_layout

\begin_layout Standard
Um das System zur Ausführung eines Threadwechsel zu veranlassen, muss einfach
 nur die Variable 
\emph on
ksched_change_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) auf 1 gesetzt werden und der Aufruf 
\emph on
ksched_next_thread
\emph default
 (
\emph on
current.c
\emph default
, 
\emph on
current.h
\emph default
)
\begin_inset Foot
status collapsed

\begin_layout Standard
Anmerkung: Es könnte evtl.
 später einmal effizienter sein, diesen Aufruf als 
\emph on
inline
\emph default
-Funktion zu realisieren.
\end_layout

\end_inset

 ausgeführt werden.
 Soll davor implizit mit Hilfe von 
\emph on
ksched_change_thread 
\emph default
überprüft werden, ob ein Thread-Wechsel überhaupt nötig ist, kann dies über
 das Makeo 
\emph on
KSCHED_TRY_RESCHED
\emph default
 gemacht werden.
 Ist ein Thread-Wechsel nötig, führt es diesen aus.
\end_layout

\begin_layout Standard
Der Aufruf 
\emph on
ksched_next_thread
\emph default
 führt alle Vorbereitungen für einen Thread- und ggf.
 Prozesswechsel zum nächsten Thread der Runqueue durch, so dass beim Ausführen
 von 
\emph on
i386_do_context_switch
\emph default
 (
\emph on
irq.s
\emph default
, siehe 
\begin_inset LatexCommand \ref{sec:Zusammenfassung-des-Ein-}

\end_inset

) der Kernel dann beim Wechsel in den Benutzermodus einen Threadwechsel
 vollzieht.
 Voraussetzung ist - wie bereits erwähnt -, dass 
\emph on
ksched_change_thread
\emph default
 zuvor auf 1 gesetzt wurde.
\end_layout

\begin_layout Standard
Sollte 
\emph on
ksched_active_threads
\emph default
 den Wert 1 haben, wird hierbei stets automatisch der 
\emph on
idle
\emph default
-Thread als nächster Thread ausgewählt.
 Andernfalls der nächste Thread der Liste - oder bei erreichtem Listenende
 - der erste Thread nach dem 
\emph on
idle
\emph default
-Thread.
\end_layout

\begin_layout Standard
Die Argumente des Aufrufs 
\emph on
i386_do_context_switch
\emph default
 - die Zeiger 
\emph on
i386_new_stack_pointer
\emph default
 und 
\emph on
i386_old_stack_pointer
\emph default
 - werden von diesem Aufruf auf die jeweiligen Stackpointer-Puffer im Deskriptor
 des Quell- (
\emph on
_old_
\emph default
) bzw.
 Ziel-Threads (
\emph on
_new_
\emph default
) gesetzt.
 
\end_layout

\begin_layout Standard
Ist der zu startende Thread Teil eines anderen Prozesses, wird über den
 Aufruf 
\emph on
ksched_switch_space
\emph default
 (
\emph on
current.h
\emph default
) ein Kontextwechsel durchgeführt.
 Dabei wird u.a.
 der Zeiger 
\emph on
i386_current_pdir
\emph default
, der das aktuelle Seitenverzeichnis anzeigt, auf das Seitenverzeichnis
 des neuen Prozesses (aus 
\emph on
PRCTAB_PAGEDIR_PHYSICAL_ADDR
\emph default
) geändert.
 Der Wechsel findet nach den IA-32-Spezifikationen dadurch statt, dass die
 Adresse des neuen Seitenverzeichnisses in das 
\emph on
CR3
\emph default
-Register der CPU geladen wird.
 Da der Kernel-Adressraum dabei konstant bleibt, kann die Ausführung danach
 normal weiterlaufen.
 Ebenfalls wird danach in 
\emph on
ksched_next_thread
\emph default
 der Zeiger 
\emph on
current_p
\emph default
, der auf den Deskriptor des aktuellen Prozesses verweist, entsprechend
 geändert und die Haupt-Info-Page aktualisiert.
 Der Aufruf 
\emph on
ksched_switch_space
\emph default
 prüft aus Performance-Gründen nicht die Zulässigkeit des genannten Prozesses.
\end_layout

\begin_layout Standard
Nachdem der Adressraum gewechselt wurde, werden alle FPU (etc.)-Register
 über die Funktion 
\emph on
ksched_switch_fpu_state 
\emph default
(
\emph on
current.c
\emph default
) geladen.
 Diese Information ist im Feld 
\emph on
THRTAB_X86_FPU_STACK
\emph default
 des jeweiligen Threads gespeichert.
 Der Kernel speichert den Registerzustand des verdrängten Threads über die
 
\emph on
fsave
\emph default
-Instruktion oder - falls verfügbar - über die 
\emph on
fxsave
\emph default
-Instruktion dort ab und lädt aus dem gleichen Feld des Zielthreads dessen
 FPU-Register mittels 
\emph on
frstor
\emph default
 bzw.
 
\emph on
fxrstor
\emph default
 neu ein, so dass diese nach Reaktivierung des Threads wieder zur Verfügung
 stehen 
\begin_inset Foot
status collapsed

\begin_layout Standard
Hier sollte geprüft werden, inwiefern die Speicherung der Registerdaten
 im öffentlich lesbaren Thread-Deskriptor ein Sicherheitsrisiko darstellen
 könnte.
 Als Alternative könnten die Daten am unteren Ende des Kernel-Stacks ebenfalls
 gesichert werden.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Als nächstes wird der Zeiger 
\emph on
current_t
\emph default
, der auf den Deskriptor des aktuellen Threads verweist geändert.
 Anschließend wird über über den Aufruf von 
\emph on
ksched_set_local_storage
\emph default
 der 
\emph on
thread local storage
\emph default
 des neuen Threads eingeblendet, wobei dieser Aufruf sich 
\emph on
kmem_map_page_frame_cur
\emph default
 bedient.
\end_layout

\begin_layout Standard
Nach Aktualisierung der Haupt-Info-Page wird der Zegier auf den Deskriptoreintra
g über die effektive Priorität des neuen Threads nach 
\emph on
kinfo_eff_prior
\emph default
 geladen.
 Diese Variable wird später verwendet, um die effektive Priorität wähernd
 des Systembetriebs bei jedem IRQ der Systemuhr herabzusetzen.
 Hat der Thread bei verlassen von 
\emph on
ksched_next_thread
\emph default
 keine effektive Priorität, so wird die Priorität aus der statischen Priorität
 des Threads errechnet.
\end_layout

\begin_layout Standard
Ebenfalls wird zur Anpassung der I/O-Zugriffsrechte beim Threadwechsel der
 Zeiger 
\emph on
kinfo_io_map
\emph default
 auf das Informationsfeld zu den I/O-Zugriffsrechten im Deskriptor des nun
 aktuellen Prozesses gesetzt (siehe 
\begin_inset LatexCommand \ref{Ist-im-IO-Zugriffsfeld}

\end_inset

).
\end_layout

\begin_layout Standard
Zu beachten ist, dass 
\emph on
ksched_next_thread
\emph default
 immer nur am Schluß einer Operation ausgeführt werden sollte, wenn der
 Threadwechsel wirklich ausgeführt werden soll, da verschiedene interne
 Zeiger (u.a.
 der auf den aktuellen Thread) dann bereits auf den neuen Thread eingestellt
 sind.
\end_layout

\begin_layout Standard
Grundsätzlich wird ein durch 
\emph on
ksched_next_thread
\emph default
 forcierter Threadwechsel bei jedem Austritt aus dem Kernel wirksam.
 Egal, ob das System durch einen IRQ, eine Exception oder einen Systemaufruf
 in den Kernel eingetreten ist.
 Ebenfalls ist egal, ob ein Systemaufruf normal terminiert hat oder seine
 Ausführung durch 
\emph on
SYSCALL_YIELDS_THREAD
\emph default
 nur einstweilen unterbrechen will.
\end_layout

\begin_layout Subsection
Eintritt in die Schedulingschleife
\end_layout

\begin_layout Standard
Nach vollständiger Initialisierung des Systems, tritt der Kernel in die
 Scheduling-Schleife ein.
 Hierfür ist die Funktion 
\emph on
ksched_enter_main_loop
\emph default
 (
\emph on
current.c
\emph default
, 
\emph on
sched.h
\emph default
) zuständig.
 Diese Funktion führt 
\emph on
ksched_next_thread
\emph default
 mit gesetztem 
\emph on
ksched_change_thread
\emph default
 aus, so dass ein Threadwechsel forciert wird.
 Da der Kernel nach dem Start einen temporären Stack verwendet, wird 
\emph on
i386_old_stack_pointer
\emph default
 nachträglich auf einen internen Zeiger geändert, da der Kernel-Stack des
 
\emph on
idle-
\emph default
Threads nicht verändert werden darf.
\end_layout

\begin_layout Standard
Der Eintritt in die Scheduling-Schleife erfolgt letztlich durch einen Sprung
 nach 
\emph on
i386_do_context_switch
\emph default
.
 Da der neue Zielthread mit aktivierten IRQs arbeitet, wird beim ersten
 Eintritt in den Benutzer-Modus automatisch die IRQ-Behandlung aktiviert.
\end_layout

\begin_layout Subsection
Die Initialen Prozesse
\end_layout

\begin_layout Standard
Der 
\emph on
hymk
\emph default
 startet automatisch zwei sog.
 initiale Prozesse, die für den Betrieb des Systems nach der Initiailsierung
 des Kernels benötigt werden.
 Der eine ist der bereits erwähnte idle-Prozess - der andere ist der sog.
 Init-Prozess, der die Initialisierung des Systems übernimmt.
\end_layout

\begin_layout Subsubsection
Der idle-Prozess
\end_layout

\begin_layout Standard
Wie bereits in Abschnitt 
\begin_inset LatexCommand \ref{sub:Der-idle-Thread}

\end_inset

 erläutert, dient der 
\emph on
idle
\emph default
-Thread dazu, die CPU in einen Wartezustand zu versetzen, wenn kein Thread
 aktiv ist.
 Diesem 
\emph on
idle
\emph default
-Thread ist ein Prozess zugeordnet.
 Auf x86-Plattformen trägt der Thread die SID 0x1000000 und der Prozess
 die SID 0x2000000.
\end_layout

\begin_layout Standard
Initialisiert wird der 
\emph on
idle
\emph default
-Prozess durch den Kernel in der Routine 
\emph on
ksysc_create_idle
\emph default
 (
\emph on
subject.c
\emph default
).
 Da diese Funktion den ersten Prozess des Systems erstellt, muss sie 
\emph on
current_p
\emph default
 und 
\emph on
current_t
\emph default
 im Voraus initialisieren, wobei diese Zeiger auf die Adresse der zukünftigen
 Deskriptoren von 
\emph on
idle
\emph default
 gesetzt werden.
 Der neue Prozess selbst (und somit auch dessen initialer Thread) wird über
 den Aufruf von 
\emph on
sysc_create_process
\emph default
 ganz konventionell erstellt.
 Dabei wird auch die Variable 
\emph on
ksched_idle_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) initialisiert.
 
\end_layout

\begin_layout Standard
Da der Idle-Thread im Kernel-Modus operieren soll, muss dessen Kernel-Stack
 mit gesetztem Flag 
\emph on
KSCHED_KERNEL_MODE
\emph default
 erneut initialisiert werden.
 Als Startroutine erhält der Idle-Thread die bereits erwähnte Routine 
\emph on
ksched_idle_loop
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
).
 
\end_layout

\begin_layout Standard
Die Priorität wird des 
\emph on
idle
\emph default
-Threads wird anschließend auf das niedrigste Niveau herabgesetzt.
 Der Thread wird daraufhin durch 
\emph on
sysc_awake_subject
\emph default
 aktiviert, so dass er beim Eintrtt in die Schedulingschleife zur Ausführung
 verfügbar wird.
\end_layout

\begin_layout Standard
Wichtig ist, dass der 
\emph on
idle
\emph default
-Thread vom Benutzermodus aus nicht kontrolliert oder beeinflusst werden
 können darf.
 Der 
\emph on
idle
\emph default
-Thread operiert ständig im Kernel-Modus und ist für den Multitaskingbetrieb
 unerlässlich.
 Eine Eingriffsmöglichkeit aus dem Benutzermodus stellt ein hohes Stabilitäts-
 und Sicherheitsrisiko dar.
 
\end_layout

\begin_layout Subsubsection
Der init-Prozess
\end_layout

\begin_layout Standard
Nachdem der Kernel soweit initialisiert wurde, muss ein Programm gestartet
 werden, das den Rest des Betriebssystems lädt.
 Dieses Programm heißt unter HydrixOS 
\emph on
init
\emph default
 und wird vom Bootloader beim Start als Image in einen Speicherbereich geladen,
 der dem Kernel zugänglich ist.
 Damit der Kernel das richtige Modul ermitteln kann, wird von einem Bootloader,
 der der Multiboot-Spezifikation entspricht (im wesentlichen ist das GRUB),
 eine Tabelle mit Informationen über die vorhandenen Module hinterlassen.
 Im 
\emph on
hymk
\emph default
 ist diese Tabelle über den Zeiger 
\emph on
grub_modules_list
\emph default
 (
\emph on
modules.c
\emph default
, 
\emph on
mem.h
\emph default
) erreichbar, wobei 
\emph on
init
\emph default
 dort im Eintrag 0 enthalten ist.
\end_layout

\begin_layout Standard
Der Kernel lädt und initialisiert 
\emph on
init
\emph default
 über die Funktion 
\emph on
ksysc_create_init
\emph default
 (
\emph on
subject.c
\emph default
).
 Diese Funktion erzeugt einen Prozess über den Aufruf 
\emph on
sysc_create_process
\emph default
.
 In den Adressraum des Prozesses werden die Daten des Init-Prozesses über
 
\emph on
kmem_map_page_frame
\emph default
 (
\emph on
page.c
\emph default
, 
\emph on
mem.h
\emph default
) eingeblendet.
 Anschließend wird dem Prozess die maximale Priorität verliehen und durch
 
\emph on
sysc_awake_subject
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sysc.h
\emph default
) gestartet.
 Da der Init-Prozess ein Tochterprozess des Idle-Prozesses ist, erbt er
 volle Root- und I/O-Rechte.
 
\end_layout

\begin_layout Standard
Der Aufruf von 
\emph on
ksysc_create_init
\emph default
 kann prinzipiell Mehrfach bei der Initialisierung des Kernels aufgerufen
 werden, um z.B.
 den Kernel tiefergehend zu testen.
 Nach dem Aufruf von 
\emph on
ksysc_create_init
\emph default
 ist als aktueller Adressraum der virtuelle Adressraum des erzeugten Prozess
 gesetzt.
 Da durch 
\emph on
awake_subject
\emph default
 ein hochprioritärer Thread erzeugt wurde, ist zu erwarten, dass dieser
 bei Eintritt in die Scheduling-Schleife gestartet wird.
\end_layout

\begin_layout Section
Behandlung von Timeouts
\end_layout

\begin_layout Standard
Synchrone Operationen erfordern es meistens, dass eine Thread auf einen
 anderen Thread warten muss.
 Bei diesen synchronen Operationen (im 
\emph on
hymk
\emph default
 sind dies im wesentlichen 
\emph on
recv_softint
\emph default
 und 
\emph on
sync
\emph default
), können Timeouts gesetzt werden, nach deren Ablauf der Kernel die Operation
 abbrechen soll.
\end_layout

\begin_layout Subsection
Verwendetes Verfahren
\end_layout

\begin_layout Standard
Der Kernel bietet hierfür ein internes Verfahren an, das von den verschiedenen
 Systemaufrufen aufgegriffen werden kann.
 Dieses Verfahren baut auf einer Warteschlange auf, in der in Reihenfolge
 der verschiedenen Timeouts alle wartenden Threads aufgelistet sind.
 Der jeweils erste Thread dieser Warteschlange ist der Thread, der als nächstes
 aufgeweckt werden soll.
 Um unnötiges Herunterzählen von Zeit zu vermeiden, wird nicht die verbleibende
 Zeit des Timeouts, sondern der Zeitpunkt relativ zur verstrichenen Zeit
 seit dem Systemstart notiert.
 Wird der Zeitpunkt erreicht, wird das Timeout erreicht.
 
\end_layout

\begin_layout Standard
Die Liste benötigt keinen besonderen Speicherplatz, sondern ist über die
 Thread-Deskriptoreneinträge 
\emph on
THRTAB_TIMEOUT_QUEUE_NEXT
\emph default
 und 
\emph on
THRTAB_TIMEOUT_QUEUE_PREV
\emph default
 untereinander verknüpft.
 Der erste Thread der Liste ist über die Variable 
\emph on
timeout_queue
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) erreichbar.
 Die Anzahl der Threads in der Warteliste kann über 
\emph on
timeout_num
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) ermittelt werden.
 Der Zeitpunkt, an dem der nächste Thread sein Timeout erreicht, ist in
 der Variable 
\emph on
timeout_next
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) gespeichert.
\end_layout

\begin_layout Standard
Die Liste kann über die Funktionen 
\emph on
ksched_add_timeout
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) und 
\emph on
ksched_del_timeout
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) bearbeitet und verwaltet werden.
 Beide Funktionen verwalten lediglich die Timeout-Liste und ändern den Timeout-W
ert eines Threads.
 Sie halten aber weder den Thread an, noch setzen sie das Flag 
\emph on
THRSTAT_TIMEOUT
\emph default
 - dies ist Aufgabe der aufrufenden Funktionen.
 
\end_layout

\begin_layout Subsection
Format eines Zeitpunkts
\end_layout

\begin_layout Standard
Jeder Zeitpunkt wird als Relativzeit zum Systemstart in Millisekunden gespeicher
t.
 Der Zeitpunkt des Timeouts eines Threads wird in den Deskriptoreinträgen
 
\emph on
THRTAB_TIMEOUT_LOW
\emph default
 und 
\emph on
THRTAB_TIMEOUT_HIGH
\emph default
 gespeichert.
 Hier ist - wie auch bei der Systemzeit - eine Aufteilung in zwei 32-bit
 Werte erforderlich, da die Zeit als 64-bit Wert gespeichert wird, um einen
 Uhren-Überlauf unwahrscheinlich zu machen (das System kann bei einem 64-bit
 Wert über 580 Mio.
 Jahre sich im Dauerbetrieb befinden).
 
\end_layout

\begin_layout Standard
Ein Timeout selbst kann aber nur maximal 32-bit (2^32 ms - d.h.
 49 Tage) lang sein.
 Ein Timeout darf nicht den Wert 
\emph on
0 
\emph default
(kein Timeout) und nicht den Wert 
\emph on
0xFFFFFFFF
\emph default
 (
\emph on
unendlich
\emph default
) haben.
 Solche Timeouts werden zwar von 
\emph on
ksched_add_timeout
\emph default
 akzeptiert, werden aber rein numerisch behandelt - ihre Sonderbedeutung
 wird dabei ignoriert.
 Unendliche Timeouts müssen daher von der aufrufenden Routine bereits richtig
 behandelt werden.
 
\end_layout

\begin_layout Subsection
Aufnahme in die Warteschlange
\end_layout

\begin_layout Standard
Die Funktion 
\emph on
ksched_add_timeout
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) erhält vom Aufrufer das Timeout in Millisekunden und errechnet selbstständig
 über die Systemzeit (gespeichert in 
\emph on
kinfo_rtc_ctr
\emph default
, 
\emph on
info.c
\emph default
, 
\emph on
info.h
\emph default
) den Zeitpunkt, andem das Timeout endet.
 In 
\emph on
THRTAB_TIMEOUT_LOW
\emph default
 und 
\emph on
THRTAB_TIMEOUT_HIGH
\emph default
 wird dann der Zeitpunkt gespeichert.
\end_layout

\begin_layout Standard
Die Routine unterscheidet zwischen vier unterschiedlichen Arten, ein Timeout
 zur Warteschlange hinzuzufügen: Entweder war die Warteschlange leer (
\emph on
timeout_queue == NULL
\emph default
) und somit wird die Warteschlange neu initialisiert und als nächstes Timeout
 (
\emph on
timeout_next
\emph default
) das, des zu installierenden Threads eingerichtet.
 
\end_layout

\begin_layout Standard
Oder aber das Timeout des zu installierenden Threads endet vor dem des ersten
 Threads der Liste - hierbei wird der neue Thread auf den Anfang der Liste
 gelegt und der Zeitpunkt des nächsten Timeouts entsprechend geändert.
 
\end_layout

\begin_layout Standard
Die dritte Möglichkeit ist, dass der Thread vor einem anderen Thread der
 Liste drankommen kann.
 Hierfür wird die komplette Liste durchsucht.
 Wird ein Thread gefunden, dessen Timeout erst nach dem neuen Thread erreicht
 ist, wird der neue Thread vor diesem in die Liste eingefügt.
 Zuletzt kann ein Thread auch noch an das Ende der Liste gestellt werden
 und die Liste terminieren.
\end_layout

\begin_layout Subsection
Entfernung aus der Warteschlange
\end_layout

\begin_layout Standard
Wird ein Timeout erreicht oder aus einem anderen Grund das Warten abgebrochen
 (z.B.
 bei Erreichen des gewünschten Ereignisses), kann der Thread mittels 
\emph on
ksched_del_timeout
\emph default
 wieder aus der Liste entfernt werden.
 Zur Beschleunigung des Verfahrens unterscheidet die Routine zwischen zwei
 Fällen:
\end_layout

\begin_layout Standard
Ist der zu entfernende Thread der Thread am Anfang der Liste, so wird dessen
 Nachfolger einfach nachgerückt - oder bei erreichtem Listenende die Liste
 geschlossen.
 Ist der zu entfernende Thread mitten in der Liste, wird er aus der Liste
 heraus entfernt.
\end_layout

\begin_layout Standard
Beim Beenden eines Threads wird dieser Automatisch von 
\emph on
sysc_destroy_subject
\emph default
 aus der Timeout-Warteschlange entfernt.
\end_layout

\begin_layout Subsection
Prüfung der Timeouts
\end_layout

\begin_layout Standard
Ob der Thread am Anfang der Timeout-Warteschlange aufgeweckt werden soll,
 oder nicht, wird bei jedem Uhren-IRQ durch die Funktion 
\emph on
ksched_handle_irq
\emph default
 überprüft.
 Da das Timeout in der Variable 
\emph on
timeout_next
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) gespeichert wird, wird ein unnötiger Zugriff auf den Thread-Deskriptor
 vermieden.
\end_layout

\begin_layout Standard
Wurde das Timeout erreicht, wird der Thread mittels 
\emph on
ksched_del_timeout
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) aus der Warteschlange entfernt und durch 
\emph on
ksched_start_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) wieder neu gestartet.
 Ebenfalls wird das Flag 
\emph on
THRSTAT_TIMEOUT
\emph default
 wieder gelöscht.
\end_layout

\begin_layout Section
IRQ-Behandlung
\end_layout

\begin_layout Subsection
Ablauf einer IRQ-Behandlung
\end_layout

\begin_layout Standard
Ein IRQ wird durch ein externes Hardwareereignis ausgelöst.
 Das auslösende Gerät sendet an den Interrupt-Controller (PIC) der CPU ein
 Signal.
 Der PIC wiederum sperrt den IRQ und übermittelt der CPU ein entsprechendes
 Signal, das sie zum Unterbrechen der aktuellen Ausführung und Behandlung
 des Interrupts auffordert.
 Die Behandlung des IRQs auf niedrigster Ebene wurde bereits im Kapitel
 über den Kernel-Eintritt (siehe 
\begin_inset LatexCommand \ref{sub:Kernel-Einsprung-durch-IRQs}

\end_inset

) angesprochen.
 Wie aber nun vom Kernel aus die IRQ-Information an den Thread eines Gerätetreib
ers weitergegeben wird, wird nun in diesem Kapitel geklärt.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
recv_irq
\end_layout

\begin_layout Standard
Ein Thread, der auf einen IRQ warten will, muss den Systemaufruf 
\emph on
recv_irq
\emph default
 - impelementiert durch 
\emph on
sysc_recv_irq
\emph default
 (
\emph on
io.c
\emph default
, 
\emph on
sysc.h
\emph default
) ausführen.
 Dieser Systemaufruf lässt den Thread passiv auf den IRQ warten.
 Tritt er ein, wird die Ausführung des Threads mit hoher Priorität fortgesetzt.
 Nach der Behandlung kann der Thread erneut auf den gleichen IRQ warten
 oder aber den IRQ anderen Threads wieder zur Verfügung stellen.
\end_layout

\begin_layout Standard
Es ergeben sich also für den Systemaufruf zwei Aufgabenbereiche, die nun
 im folgenden geklärt werden:
\end_layout

\begin_layout Subsubsection
1.
 Warten auf einen IRQ
\end_layout

\begin_layout Standard
Wartet ein Thread das erste mal auf einen bestimmten IRQ, muss dieser zuerst
 durch 
\emph on
recv_irq
\emph default
 reserviert werden.
 Zur Reservierung von IRQs existiert die Datenstruktur 
\emph on
irq_handlers_s
\emph default
 (
\emph on
io.c
\emph default
), die folgenden Aufbau hat:
\end_layout

\begin_layout LyX-Code
struct
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
sid_t tid;
\end_layout

\begin_layout LyX-Code
int is_handling;
\end_layout

\end_deeper
\begin_layout LyX-Code
}irq_handlers_s[16];
\end_layout

\begin_layout Standard
Jeder Eintrag des Arrays entspricht einem der sechzehn IRQs der x86-Plattform.
 Das Unterelement 
\emph on
tid
\emph default
 gibt die Thread-SID des Threads an, der den IRQ derzeit belegt (ist der
 Wert 0, so gilt der IRQ als nicht belegt.
 Das Unterelement 
\emph on
is_handling
\emph default
 hingegen gibt an, ob derzeit darauf gewartet wird, ob der IRQ eintritt
 (0) oder ob der IRQ derzeit vom Thread 
\emph on
tid
\emph default
 behandelt wird (1).
\end_layout

\begin_layout Standard
Soll ein IRQ nun reserviert werden, wird zuerst geprüft, ob die IRQ-Nummer
 gültig ist und ob der IRQ bereits belegt ist.
 Ist dem nicht so, wird der entsprechende Eintrag in 
\emph on
irq_handlers_s
\emph default
 konfiguriert.
 Dementsprechend wird ebenfalls der Deskriptor des aufrufenden Threads geändert.
 Dem Element 
\emph on
THRTAB_IRQ_RECV_NUMBER
\emph default
 wird die Nummer des aktuellen IRQs zugewiesen.
 Als effektive Priorität erhält der Thread 
\emph on
IRQ_THREAD_PRIORITY
\emph default
, was normalerweise ausreichend hoch seien sollte.
\end_layout

\begin_layout Standard
Anschließend wird der Thread durch 
\emph on
ksched_stop_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) gestoppt und der IRQ über 
\emph on
ksched_enable_irq
\emph default
 (
\emph on
intr.c
\emph default
, 
\emph on
sched.h
\emph default
) freigegeben.
 Diese Funktion führt plattformspezifische Operationen aus, die den Interrupt-Co
ntroller anweisen, den IRQ an die CPU weiterzuleiten.
\end_layout

\begin_layout Standard
Zum Schluß wird ein Threadwechsel durch setzen von 
\emph on
ksched_change_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) und Ausführen von 
\emph on
ksched_next_thread
\emph default
 (
\emph on
current.c
\emph default
, 
\emph on
current.h
\emph default
) forciert.
\end_layout

\begin_layout Standard
Beim erneuten Warten auf einen IRQ passiert im Prinzip das gleiche, wie
 beim erstmaligen Warten auf einen IRQ.
 Einziger Unterschied ist, dass der IRQ bereits durch den aktuellen Thread
 reserviert ist.
 Wird jedoch auf einen anderen IRQ gewartet, als im Wartevorgang zuvor,
 wird zuerst der IRQ wieder freigegeben
\end_layout

\begin_layout Subsubsection
2.
 Freigabe eines IRQs
\end_layout

\begin_layout Standard
Ein IRQ wird freigegeben, wenn auf den IRQ 
\emph on
0xFFFFFFFF
\emph default
 oder wenn auf einen neuen, anderen IRQ gewartet werden soll.
 Hierfür ist die Routine 
\emph on
kio_reenable_irq
\emph default
 zuständig, die von 
\emph on
sysc_recv_irq
\emph default
 in einem der beiden Fällen aufgerufen wird.
\end_layout

\begin_layout Standard
Diese Routine setzt den 
\emph on
irq_handlers_s
\emph default
-Eintrag wieder auf 0 zurück und setzt den Eintrag 
\emph on
THRTAB_IRQ_RECV_NUMBER
\emph default
 des Thread-Deskriptors wieder auf 
\emph on
0xFFFFFFFF
\emph default
.
 
\end_layout

\begin_layout Standard
Der IRQ selbst wird mittels 
\emph on
ksched_disable_irq
\emph default
 (die wieder einige x86-Spezifische Operationen ausführt, um den IRQ zu
 sperren; siehe 
\emph on
intr.c
\emph default
, 
\emph on
sched.h
\emph default
) gesperrt.
 Der IRQ wird nicht gesperrt, wenn es sich um den IRQ der Systemuhr (IRQ
 0) handelt, da dieser IRQ vom Kernel für den Scheduler verwendet wird.
\end_layout

\begin_layout Standard
Wenn der Thread keinen weiteren IRQ mehr behandeln will, verliert er seine
 effektive Priorität und wird zu einem Threadwechsel gezwungen, um anderen
 Threads nicht ungerechtfertigt zu benachteiligen.
\end_layout

\begin_layout Subsection
Der Weg vom Kernel zum Thread
\end_layout

\begin_layout Standard
Tritt ein IRQ ein, ruft die Low-Level-Routine des Kernels die Funktion 
\emph on
ksched_handle_irq
\emph default
 (
\emph on
intr.c
\emph default
) auf.
 Diese Routine erhält als Parameter die Nummer des aufgerufenen IRQs.
 Stellt die Routine fest, dass es sich um den IRQ 0 handelt, so erhöht sie
 den Zähler der Uhr (
\emph on
kinfo_rtc_ctr
\emph default
) 
\begin_inset Foot
status collapsed

\begin_layout Standard
Bei einem Überlauf der Uhr wird eine Kernel-Panic ausgelöst, da anhand der
 langen Laufzeit der Uhr (mehrere Mio.
 Jahre) eher anzunehmen ist, dass die Systemuhr defekt ist.
\end_layout

\end_inset

.
 Außerdem prüft sie, ob der aktuelle Thread sein Zeitquantum aufgebraucht
 hat oder nicht.
 Hat er es aufgebraucht, wird ein Threadwechsel forciert.
 Andernfalls wird seine effektive Priorität (und somit sein Zeitquantum)
 verringert.
 Der Zeiger 
\emph on
kinfo_eff_prior
\emph default
, der beim Threadwechsel zuvor gesetzt wurde, erlaubt hierbei einen schnellen
 Zugriff auf den entsprechenden Eintrag im Threaddeskriptor.
\end_layout

\begin_layout Standard
In jedem Fall wird der IRQ an die Routine 
\emph on
ksched_start_irq_handler
\emph default
 (
\emph on
io.c
\emph default
, 
\emph on
sched.h
\emph default
) weitergegeben.
 Diese Routine prüft, ob ein Thread auf diesen IRQ wartet bzw.
 ob er derzeit schon behandelt wird.
 Wartet ein Thread auf diesen IRQ und wird er noch nicht behandelt, so wird
 der 
\emph on
is_handling
\emph default
-Eintrag in der 
\emph on
irq_handler_s
\emph default
-Datenstruktur gesetzt und der IRQ mit 
\emph on
ksched_disable_irq
\emph default
 (
\emph on
intr.c
\emph default
, 
\emph on
sched.h
\emph default
) deaktiviert.
 Auch hier ist der IRQ 0 davon ausgenommen.
 Eine Mehrfachbehandlung durch einen Thread wird hierbei durch das 
\emph on
is_handling
\emph default
-Flag vermieden.
\end_layout

\begin_layout Standard
Der behandelnde Thread wird nun über 
\emph on
ksched_start_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) ganz normal wieder in die Runqueue aufgenommen.
 Es wird ein Threadwechsel forciert und da der Thread eine sehr hohe effektive
 Priorität hat, wird er höchstwahrscheinlich bei Rückkehr aus dem Kernel-Modus
 gestartet werden.
\end_layout

\begin_layout Subsection
Schlußbemerkungen zur IRQ-Behandlung
\end_layout

\begin_layout Standard
Der Kernel befindet sich also während der Behandlung eines IRQs durch einen
 Treiber in keinem besonderen Betriebsmodus.
 Der IRQ wird direkt weitergegeben und der Treiber ganz normal im Multitasking-Z
yklus ausgeführt.
 Ist während der IRQ-Behandlung das Multitasking unerwünscht, muss der jeweilige
 Treiber den Interruptcontroller anweisen, den IRQ 0 zu sperren.
 
\end_layout

\begin_layout Standard
Der Kernel muss dies berechtigten Threads gestatten und ebenfalls genug
 Zeit dem behandelnden Thread beim Beginn der IRQ-Behandlung durch eine
 entsprechend hohe effektive Priorität einräumen.
\end_layout

\begin_layout Section
Systemaufrufe zur Ausführungskontrolle
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
set_priority
\end_layout

\begin_layout Standard
Für die Änderung der statischen Priorität ist der Systemaufruf 
\emph on
set_priority
\emph default
, implementiert durch den Aufruf 
\emph on
sysc_set_priority
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sysc.h
\emph default
) zuständig.
 Der Systemaufruf prüft lediglich die Zugriffsrecht und ändert die Daten
 der statischen Priorität und Scheduling-Klasse.
 Bei erneuter Berechnung der effektiven Priorität wird die neue statische
 Priorität beachtet.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
freeze_subject
\end_layout

\begin_layout Standard
Soll ein Thread eingefroren werden, muss der Systemaufruf 
\emph on
freeze_subject
\emph default
 getätigt werden.
 Dieser Systemaufruf - implementiert durch 
\emph on
sysc_freeze_subject
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sysc.h
\emph default
) - ist derzeit nur auf Thread-Subjekte beschränkt, kann aber in späteren
 Versionen auch auf andere Subjektarten ausgeweitet werden.
\end_layout

\begin_layout Standard
Der Aufruf selbst erhöht (nach einer ausführlichen Prüfung der Zugriffsrechte),
 den Freeze-Counter des Threads und setzt das Flag THRSTAT_FREEZED.
 Anschließend wird geprüft, ob der Thread bereits eingefroren ist, sei es
 durch einen vorherigen Freeze-Aufruf (Freeze-Counter ist erhöht) oder aus
 einem anderen Grund (eines der unter THRSTAT_OTHER_FREEZED zusammengefassten
 Bits ist gesetzt).
 Ist der Thread noch nicht eingefroren gewesen, wird er aus der Runqueue
 mittels 
\emph on
ksched_stop_thread
\emph default
 entfernt.
 Handelt es sich zudem um den aktuellen Thread, wird ein Threadwechsel forciert.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
awake_subject
\end_layout

\begin_layout Standard
Ein bereits eingefrorener Thread kann über den Systemaufruf 
\emph on
awake_subject
\emph default
 wieder aufgeweckt werden.
 Der Systemaufruf ist über 
\emph on
sysc_awake_subject
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sysc.h
\emph default
) implementiert.
 Auch hier ist eine Erweiterung auf andere Subjekt-Arten in späteren Versionen
 möglich.
\end_layout

\begin_layout Standard
Dieser Aufruf dekrementiert den Freeze-Counter des Threads.
 Ist dieser bei 0 angelangt, wird der Thread über 
\emph on
ksched_start_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) wieder gesartet, sofern nicht der Thread zuvor schon aus einem anderen
 Grund eingefroren wurde (eines der unter THRSTAT_OTHER_FREEZED zusamengefassten
 Bits ist gesetzt).
 Da der neu gestartete Thread möglicherweise eine höhere effektive Priorität
 als der aktuelle Thread haben kann, wird mit 
\emph on
ksched_next_thread
\emph default
 ggf.
 ein forcierter Threadwechsel gültig gemacht.
\end_layout

\begin_layout Subsection
Der Systemaufruf 
\emph on
yield_thread
\end_layout

\begin_layout Standard
Ein Systemaufruf hat die Möglichkeit seine CPU-Zeit freiwillig abzugeben.
 Hierfür ist der Systemaufruf 
\emph on
yield_thread
\emph default
, implementiert durch 
\emph on
sysc_yield_thread
\emph default
 zuständig.
 Im wesentlichen setzt dieser Aufruf die effektive Priorität des Aufrufers
 auf 0 und forciert durch Setzen von 
\emph on
ksched_change_thread
\emph default
 und 
\emph on
ksched_next_thread
\emph default
 einen Threadwechsel.
 Der Systemaufruf erlaubt auch, die effektive Priorität an einen anderen
 Thread weiterzugeben, was lediglich durch Addition der Priorität zu der
 des anderen Threads geschiet.
\end_layout

\begin_layout Section
Der 
\emph on
sync
\emph default
-Mechanismus
\end_layout

\begin_layout Standard
Der einzige universelle Mechanismus für synchrone Kommunikation, der vom
 
\emph on
hymk
\emph default
 angeboten wird, ist der 
\emph on
sync-
\emph default
Mechanismus.
 Dieser Mechanismus wird durch den Systemaufruf 
\emph on
sync
\emph default
, implementiert in 
\emph on
sysc_sync
\emph default
 (
\emph on
sync.c
\emph default
, 
\emph on
sysc.h
\emph default
), zur Verfügung gestellt.
\end_layout

\begin_layout Standard
Hierbei ist eigentlich zwischen zwei Arten von Synchronisationen zu unterscheide
n: Der direkten Synchronisation mit einem bekannten Thread-Subjekt und der
 indirekten Synchronisation mit einem beliebigen Subjekt.
 Beide Synchronisationen können sowohl aktiv einen anderen wartenden Thread
 aufwekcken oder zu passiven Wartezuständen des Aufrufers führen.
\end_layout

\begin_layout Subsection
Grundlegende Datenstrukturen
\end_layout

\begin_layout Standard
Die wohl wichtigsten Datenstrukturen des Sync-Mechanismus sind die sog.
 Synchronisationswarteschleifen.
 Jeder Thread besitzt eine solche Warteschleife.
 Die Warteschleifen sind als verkettete Listen organisiert, wobei im Thread-Desk
riptor ein Zeiger auf den ersten Thread von dessen Liste besteht (
\emph on
THRTAB_OWN_SYNC_QUEUE_BEGIN
\emph default
).
 Im Deskriptor eines Threads, der Mitglied einer Liste ist, verweisen die
 Elemente 
\emph on
THRTAB_CUR_SYNC_QUEUE_PREV
\emph default
 und 
\emph on
THRTAB_CUR_SYNC_QUEUE_NEXT
\emph default
 jeweils auf das vorherige bzw.
 nächste Element der Synchronisationsliste, in der er Mitglied ist.
\end_layout

\begin_layout Subsection
Elemente des 
\emph on
sync
\emph default
-Mechanismus
\end_layout

\begin_layout Standard
Da einige Elemente mehrfach genutzt werden und der Quelltext auch übersichtlich
 gehalten werden sollte, wurde der 
\emph on
sync
\emph default
-Mechanismus auf weitere interne Funktionen verteilt, die hier nun erläutert
 werden (alle Funktionen sind im Modul 
\emph on
sync.c
\emph default
 enthalten):
\end_layout

\begin_layout Subsubsection
ksync_is_waitqueue
\end_layout

\begin_layout Standard
Diese Funktion durchsucht die Synchronisationswarteschlange des aufrufenden
 Threads bei passiven Synchronisationen nach einem Thread, der den Suchkriterien
 der 
\emph on
sync
\emph default
-Operation (siehe Beschreibung Systemaufruf 
\emph on
sync
\emph default
, Kapitel 
\begin_inset LatexCommand \ref{sub:sync}

\end_inset

) entspricht.
 Entweder wird von dieser Funktion die SID eines Threads zurückgegeben,
 der auf eine Synchronisation mit dem aktuellen Thread wartet.
 Oder aber es wird 0 zurückgegeben, wodurch die 
\emph on
sync
\emph default
-Operation zum Start des passiven Wartevorgangs veranlasst wird.
\end_layout

\begin_layout Subsubsection
ksync_wait_for
\end_layout

\begin_layout Standard
Diese Funktion startet einen passiven Wartevorgang.
 Ist ein Timeout gesetzt, wird das Timeout mittels 
\emph on
ksched_add_timeout
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) eingerichtet.
 Ist das Timeout 0 gesetzt, wird die Routine mit einer Fehlermeldung abgebrochen.
 In allen anderen Fällen (begrenztes oder unendliches Timeout) wird anschließend
 der Thread durch 
\emph on
ksched_stop_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) gestoppt und durch 
\emph on
i386_yield_kernel_thread
\emph default
 verdrängt.
 Nach Reaktivierung des Threads durch einen anderen Thread, startet die
 Funktion nach dem Yield-Befehl.
 Mittels des Aufrufs 
\emph on
MSYNC
\emph default
 wird sichergestellt, dass der Compiler nicht von einer ununterbrochenen
 Ausführung ausgeht.
\end_layout

\begin_layout Standard
Diese Funktion setzt ebenfalls das Flag 
\emph on
THRSTAT_SYNC
\emph default
.
 Ist nach Ende des Wartevorgangs das Flag immer noch gesetzt, so fand keine
 Synchronisation statt, da der synchronisierende Thread dieses Flag löscht.
 Die Funktion terminiert dann mit einer Timeout-Fehlermeldung.
 Andernfalls gibt die Funktion die SID des Threads zurück, der sich mit
 dem Thread während der Wartezeit synchronisiert hat.
\end_layout

\begin_layout Subsubsection
ksync_awake_other
\end_layout

\begin_layout Standard
Diese Funktion weckt einen anderen Thread auf, wenn dieser auf eine Synchronisie
rung mit dem aktuellen Thread gewartet hat.
 Ggf.
 entfernt die Routine den wartenden Thread aus der Timeout-Liste über 
\emph on
ksched_del_timeout
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) und startet ihn mittelst 
\emph on
ksched_start_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
).
 Wichtig ist, dass diese Funktion das Flag 
\emph on
THRSTAT_SYNC
\emph default
 beim wartenden Thread anschließend löscht und dessen Feld 
\emph on
THRTAB_SYNC_SID
\emph default
 auf die SID des aktuellen Threads anpasst, so dass dieser über den Erfolg
 der Synchronisierung informiert ist.
\end_layout

\begin_layout Subsubsection
ksync_addto_waitqueue
\end_layout

\begin_layout Standard
Diese Funktion fügt den aktuellen Thread zur Synchronisationswarteschlange
 eines anderen Threads hinzu.
\end_layout

\begin_layout Subsubsection
ksync_removefrom_waitqueue
\end_layout

\begin_layout Standard
Diese Funktion entfernt den aktuellen Thread aus der Synchronisationswarteschlan
ge eines anderen Threads.
\end_layout

\begin_layout Subsubsection
ksync_interrupt_other
\end_layout

\begin_layout Standard
Diese Funktion wird nicht von 
\emph on
sync
\emph default
, sondern 
\emph on
destroy_subject
\emph default
 verwendet, wenn ein Thread vernichtet werden soll.
 Sie weckt einen auf den zu vernichtenden Thread wartenden Thread wieder
 auf.
 Da sie das Flag 
\emph on
THRSTAT_SYNC
\emph default
 gesetzt lässt, weiß der Thread nach dem aufwachen, dass die Synchronisierung
 fehlgeschlagen ist, so dass 
\emph on
sync
\emph default
 eine entsprechende Fehlermeldung an den Benutzermodus zurückreichen kann.
\end_layout

\begin_layout Subsubsection
ksync_removefrom_waitqueue_error
\end_layout

\begin_layout Standard
Auch diese Funktion wird extern von 
\emph on
destroy_subject
\emph default
 verwendet, um einen zu vernichtenden Thread aus der Warteschlange eines
 anderen Threads zu entfernen.
\end_layout

\begin_layout Subsection
Ablauf einer Sync-Operation
\end_layout

\begin_layout Subsubsection
Direkte Synchronisation mit einem anderen Thread
\end_layout

\begin_layout Standard
Wenn sich ein Thread A direkt mit einem anderen Thread B synchronisieren
 will, so prüft 
\emph on
sync
\emph default
 zunächst, ob der B bereits auf den aktuellen Thread (A) wartet oder nicht.
 Wartet B bereits auf A, so wird B mit 
\emph on
ksync_awake_other
\emph default
 wieder aufgeweckt.
 Andernfalls trägt sich der Thread A in die Warteliste von Thread B durch
 
\emph on
ksync_addto_waitqueue
\emph default
 ein und legt sich mittels 
\emph on
ksync_wait_for
\emph default
 schlafen, bis entweder das gesetzte Timeout endet oder ab B eine Synchronisatio
n mit A startet und dabei A aufweckt.
 Nachdem A wieder aufgeweckt wurde, trägt sich A aus der Warteschlange von
 B durch 
\emph on
ksync_removefrom_waitqueue
\emph default
 aus und beendet den 
\emph on
sync
\emph default
-Aufruf.
\end_layout

\begin_layout Subsubsection
Indirekte Synchronisation mit einem Nicht-Thread-Subjekt
\end_layout

\begin_layout Standard
Wenn sich ein Thread mit einem Subjekt synchronisieren will, das kein Thread
 ist, so bleibt ihm nichts anderes übrig, als auf die Synchronisation mit
 Threads zu warten, die unter diese Subjekt-Kriterien (z.B.
 Prozess-SID) fallen.
 Bevor ein passiver Wartemodus begonnen wird, prüft jedoch der Thread durch
 den Aufruf von 
\emph on
ksync_is_waitqueue
\emph default
, ob sich nicht möglicherweise in seine Synchronisationswarteschlange bereits
 ein Thread eingetragen hat, auf den diese Kriterien zutreffen.
 Ist dem so, so wird dieser mittels 
\emph on
ksync_awake_other
\emph default
 wieder aufgeweckt.
 Andernfalls wird ein passiver Wartezustand durch 
\emph on
ksync_wait_for
\emph default
 eingegangen, der entweder durch ein Timeout oder einen Thread beendet werden
 kann, der sich gezielt mit dem schlafenden Thread synchronisiert.
 Nach Ende des Wartevorgangs wird die Routine einfach beendet.
\end_layout

\begin_layout Subsubsection
Implementierung des Resync-Mechanismuses
\end_layout

\begin_layout Standard
Die Resync-Fähigkeit des 
\emph on
sync
\emph default
-Systemaufrufs wird durch eine einfache while-Schleife umgesetzt.
 Diese wird verlassen, wenn alle Resyncs getätigt worden sind oder bei einer
 Synchronisation ein Fehler oder ein leerer Rückgabewert aufgetreten ist.
\end_layout

\begin_layout Chapter
Fernsteuerung von Threads
\end_layout

\begin_layout Section
Lesen und Manipulieren von Registerinhalten
\end_layout

\begin_layout Standard
In Abschnitt 
\begin_inset LatexCommand \ref{sub:Aufbau-eines-Kernel-Stacks}

\end_inset

 wurde bereits erläutert, dass der Anfangsbereich eines Kernel-Stacks stets
 die Registerdaten des Threads im Benutzermodus enthält.
 Aus diesem Grund kann das Auslesen und Manipulieren von Registerinhalten
 für die Systemaufrufe 
\emph on
read_regs
\emph default
 und 
\emph on
write_regs
\emph default
 leicht realisiert werden.
 Beide Systemaufrufe - jeweils implementiert über 
\emph on
sysc_read_regs
\emph default
 und 
\emph on
sysc_write_regs
\emph default
 (
\emph on
remote.c
\emph default
, 
\emph on
sysc.h
\emph default
) - müssen lediglich direkt auf den Anfang des Kernel-Stacks eines Threads
 zugreifen, um die entsprechenden Registerdaten auszulesen oder zu ändern.
\end_layout

\begin_layout Standard
Eine Ausnahme bildet hier der 
\emph on
idle-
\emph default
Thread, dessen Kernel-Stack den Registerzustand im Kernel enthält und daher
 von den Systemaufrufen nicht bearbeitet werden darf.
 Die FPU-Register der x86-Architektur werden derzeit zudem im Thread-Deskriptor
 und nicht im Kernel-Stack des Threads gespeichert, was mit der eigentümlichen
 Art und Weise zusammenhängt, mit der die x87-FPU ihre Registerinhalte speichert.
 Sie können mit 
\emph on
read_regs
\emph default
 weder ausgelesen, noch mit 
\emph on
write_regs
\emph default
 manipuliert werden
\begin_inset Foot
status collapsed

\begin_layout Standard
Ein direktes auslesen über den Thread-Deskriptor ist hier allerdings auch
 für unberechtigte (nicht-root) Threads derzeit möglich.
 Da dies ein Sicherheitsproblem darstellen könnte, wird empfohlen, die FPU-Daten
 in späteren Versionen des hymk am unteren Ende des Kernel-Stacks zu speichern.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Umleiten von Softwareinterrupts
\end_layout

\begin_layout Standard
Im Unterschied zu den meisten anderen Mikrokernen gestattet der 
\emph on
hymk
\emph default
 die Umleitung von Softwareinterrupts im Benutzermodus.
 Dies soll u.a.
 für die transparente Implementierung von Virtualisierungsdiensten ermöglichen.
 Hierfür zuständig ist der Systemaufruf 
\emph on
recv_softints
\emph default
, der selbst wiederum durch den Aufruf 
\emph on
sysc_recv_softints
\emph default
 (
\emph on
remote.c
\emph default
, 
\emph on
sysc.h
\emph default
) implementiert ist.
 Für dessen Umsetzung ist jedoch eine Zahl weiterer interner Aufrufe und
 Erweiterungen erforderlich.
\end_layout

\begin_layout Subsection
Einleitung einer Überwachung
\end_layout

\begin_layout Standard
Beim Aufruf von 
\emph on
sysc_recv_softints
\emph default
 wird (nach der obligatorischen Sicherheitsprüfung und einem ggf.
 Aufwecken des Zielthreads) im Deskriptor des Zielthreads der Eintrag 
\emph on
THRTAB_SOFTINT_LISTENER_THREAD
\emph default
 auf die SID des Aufrufers gestellt.
 Dadurch werden später die verschiedenen Kernel-Einsprungroutinen prüfen
 können, ob eine Umleitugn eines aufgetretenen Softwareinterrupts erforderlich
 ist oder ob der Softwareinterrupt gewöhnlich abgearbeitet werden soll.
 Ebenfalls wird das Feld 
\emph on
THRTAB_RECEIVED_SOFTINT
\emph default
 im zu überwachenden Thread auf 
\emph on
0xFFFFFFFF
\emph default
 gesetzt, so dass hier später die Nummer des tatsächlichen Software-Interrupts
 eingetragen werden kann oder aber - bei bleibendem Wert 
\emph on
0xFFFFFFFF
\emph default
 ein Fehlschlag der Überwachung (z.B.
 bei Erreichen eines Timeouts) erkannt werden kann.
\end_layout

\begin_layout Standard
Im Deskriptor des Aufrufers wird das Flag 
\emph on
THRSTAT_RECV_SOFTINT
\emph default
 gesetzt und in das Element 
\emph on
THRTAB_RECV_LISTEN_TO
\emph default
 die SID des zu überwachenden Threads eingetragen.
 Anschließend wird ein passiver Wartemodus erreicht.
 Bei gesetztem Timeout wird hierbei die Timeout-Überwachung mittels 
\emph on
ksched_add_timeout
\emph default
 (
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
) und durch Setzen des 
\emph on
THRSTAT_TIMEOUT
\emph default
-Flags eingeschaltet.
 In jedem Fall wird der Thread anschließend durch 
\emph on
ksched_stop_thread
\emph default
 (
\emph on
schedule.c
\emph default
, 
\emph on
sched.h
\emph default
) gestoppt und über den üblichen Weg verdrängt.
\end_layout

\begin_layout Standard
Durch das Makro 
\emph on
MSYNC
\emph default
 wird dem Compiler klar gemacht, dass ab dieser Position etwaige gechachte
 Variablen neu geladen werden müssen, da hier ein längerer passiver Wartezustand
 stattfand und globale Variablen sich möglicherweise geändert haben.
 Nach dem Wartezustand wird geprüft ob im Feld 
\emph on
THRSTAT_RECEIVED_SOFTINT
\emph default
 ein gültiger Software-Interrupt steht - andernfalls wird die Operation
 mit einer Fehlermeldung beendet.
 Unabhängig vom Rückgabewert werden die veränderten Deskriptoreinträge wieder
 auf ihre Grundeinstellungen zurückgesetzt.
\end_layout

\begin_layout Subsection
Übermittlung eines Software-Interrupts
\end_layout

\begin_layout Standard
Erkennt eine Kernel-Eintrittsroutine eine Überwachung der Software-Interrupts,
 so gibt sie die Behandlung des Software-Interrupts an die Routine 
\emph on
kremote_received
\emph default
 (
\emph on
remote.c
\emph default
, 
\emph on
sched.h
\emph default
) weiter.
 Diese Routine weckt den überwachenden Thread wieder auf und entfernt ihn
 ggf.
 mittels 
\emph on
ksched_del_timeout 
\emph default
(
\emph on
timeout.c
\emph default
, 
\emph on
sched.h
\emph default
)
\emph on
 
\emph default
aus der Timeout-Liste und löscht das Timeout-Flag 
\emph on
THRSTAT_TIMEOUT
\emph default
.
 Anschließend friert sie den aktuellen Thread über 
\emph on
sysc_freeze_subject
\emph default
 ein.
 
\end_layout

\begin_layout Subsection
Erkennung der Überwachung
\end_layout

\begin_layout Standard
Der wohl schwierigste Teil bei der Überwachung von Software-Interrupts ist
 die Erkennung der Überwachung und die korrekte Wiedergabe.
 Die Überwachung muss bei jeder Art von Software-Interrupt (Systemaufruf,
 leerer Software-Interrupt, Software-Interrupt eines IRQs / einer Exception)
 seperat implementiert werden und gestaltet sich unterschiedlich schwierig.
\end_layout

\begin_layout Subsubsection
Erkennung bei leeren Software-Interrupts
\end_layout

\begin_layout Standard
Bei leeren Software-Interrupts ist die Erkennung am leichtesten.
 Hier gibt die Funktion 
\emph on
i386_handle_emptyint
\emph default
 (
\emph on
intr.c
\emph default
, 
\emph on
sched.h
\emph default
) lediglich durch Aufruf von 
\emph on
kremote_received
\emph default
 (
\emph on
remote.c,
\emph default
 
\emph on
sched.h
\emph default
)
\emph on
 
\emph default
den Software-Interrupt weiter, wenn 
\emph on
THRSTAT_SOFTINT_LISTENER_SID
\emph default
 einen gültigen Wert hat.
 
\end_layout

\begin_layout Subsubsection
Erkennung bei Systemaufrufen
\end_layout

\begin_layout Standard
Bei Systemaufrufen gestaltet sich die Sache insgesamt schon etwas schwerer.
 Hier muss die Erkennung für jeden Systemaufruf seperat implementiert sein,
 da ja jeder Systemaufruf einen eigenen Low-Level-Handler in der Datei 
\emph on
sysc.s
\emph default
 besitzt.
 In der Regel sieht der dafür zuständige Abschnitt wie folgt aus (am Beispiel
 von 
\emph on
alloc
\emph default
):
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_deeper
\begin_layout LyX-Code
        #
\end_layout

\begin_layout LyX-Code
        # Redirect the system call if we are selected for
\end_layout

\begin_layout LyX-Code
        # recv_softints
\end_layout

\begin_layout LyX-Code
        #
\end_layout

\begin_layout LyX-Code
        pushl   %eax
\end_layout

\begin_layout LyX-Code
        pushl   %ebp
\end_layout

\begin_layout LyX-Code
        movl    current_t, %ebp
\end_layout

\begin_layout LyX-Code
        addl    $60, %ebp               # THRTAB_SOFTINT_LISTENER_SID
\end_layout

\begin_layout LyX-Code
        movl    (%ebp), %eax
\end_layout

\begin_layout LyX-Code
        cmpl    $0, %eax
\end_layout

\begin_layout LyX-Code
        je      i386_sysc_alloc_pages_norm      # Normal system call
\end_layout

\begin_layout LyX-Code
        
\end_layout

\begin_layout LyX-Code
        # Redirect it
\end_layout

\begin_layout LyX-Code
        pushal
\end_layout

\begin_layout LyX-Code
        pushl   $0xC0
\end_layout

\begin_layout LyX-Code
        call    kremote_received
\end_layout

\begin_layout LyX-Code
        addl    $4, %esp
\end_layout

\begin_layout LyX-Code
        cmpl    $0, %eax
\end_layout

\begin_layout LyX-Code
        popal
\end_layout

\begin_layout LyX-Code
        jne     i386_sysc_alloc_pages_norm      # Normal execution, if Trace-Onl
y
\end_layout

\begin_layout LyX-Code
        
\end_layout

\begin_layout LyX-Code
        # Return to user mode
\end_layout

\begin_layout LyX-Code
        popl    %ebp
\end_layout

\begin_layout LyX-Code
        popl    %eax
\end_layout

\begin_layout LyX-Code
        jmp     i386_do_context_switch
\end_layout

\begin_layout LyX-Code
i386_sysc_alloc_pages_norm:
\end_layout

\end_deeper
\begin_layout Standard
Im ersten Teil des Erkennungscodes wird überprüft, ob 
\emph on
THRTAB_SOFTINT_LISTENER_SID
\emph default
 (das liegt am 60.
 Byte des Threadsdeskriptors) einen Wert ungleich 0 hat.
 Ist dem nicht so, wird der Systemaufruf normal bei 
\emph on
i386_sysc_alloc_pages_norm
\emph default
 (das Prefix 
\emph on
_norm
\emph default
 ist dabei bei allen Systemaufrufen identisch verwendet) fortgesetzt.
 Ist der Wert ungleich 0, wird 
\emph on
kremote_received
\emph default
 gestartet, um den Systemaufruf umzulenken.
 Nach dessen Aufruf wird geprüft, ob das System den Systemaufruf zusätzlich
 dennoch ausführen soll (
\emph on
kremote_received
\emph default
 gibt einen Wert ungleich 0 zurück), oder ob der Systemaufruf zu ignorieren
 ist (siehe Flag 
\family typewriter
RECV_TRACE_SYSCALL
\family default
 in 
\begin_inset LatexCommand \ref{RECV_TRACE_SYSCALL}

\end_inset

) und nach dessen Ende mit dem Kontext-Wechsel durch 
\emph on
i386_do_context_switch
\emph default
 fortgefahren.
\end_layout

\begin_layout Subsubsection
Erkennung eines Software-Interrupts einer Exceptions oder eines IRQs
\end_layout

\begin_layout Standard
Da die Software-Interrupts, die von Exceptions oder IRQs verwendet werden,
 prinzipiell auch umgeleitet werden können müssen (es könnte ja z.B.
 sein, dass ein emuliertes Betriebssystem die von den IRQs belegten Softwareinte
rrupts für seine Systemaufrufe verwendet), aber andererseits die Software-Interr
upts von IRQs und Exceptions vor Zugriffen aus dem Benutzermodus gesperrt
 werden müssen, ist für die Erkennung dieser Software-Interrupts eine besondere
 Maßnahme erforderlich.
\end_layout

\begin_layout Standard
Immer wenn ein Thread einen Software-Interrupt aufruft, der von einem IRQ
 oder einer Exception belegt ist (abgesehen von einigen wenigen, zulässigen
 Exceptions), erzeugt er eine allgemeine Schutzverletzung.
 Im Fehlercode der Schutzverletzung ist erkennbar, dass die Fehlerursache
 ein ungültiger Zugriff auf die IDT war.
 Ebenfalls im Fehlercode enthalten ist die Nummer des aufgerufenen Software-Inte
rrupts.
 Diese Nummer kann an 
\emph on
kremote_received
\emph default
 dann zur weiteren Verarbeitung weitergegeben werden.
\end_layout

\begin_layout Standard
Diese Überprüfung findet in der kernelseitigen Exceptionbehandlung 
\emph on
ksched_handle_except
\emph default
 (
\emph on
intr.c
\emph default
, 
\emph on
sched.h
\emph default
) statt, wenn bei einem Thread die Interrupt-Umleitung aktiviert ist.
 Ein Problem ist jedoch, dass bei Auftreten der allgemeinen Schutzverletzung
 (Exception 13) der Programmzeiger an der Adresse der fehlerhaften Instruktion
 stehenbleibt.
 Der Kernel muss daher den Programmzeiger des Threads entsprechend ändern.
 Ein Interrupt kann bei x86-Systemen durch die Instruktionen 
\emph on
INT
\emph default
, 
\emph on
INT3
\emph default
 un 
\emph on
INTO
\emph default
 ausgelöst werden.
 Da diese Instruktionen unterschiedliche Längen haben, bleibt dem Kernel
 nichts anderes übrig, als die Codestelle zu disassemblieren, die den Fehler
 auslöste, um dann dementsprechend den Programmzeiger zu ändern.
 An dieser Stelle muss der Kernel auf den virtuellen Benutzeradressraum
 zugreifen, was über eine Änderung des 
\emph on
ES
\emph default
-Segmentselektos geschieht.
 Die komplette Codestelle lautet wie folgt:
\end_layout

\begin_layout LyX-Code
asm("pushl %%es
\backslash
n"
\end_layout

\begin_layout LyX-Code
    "movw $0x33, %%ax
\backslash
n"
\end_layout

\begin_layout LyX-Code
    "movw %%ax, %%es
\backslash
n"
\end_layout

\begin_layout LyX-Code
    "movb %%es:(%%ebx), %%al
\backslash
n"
\end_layout

\begin_layout LyX-Code
    "popl %%es
\backslash
n"
\end_layout

\begin_layout LyX-Code
    : "=a" (l__instr)
\end_layout

\begin_layout LyX-Code
    : "b"(l__stack[12])
\end_layout

\begin_layout LyX-Code
    : "memory"
\end_layout

\begin_layout LyX-Code
   );
\end_layout

\begin_layout Standard
Zunächst wird der ES-Deskriptor auf den Stack gesichert.
 Anschließend wird der Selektor 
\emph on
0x33
\emph default
 geladen, der auf das Datensegment im Benutzermodus verweist.
 Dieses Datensegment wird nach ES geladen.
 Über das Register EBX, das im voraus mit dem Code-Zeiger des Programms
 geladen wurde, wird anschließend die Instruktion ausgelesen.
 Zum Schluß wird ES wiederhergestellt.
\end_layout

\begin_layout Subsubsection
Weitergabe normaler Exceptions
\end_layout

\begin_layout Standard
Verursacht ein Thread eine Exception, so wird die Exception nicht an den
 Paging-Dämon, sondern an den überwachenden Thread weitergeleitet.
 Der überachende Thread kann die weiteren Daten über die aufgetretene Exception
 aus dem Deskriptor des fehlerhaften Threads auslesen.
\end_layout

\begin_layout Standard
Die Umleitung geschiet in den Routinen 
\emph on
kpaged_pagefault_to_usermode
\emph default
 und 
\emph on
kpaged_exception_to_usermode
\emph default
 (
\emph on
paged.c
\emph default
), die im Kapitel über den Paging-Dämon näher erläutert werden.
\end_layout

\begin_layout Chapter
Pagingoperationen
\end_layout

\begin_layout Section
Der Paging-Dämon
\end_layout

\begin_layout Standard
Der 
\emph on
hymk
\emph default
 besitzt zu einem Prozess im System eine besondere Beziehung: Dem Paging
 Dämon.
 Dieser Prozess hat erweiterte Rechte, aber auch Aufgaben.
 So kann der Paging-Dämon ungehindert auf den virtuellen Adressraum anderer
 Prozesse zugreifen und wird möglicherweise in späteren Versionen des 
\emph on
hymk
\emph default
 ebenfalls direkten Zugriff auf Seitentabellen und Seitenverzeichnisse anderer
 Prozesse erhalten.
 
\end_layout

\begin_layout Standard
Auf der anderen Seite ist der Paging Dämon für das saubere Beenden von Prozessen
 und Threads zuständig und nimmt alle unbehandelten Ausnahmefehler entgegen.
 Da er an dieser Stelle einen gewissen Flaschenhals darstellt, muss der
 Paging-Dämon sehr effizient implementiert sein.
\end_layout

\begin_layout Subsection
Weitergabe von Ausnahmefehlern
\end_layout

\begin_layout Standard
Wie jedes andere Programm auch, kommuniziert der Paging-Dämon mit dem Kernel
 über den 
\emph on
sync
\emph default
-Systemaufruf.
 Der Thread, der sich beim Kernel über den Aufruf 
\emph on
set_paged
\emph default
 als Paging-Dämon angemeldet hat, synchronisiert sich ständig mit dem Kernel-Pla
tzhalter.
 Tritt eine Exception auf, synchronisiert der Kernel den fehlerhaften Thread
 mit dem Paging-Dämon und friert ihn anschließend ein.
 Der Paging-Dämon erhält als Rückgabewert der 
\emph on
sync
\emph default
-Operation die SID des fehlerhaften Threads und kann über den Thread-Deskriptor
 die Informationen zum aufgetretenen Fehler auslesen.
\end_layout

\begin_layout Standard
Dieser Vorgang ist im wesentlichen in der Routine 
\emph on
kpaged_message_send
\emph default
 (
\emph on
paged.c
\emph default
) implementiert.
 Diese Routine wird durch die Exception-Behandlung des Kernels ausgelöst.
 Tritt eine Exception auf, startet der Kernel über 
\emph on
ksched_exception_to_user_mode
\emph default
 (
\emph on
intr.c
\emph default
) normalerweise die Funktion 
\emph on
kpaged_handle_exception
\emph default
 (
\emph on
paged.c
\emph default
, 
\emph on
sched.h
\emph default
)
\begin_inset Foot
status collapsed

\begin_layout Standard
 Ausnahmen hiervon werden nur bei überwachten Interrupts, einer Kernel-Mode-Exce
ption oder aber bei einer durch Copy-On-Write verursachten Exception gemacht.
 
\end_layout

\end_inset

.
 Diese Funktion prüft zunächst ob ein Paging-Dämon installiert ist oder
 nicht und ob die Exception durch den Paging-Dämon ausgelöst wurde.
 Existiert kein Paging-Dämon oder verursachte der Paging-Dämon selbst die
 Exception, so wird das System angehalten.
 
\end_layout

\begin_layout Standard
In den anderen Fällen wird die Exception näher untersucht.
 Handelte es sich um einen Page Fault (
\emph on
EXC_X86_PAGE_FAULT
\emph default
), so wird die Funktion 
\emph on
kpaged_pagefault_to_usermode
\emph default
 (
\emph on
paged.c
\emph default
) mit der Untersuchung und Behandlung der Exception weiter beauftragt.
 Handelte es sich um eine andere Exception, so wird diese an die Funktion
 
\emph on
kpaged_exception_to_usermode
\emph default
 (
\emph on
paged.c
\emph default
) weitergeleitet.
 
\end_layout

\begin_layout Standard
Gibt eine der Funktionen 1 als Rückgabewert zurück, so wird dieser Rückgabewert
 auch an den Aufrufer von 
\emph on
kpaged_handle_exception
\emph default
 weitergegeben.
 Der Rückgabewert 1 bedeutet, dass die Exception im Kernel-Modus verbleibt
 und der Kernel das System anhalten soll.
\end_layout

\begin_layout Subsubsection
Behandlung eines Page-Faults
\end_layout

\begin_layout Standard
Bei einem Page Fault wird zunächst von 
\emph on
kpaged_pagefault_to_usermode
\emph default
 die Adresse des Page-Faults durch auslesen des 
\emph on
CR2
\emph default
-Registers der CPU ermittelt.
 Über den Aufruf 
\emph on
kpaged_send_pagefault 
\emph default
wird der Page-Fault dann an den Paging-Dämon weitergeleitet: Dazu wird der
 zuständige Seitendeskriptor mittels 
\emph on
kmem_get_table 
\emph default
ermittelt (
\emph on
page.h
\emph default
), wobei fehlende Seitentabellen weder erzeugt, noch nachgeladen werden.
 Die ermittelten Daten werden in die entsprechenden Felder des Deskriptors
 des betroffenen Threads eingetragen.
 Ist eine Umleitung auf die Software-Interrupts des Threads aktiviert, wird
 die Exception mit Hilfe von 
\emph on
kremote_received
\emph default
 (
\emph on
remote.c
\emph default
, 
\emph on
sched.h
\emph default
)
\emph on
 
\emph default
weiterdelegiert.
 Andernfalls wird sie über 
\emph on
kpaged_message_send
\emph default
 (
\emph on
paged.c
\emph default
) an den Paging-Dämon übergeben.
\end_layout

\begin_layout Standard
Die Felder mit den Informationen über den Page-Fault sind: 
\emph on
THRTAB_LAST_EXCPT_NUMBER
\emph default
 (plattformunabhängige Nummer der Exception - in diesem Fall 
\emph on
EXC_INVALID_PAGE
\emph default
), 
\emph on
THRTAB_LAST_EXCPT_NR_PLATTFORM
\emph default
 (x86-spezifische Nummer der Exception - in diesem Fall 
\emph on
EXC_X86_PAGEFAULT
\emph default
), 
\emph on
THRTAB_LAST_EXCPT_ERROR_CODE
\emph default
 (x86-spezifischer Fehlercode), 
\emph on
THRTAB_LAST_EXCPT_ADDRESS
\emph default
 (Programmadresse, an dem die Exception auftrat), 
\emph on
THRTAB_PAGEFAULT_LINEAR_ADDRESS
\emph default
 (Lineare Adresse an welcher der Page-Fault auftrat) und 
\emph on
THRTAB_PAGEFAULT_DESCRIPTOR
\emph default
 (Seitendeskriptor der betrofefnen Seite).
 
\end_layout

\begin_layout Standard
Hierbei sei anzumerken, dass ein Page-Fault, den der Aufruf 
\emph on
unmap
\emph default
 durch das gesetzte Flag 
\emph on
GENFLAG_PAGED_PROTECTED
\emph default
 ausgelöst hat, den Parameter 
\emph on
THRTAB_LAST_EXCPT_NR_PLATTFORM
\emph default
 auf den Wert 0xABCD setzt und weder eine IP, noch einen Fehlercode übermittelt.
 Tritt dieser speziell Fall auf, kann der Paging-Dämon daraus schließen,
 dass auf die betroffene Seite eine 
\emph on
unmap
\emph default
-Operation ausgeführt werden soll.
\end_layout

\begin_layout Subsubsection
Behandlung einer Exception
\end_layout

\begin_layout Standard
Alle anderen Exception werden durch 
\emph on
kapged_exception_to_usermode
\emph default
 weiterverarbeitet.
 Diese Funktion übersetzt zunächst die x86-spezifische Exceptionnummer in
 eine 
\emph on
hymk
\emph default
-spezifische Fehlernummer.
 Anschließend werden die Deskriptor-Fehler des fehlerhaften Threads mit
 den Informationen über die Exception gefüllt.
 Diese Felder sind 
\emph on
THRTAB_LAST_EXCPT_NUMBER
\emph default
 (plattformunabhängige Nummer der Exception), 
\emph on
THRTAB_LAST_EXCPT_NR_PLATTFORM
\emph default
 (x86-spezifische Nummer der Exception), 
\emph on
THRTAB_LAST_EXCPT_ERROR_CODE 
\emph default
86-spezifischer Fehlercode) und
\emph on
 THRTAB_LAST_EXCPT_ADDRESS 
\emph default
(Programmadresse, an dem die Exception auftrat)
\emph on
.

\emph default
 
\end_layout

\begin_layout Standard
Existiert eine Interrupt-Umleitung, wird diese über 
\emph on
kremote_received
\emph default
 (
\emph on
remote.c
\emph default
, 
\emph on
sched.h
\emph default
) getätigt.
 Andernfalls wird die Exception über 
\emph on
kpaged_message_send
\emph default
 (
\emph on
paged.c
\emph default
) an den Paging-Dämon weitergegeben.
\end_layout

\begin_layout Subsection
Installation des Paging-Dämons
\end_layout

\begin_layout Standard
Der Paging-Dämon wird durch den Systemaufruf 
\emph on
set_paged
\emph default
, implementiert in der Funktion 
\emph on
sysc_set_paged
\emph default
 (
\emph on
paged.c
\emph default
, 
\emph on
sysc.h
\emph default
) installiert.
 Hierbei wird die interne Variable 
\emph on
paged_thr_sid
\emph default
 auf die SID des aufrufenden Threads gesetzt.
 Diese SID wird später bei Synchronisationen mit dem Paging-Dämon verwendet.
 Im Prozess-Deskriptor des Paging-Dämons wird das Feld 
\emph on
PRCTAB_IS_PAGED
\emph default
 auf 1 gesetzt, wodurch alle Threads dieses Prozesses die volle Berechtigung
 des Paging-Dämons erhalten.
\end_layout

\begin_layout Subsection
Anmerkungen
\end_layout

\begin_layout Standard
Derzeit ist noch kein Paging-Dämon für HydrixOS implementiert worden.
 Da es sich während der Implementierung des Dienstes möglicherweise ergeben
 kann, dass dem Paging-Dämon weitere Rechte eingeräumt werden müssen oder
 Schnittstellenänderungen erforderlich sein können, müssen die Angaben über
 die Schnittstelle zum Paging-Dämon derzeit noch als vorläufig betrachtet
 werden.
 Weitere Details werden erst zur Verfügung stehen können, wenn die Entwicklung
 des Paging-Dämons angegangen wird.
\end_layout

\begin_layout Section
Copy-On-Write
\end_layout

\begin_layout Standard
Der 
\emph on
hymk
\emph default
 bietet zur Beschleunigung von Kopierverfahren zwischen Prozessen eine Implement
ierung des unter UNIX üblichen Copy-On-Write-Verfahrens an.
 Bei diesem Verfahren werden beim Kopieren von Speicherseiten, diese nicht
 sofort kopiert, sondern lediglich zwischen den Prozessen gemeinsam genutzt.
 Die Speicherseiten werden als schreibgeschützt markiert und für das Copy-On-Wri
te-Verfahren selektiert.
 Wird nun auf die Seite geschrieben, tritt ein Page-Fault auf.
 Der Kernel findet dabei heraus, dass die Seite für Copy-On-Write markiert
 ist und kopiert diese.
 Die Kopie wird in den Adressraum des anderen Prozesses beschreibbar und
 ohne Copy-On-Write-Flag eingeblendet und - sollte kein weiterer Prozess
 die Seite nutzen - im Quellprozess das Copy-On-Write gelöscht.
 Durch dieses Verfahren soll Rechenzeit und Speicherplatz gespart werden,
 da Erfahrungsgemäß oft Kopien von Daten zwischen Prozessen meistens lediglich
 gelesen und nur selten geändert werden (wie z.B.
 bei einer gemeinsam genutzten Programmbibliothek).
\end_layout

\begin_layout Subsubsection
Implementierung des Verfahrens bei Ausnahmefehlern
\end_layout

\begin_layout Standard
Die Selektierung für das Copy-On-Write-Verfahren erfolgt durch den Systemaufruf
 
\emph on
sysc_map
\emph default
, wenn der Parameter 
\emph on
MAP_COPYONWRITE
\emph default
 gesetzt ist.
 Hierbei wird beim Einblenden der Seite in den Zieladressraum, wie auch
 im Quelladressraum das Copy-On-Write-Flag gesetzt und der Schreibschutz
 der Seite aktiviert.
\end_layout

\begin_layout Standard
Bei einem Zugriff auf eine Seite tritt auf x86-Plattformen die Page-Fault-Except
ion auf.
 Diese wird auf unterster Ebene durch 
\emph on
ksched_handle_except
\emph default
 behandelt.
 Erkennt die Routine einen Pagefault (
\emph on
EXC_X86_PAGEFAULT
\emph default
) und wurde dieser durch einen Zugriff auf eine schreibgeschützte Speicherseite
 im Benutzermodus erzeugt, so wird die weitere Überprüfung durch 
\emph on
kmem_copy_on_write
\emph default
 (
\emph on
page.c
\emph default
, 
\emph on
mem.h
\emph default
) übernommen.
 Wird hier eine andere Ursache für die Exception erkannt, wird die Exception
 normal über 
\emph on
ksched_exception_to_user_mode
\emph default
 (
\emph on
intr.c
\emph default
) weiterbehandelt.
\end_layout

\begin_layout Standard
Die Funktion 
\emph on
kmem_copy_on_write
\emph default
 sucht anschließend die Adresse des Zugriffs und gibt die Durchführung des
 Copy-On-Write-Auftrags an 
\emph on
kmem_do_copy_on_write 
\emph default
(
\emph on
page.c
\emph default
, 
\emph on
mem.h
\emph default
) weiter.
 
\emph on
kmem_do_copy_on_write
\emph default
 prüft nun die Ursache, indem nach dem gesetzten Flag 
\emph on
GENFLAG_DO_COPYONWRITE
\emph default
 im Seitendeskriptor gesucht wird.
 Ist er nicht vorhanden, wird die Funktion mit einem entsprechenden Rückgabewert
 beendet.
 Anschließend wird geprüft, ob die Seite für Copy-On-Write noch in Frage
 kommt, oder ob der Prozess, der den Page-Fault auslöste nur noch der einzige
 Prozess ist, der auf die Seite zugreift.
 Ist dem so, wird die Copy-On-Write-Markierung und der Schreibschutz der
 Seite aufgehoben und der Page-Fault als behandelt erklärt.
\end_layout

\begin_layout Standard
Andernfalls wird durch 
\emph on
kmem_alloc_user_pagefrage
\emph default
 (
\emph on
alloc.c
\emph default
, 
\emph on
mem.h
\emph default
) ein neuer Seitenrahmen reserviert.
 Im UMCA werden sowohl Quell- als auch Zielrahmen eingeblendet, so dass
 der Kernel Zugriff auf die Seiten erhalten kann (siehe 
\begin_inset LatexCommand \ref{UMCA}

\end_inset

).
 Anschließend wird der TLB für den verwendeten UMCA-Bereich invalidiert
 und die Daten werden zwischen der Quell- und Zielseite kopiert.
 Nachdem die Seiten aus dem UMCA wieder entfernt wurden, wird die neue Seite
 in den Adressraum des Aufrufers eingeblendet und der Aufrufer aus der Besitzerl
iste der Quellseite durch 
\emph on
kmem_free_user_pageframe
\emph default
 (
\emph on
alloc.c
\emph default
, 
\emph on
mem.h
\emph default
) entfernt.
 Zum Schluß wird ebenfalls der TLB für die neue Seite invalidiert, so dass
 nach Wiedereintritt in den Benutzermodus der Zugriff auf die neue Seite
 erfolgen kann.
\end_layout

\begin_layout Standard
Gibt 
\emph on
kmem_do_copy_on_write
\emph default
 bzw.
 
\emph on
kmem_copy_on_write 
\emph default
den Rückgabewert 0 zurück, gilt der Page-Fault als behandelt.
 Bei anderen Rückgabewerten muss die Exception, wie bereits erwähnt, weitergelei
tet werden.
\end_layout

\begin_layout Subsubsection
Implementierung des Verfahrens bei 
\emph on
map
\end_layout

\begin_layout Standard
Während eines 
\emph on
map
\emph default
-Vorgangs kann ebenfalls die Durchführung von Copy-On-Write erforderlich
 werden: Soll eine Seite gemeinsam zwischen Prozessen genutzt werden, die
 für 
\emph on
Copy-On-Write
\emph default
 vorgemerkt ist, dann wird das zwangsläufig zu Inkonsistenzen führen, da
 spätestens bei einem Schreibzugriff durch einen der beiden Prozesse der
 Copy-On-Write-Mechanismus anlaufen würde und die gemeinsame Speichernutzung
 aufgebrochen werden würde.
 Ein direktes Sharen einer mit Copy-On-Write markierten Speicherseite ist
 nur dann erwünscht, wenn das Share selbst ebenfalls ein Copy-On-Write-Share
 ist (map mit 
\emph on
MAP_COPYONWRITE
\emph default
).
 
\end_layout

\begin_layout Standard
Folglich muss wähernd der Etablierung des gemeinsamen Speicherbereichs die
 Seite im Quelladressraum zunächst mittels Copy-On-Write kopiert werden,
 so dass dann zwischen beiden Prozessen tatsächlich eine gemeinsam genutze
 Speicherseite existiert.
 Dazu ruft 
\emph on
sysc_map
\emph default
 die Funktion ebenfalls 
\emph on
kmem_do_copy_on_write
\emph default
 auf.
 Der Kopierforgang läuft dann wie bereits bekannt ab.
\end_layout

\end_body
\end_document
